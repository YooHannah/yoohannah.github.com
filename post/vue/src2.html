<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="vue," />





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="分析官网的流程图可知new Vue时，进行一系列initxxx初始化工作后会根据选项el和template配置情况去做编译即情况1：挂载了el和template情况下直接去将template编译成渲染函数情况2：挂载了el而没有挂载template情况下，将以el外部的html为template进行编译情况3：没有挂载el的情况下，需要手动调用$mount函数挂载，这时再去判断有没有挂载templ">
<meta name="keywords" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="vue 源码学习二【编译器】">
<meta property="og:url" content="http://yoohannah.github.io/post/vue/src2.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:description" content="分析官网的流程图可知new Vue时，进行一系列initxxx初始化工作后会根据选项el和template配置情况去做编译即情况1：挂载了el和template情况下直接去将template编译成渲染函数情况2：挂载了el而没有挂载template情况下，将以el外部的html为template进行编译情况3：没有挂载el的情况下，需要手动调用$mount函数挂载，这时再去判断有没有挂载templ">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoohannah.github.io/image/lifecycle.png">
<meta property="og:updated_time" content="2020-02-26T15:26:22.982Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue 源码学习二【编译器】">
<meta name="twitter:description" content="分析官网的流程图可知new Vue时，进行一系列initxxx初始化工作后会根据选项el和template配置情况去做编译即情况1：挂载了el和template情况下直接去将template编译成渲染函数情况2：挂载了el而没有挂载template情况下，将以el外部的html为template进行编译情况3：没有挂载el的情况下，需要手动调用$mount函数挂载，这时再去判断有没有挂载templ">
<meta name="twitter:image" content="http://yoohannah.github.io/image/lifecycle.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/post/vue/src2.html"/>





  <title> vue 源码学习二【编译器】 | My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/vue/src2.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                vue 源码学习二【编译器】
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-05T12:41:15+08:00">
                2020-02-05
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/image/lifecycle.png" alt="Vue声明周期"><br>分析官网的流程图可知<br>new Vue时，进行一系列initxxx初始化工作后会根据选项el和template配置情况去做编译<br>即<br>情况1：挂载了el和template情况下直接去将template编译成渲染函数<br>情况2：挂载了el而没有挂载template情况下，将以el外部的html为template进行编译<br>情况3：没有挂载el的情况下，需要手动调用$mount函数挂载，这时再去判断有没有挂载template，在进行依据template有无继续接下来的编译工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._init = function (options) &#123;</div><div class="line">    var vm = this;</div><div class="line">    vm._uid = uid$3++;</div><div class="line">    var startTag, endTag;</div><div class="line">    vm._isVue = true;  // 防止被监听的标识</div><div class="line">    //合并内置选项与传进来的选项</div><div class="line">    if (options &amp;&amp; options._isComponent) &#123;</div><div class="line">      initInternalComponent(vm, options);</div><div class="line">    &#125; else &#123;</div><div class="line">      vm.$options = mergeOptions(</div><div class="line">        resolveConstructorOptions(vm.constructor),</div><div class="line">        options || &#123;&#125;,</div><div class="line">        vm</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">    /* istanbul ignore else */</div><div class="line">    &#123;</div><div class="line">      initProxy(vm);</div><div class="line">    &#125;</div><div class="line">    //进行一系列初始化</div><div class="line">    vm._self = vm;</div><div class="line">    initLifecycle(vm);</div><div class="line">    initEvents(vm);</div><div class="line">    initRender(vm);</div><div class="line">    callHook(vm, &apos;beforeCreate&apos;);</div><div class="line">    initInjections(vm); </div><div class="line">    initState(vm);//对数据进行劫持</div><div class="line">    initProvide(vm); </div><div class="line">    callHook(vm, &apos;created&apos;);</div><div class="line"></div><div class="line">    if (vm.$options.el) &#123; //判断有没有配置el,有则调用vm.$mount进入情况1和2，没有则进入情况3，等待手动调用vm.$mount</div><div class="line">      vm.$mount(vm.$options.el);//生成渲染函数后，给option挂上render，staticRenderFns属性</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="mount挂载函数的巧妙设计"><a href="#mount挂载函数的巧妙设计" class="headerlink" title="$mount挂载函数的巧妙设计"></a>$mount挂载函数的巧妙设计</h1><p>一开始定义的$mount仅用于运行时，功能是将编译好的渲染函数运行实现挂载组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$mount = function ( </div><div class="line">  el,</div><div class="line">  hydrating</div><div class="line">) &#123;</div><div class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined;</div><div class="line">  return mountComponent(this, el, hydrating)</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>之后会将运行时定义存放到另一个变量<br>方便定义之后包含编译步骤的挂载函数，<br>同时编译运行方案还会调用这个函数<br>这样在打包时，就可以方便的去掉进行编译过程的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var mount = Vue.prototype.$mount;</div></pre></td></tr></table></figure></p>
<p>在定义含有编译过程的挂载函数，将template编译成渲染函数<br>再调用运行时$mount(这时依托在mount变量上)，进行挂载组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$mount = function (</div><div class="line">  el,</div><div class="line">  hydrating</div><div class="line">) &#123;</div><div class="line">  el = el &amp;&amp; query(el);//query检查挂载点dom是否存在</div><div class="line">  //不要挂载到&lt;body&gt;元素或者&lt;html&gt;元素,</div><div class="line">  //因为挂载点的本意是组件挂载的占位，它将会被组件自身的模板替换掉，而&lt;body&gt;元素和&lt;html&gt;元素是不能被替换掉的。</div><div class="line">  if (el === document.body || el === document.documentElement) &#123;</div><div class="line">    warn(</div><div class="line">      &quot;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&quot;</div><div class="line">    );</div><div class="line">    return this</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var options = this.$options;</div><div class="line">  // 解析 template/el 转换成render函数</div><div class="line">  if (!options.render) &#123;</div><div class="line">    var template = options.template;</div><div class="line">    if (template) &#123; //配置了template</div><div class="line">      if (typeof template === &apos;string&apos;) &#123;</div><div class="line">        //如果第一个字符是 #，那么会把该字符串作为 css 选择符</div><div class="line">        //去选中对应的元素，并把该元素的 innerHTML 作为模板</div><div class="line">        if (template.charAt(0) === &apos;#&apos;) &#123;</div><div class="line">          template = idToTemplate(template);</div><div class="line">          if (!template) &#123;</div><div class="line">            warn((&quot;Template element not found or is empty: &quot; + (options.template)),this);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; else if (template.nodeType) &#123; </div><div class="line">        //如果第一个字符不是 #，且template的类型是元素节点,</div><div class="line">        //那就用 template 自身的字符串值作为模板</div><div class="line">        template = template.innerHTML;</div><div class="line">      &#125; else &#123;&#123; warn(&apos;invalid template option:&apos; + template, this);&#125;</div><div class="line">        //否则报错不存在配置的template</div><div class="line">        return this</div><div class="line">      &#125;</div><div class="line">    &#125; else if (el) &#123; //如果template选项不存在，那么使用el元素的outerHTML作为模板内容</div><div class="line">      template = getOuterHTML(el);</div><div class="line">    &#125;</div><div class="line">    if (template) &#123;</div><div class="line">      //编译生成静态结点渲染函数和动态结点渲染函数</div><div class="line">      var ref = compileToFunctions(template, &#123;...参数下文有说明&#125;, this);</div><div class="line">      var render = ref.render;</div><div class="line">      var staticRenderFns = ref.staticRenderFns;</div><div class="line">      //生成渲染函数后，给option挂上render，staticRenderFns渲染函数属性</div><div class="line">      options.render = render;</div><div class="line">      options.staticRenderFns = staticRenderFns;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return mount.call(this, el, hydrating) //调用运行时挂载函数</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="compileToFunctions"><a href="#compileToFunctions" class="headerlink" title="compileToFunctions"></a>compileToFunctions</h1><p>compileToFunctions 作用就两个<br>1.调用compile编译生成渲染函数字符串<br>2.将渲染函数字符串生成渲染返回返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">function createCompileToFunctionFn (compile) &#123;</div><div class="line">  var cache = Object.create(null);</div><div class="line">  return function compileToFunctions (template, options,vm) &#123;</div><div class="line">    options = extend(&#123;&#125;, options);</div><div class="line">    var warn$$1 = options.warn || warn;</div><div class="line">    delete options.warn;</div><div class="line">      &#123;  //检测 new Function() 是否可用，</div><div class="line">         //在某些极端情况下(如CSP限制)给一个有用的提示</div><div class="line">        try &#123;new Function(&apos;return 1&apos;);&#125; catch (e) &#123;</div><div class="line">          if (e.toString().match(/unsafe-eval|CSP/)) &#123;</div><div class="line">            warn$$1(...警告内容);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    // 有缓存直接返回缓存，不用在进行编译一次，</div><div class="line">    // cache在闭包父域定义，相当于全局，</div><div class="line">    // 所以每次编译的结果都可以缓存起来</div><div class="line">    //options.delimiters这个选项是配置纯文本插入分隔符</div><div class="line">    //这里用来拼接做缓存key值</div><div class="line">    var key = options.delimiters </div><div class="line">      ? String(options.delimiters) + template</div><div class="line">      : template;</div><div class="line">    if (cache[key]) &#123;</div><div class="line">      return cache[key]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //调用 baseCompile编译模板并返回其生成的值 </div><div class="line">    var compiled = compile(template, options);</div><div class="line"></div><div class="line">    //将字符串代码转换成函数</div><div class="line">    var res = &#123;&#125;;</div><div class="line">    var fnGenErrors = [];</div><div class="line">    res.render = createFunction(compiled.render, fnGenErrors);</div><div class="line">    res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123;</div><div class="line">      return createFunction(code, fnGenErrors)</div><div class="line">    &#125;);</div><div class="line">    return (cache[key] = res)//缓存字符串模板的编译结果，防止重复编译，提升性能</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>try-catch语句如果有错误发生且错误的内容中<br>包含如 ‘unsafe-eval’ 或者 ‘CSP’ 这些字样的信息时就会给出一个警告</p>
<p>CSP全称Content Security Policy ,可以直接翻译为内容安全策略<br>就是为了页面内容安全而制定的一系列防护策略<br>通过CSP所约束的的规责指定可信的内容来源<br>（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。<br>通过CSP协定，让WEB处于一个安全的运行环境中</p>
<p>如果你的策略比较严格，那么 new Function() 将会受到影响，从而不能够使用<br>但是将模板字符串编译成渲染函数又依赖 new Function()，所以解决方案有两个：<br>1、放宽你的CSP策略<br>2、预编译</p>
<h1 id="一些变量参数说明"><a href="#一些变量参数说明" class="headerlink" title="一些变量参数说明"></a>一些变量参数说明</h1><p>因为之后分析会用到，事先了解一下</p>
<h2 id="变量之间关系"><a href="#变量之间关系" class="headerlink" title="变量之间关系"></a>变量之间关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var modules$1 = [</div><div class="line">	klass$1,</div><div class="line">	style$1,</div><div class="line">	model$1</div><div class="line">];</div><div class="line"></div><div class="line">var klass$1 = &#123;</div><div class="line">	staticKeys: [&apos;staticClass&apos;],</div><div class="line">	transformNode: transformNode,</div><div class="line">	genData: genData</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var style$1 = &#123;</div><div class="line">	staticKeys: [&apos;staticStyle&apos;],</div><div class="line">	transformNode: transformNode$1,</div><div class="line">	genData: genData$1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var model$1 = &#123;</div><div class="line">	preTransformNode: preTransformNode</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="baseOptions"><a href="#baseOptions" class="headerlink" title="baseOptions"></a>baseOptions</h2><p>baseOptions包含编译器在运作的时候所需的基本配置选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var baseOptions = &#123;</div><div class="line">  expectHTML: true,</div><div class="line">  modules: modules$1,</div><div class="line">  directives: directives$1,</div><div class="line">  isPreTag: isPreTag,</div><div class="line">  isUnaryTag: isUnaryTag,</div><div class="line">  mustUseProp: mustUseProp,</div><div class="line">  canBeLeftOpenTag: canBeLeftOpenTag,</div><div class="line">  isReservedTag: isReservedTag,</div><div class="line">  getTagNamespace: getTagNamespace,</div><div class="line">  staticKeys: genStaticKeys(modules$1)</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>第三个属性：directives 值是三个属性 (model、text、html) 的对象，且属性的值都是函数。<br>第四个属性：isPreTag 它是一个函数，其作用是通过给定的标签名字检查标签是否是 ‘pre’ 标签。<br>第五个属性：isUnaryTag 是一个通过makeMap生成的函数，该函数的作用是检测给定的标签是否是一元标签。<br>第六个属性：mustUseProp 它是一个函数，其作用是用来检测一个属性在标签中是否要使用props进行绑定。<br>第七个属性：canBeLeftOpenTag 一个使用makeMap生成的函数，它的作用是检测非一元标签，但却可以自己补全并闭合的标签。比如 div 标签是一个双标签，你需要这样使用&lt;div&gt; text &lt;/div&gt;，但是你依然可以省略闭合标签，直接这样写：&lt;div&gt; text ，且浏览器会自动补全。但是有些标签你不可以这样用，它们是严格的双标签。<br>第八个属性：isReservedTag 它是一个函数，其作用是检查给定的标签是否是保留的标签。<br>第九个属性：getTagNamespace 它也是一个函数，其作用是获取元素(标签)的命名空间。<br>第十个属性：staticKeys 它的值是通过以 modules 为参数调用 genStaticKeys 函数的返回值得到的。 其作用是根据编译器选项的 modules 选项生成一个静态键字符串。</p>
<h2 id="compileToFunctions传入的参数"><a href="#compileToFunctions传入的参数" class="headerlink" title="compileToFunctions传入的参数"></a>compileToFunctions传入的参数</h2><p>实际调用时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ref = compileToFunctions(template, &#123;</div><div class="line">  outputSourceRange: &quot;development&quot; !== &apos;production&apos;,</div><div class="line">  shouldDecodeNewlines: shouldDecodeNewlines,</div><div class="line">  shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,</div><div class="line">  delimiters: options.delimiters,//更改纯文本插入符</div><div class="line">  comments: options.comments//设置为true时，保留且渲染模板HTML注释，false时舍弃注释</div><div class="line">&#125;, this);</div></pre></td></tr></table></figure></p>
<p>参数说明<br>在我们innerHTML获取内容时，换行符和制表符分别被转换成了&amp;#10和&amp;#9。<br>在IE中，不仅仅是 a 标签的 href 属性值，任何属性值都存在这个问题<br>这就会影响Vue的编译器在对模板进行编译后的结果，为了避免这些问题Vue需要知道什么时候要做兼容工作，<br>如果 shouldDecodeNewlines 为 true，意味着 Vue 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。<br>而shouldDecodeNewlinesForHref为true 意味着Vue在编译模板的时候，要对a标签的 href 属性值中的换行符或制表符做兼容处理。<br>delimiters和comments都是 Vue 提供的选项，Vue实例的$options属性<br>delimiters代表纯文本插入分隔符<br>comments代表编译时是否保留注释，会在parse阶段进行判断</p>
<h1 id="compiler编译器生成"><a href="#compiler编译器生成" class="headerlink" title="compiler编译器生成"></a>compiler编译器生成</h1><p>compiler的爷爷createCompilerCreator，<br>会生成compiler的爸爸createCompiler<br>createCompiler会生成compiler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">function createCompilerCreator (baseCompile) &#123;</div><div class="line">  return function createCompiler (baseOptions) &#123;</div><div class="line">    function compile (</div><div class="line">      template,</div><div class="line">      options</div><div class="line">    ) &#123;</div><div class="line">      //所有的配置选项最终都会挂载在这个finalOptions 对象上</div><div class="line">      var finalOptions = Object.create(baseOptions);</div><div class="line">      var errors = [];</div><div class="line">      var tips = [];</div><div class="line">      var warn = function (msg, range, tip) &#123; (tip ? tips : errors).push(msg) &#125;;</div><div class="line">      //options为调用 compileToFunctions 函数时传递的选项参数。</div><div class="line">      //baseOptions理解为编译器的默认选项或者基本选项，options 是用来提供定制能力的扩展选项</div><div class="line">      if (options) &#123;</div><div class="line">        // merge custom modules</div><div class="line">        //如果 options.modules 存在，就在 finalOptions 对象上添加 modules 属性，</div><div class="line">        //其值为 baseOptions.modules 和 options.modules 这两个数组合并后的新数组</div><div class="line">        if (options.modules) &#123;</div><div class="line">          finalOptions.modules =</div><div class="line">            (baseOptions.modules || []).concat(options.modules);</div><div class="line">        &#125;</div><div class="line">        // merge custom directives</div><div class="line">        //对于directives 采用原型链的原理实现扩展属性对基本属性的覆盖</div><div class="line">        if (options.directives) &#123;</div><div class="line">          finalOptions.directives = extend(</div><div class="line">            Object.create(baseOptions.directives || null),</div><div class="line">            options.directives</div><div class="line">          );</div><div class="line">        &#125;</div><div class="line">        // copy other options</div><div class="line">        for (var key in options) &#123;</div><div class="line">          if (key !== &apos;modules&apos; &amp;&amp; key !== &apos;directives&apos;) &#123;</div><div class="line">            finalOptions[key] = options[key];</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      finalOptions.warn = warn;</div><div class="line"></div><div class="line">      var compiled = baseCompile(template.trim(), finalOptions);//调用 baseCompile并返回其生成的值</div><div class="line">      &#123;</div><div class="line">        detectErrors(compiled.ast, warn);</div><div class="line">      &#125;</div><div class="line">      compiled.errors = errors;</div><div class="line">      compiled.tips = tips;</div><div class="line">      return compiled</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">      compile: compile,</div><div class="line">      compileToFunctions: createCompileToFunctionFn(compile)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>传入实际编译器生成createCompiler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var createCompiler = createCompilerCreator(function baseCompile (</div><div class="line">  template,</div><div class="line">  options</div><div class="line">) &#123;</div><div class="line">  var ast = parse(template.trim(), options);</div><div class="line">  if (options.optimize !== false) &#123;</div><div class="line">    optimize(ast, options);</div><div class="line">  &#125;</div><div class="line">  var code = generate(ast, options);</div><div class="line">  return &#123;</div><div class="line">    ast: ast,</div><div class="line">    render: code.render,</div><div class="line">    staticRenderFns: code.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">var ref$1 = createCompiler(baseOptions);</div><div class="line">var compile = ref$1.compile;</div><div class="line">var compileToFunctions = ref$1.compileToFunctions;</div></pre></td></tr></table></figure></p>
<p>可见compileToFunctions也由createCompiler函数生成<br>createCompiler函数 由 createCompilerCreator函数在传入函数 baseCompile 条件下生成<br>在createCompiler函数中会声明compile函数,在compile中会调用 baseCompile并返回其生成的值<br>然后对 createCompileToFunctionFn 函数传入compile函数，返回一个函数即compileToFunctions<br>在compileToFunctions 函数中会调用compile函数并处理其返回值<br>最终生成render和staticRenderFns属性<br>所以可见在compileToFunctions还是在调用baseCompile来生成render和staticRenderFns属性，<br>现在摘出来主要逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//base函数</div><div class="line">function baseCompile (</div><div class="line">  template,</div><div class="line">  options</div><div class="line">) &#123;</div><div class="line">  var ast = parse(template.trim(), options);</div><div class="line">  if (options.optimize !== false) &#123;</div><div class="line">    optimize(ast, options);</div><div class="line">  &#125;</div><div class="line">  var code = generate(ast, options);</div><div class="line">  return &#123;</div><div class="line">    ast: ast,</div><div class="line">    render: code.render,</div><div class="line">    staticRenderFns: code.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// compileToFunctions调用compile</div><div class="line">// 实际调用 baseCompile得到其生成的值</div><div class="line">var compiled = compile(template, options);</div><div class="line"></div><div class="line">// 调用后处理</div><div class="line">//将字符串转成函数</div><div class="line">var res = &#123;&#125;;</div><div class="line">var fnGenErrors = [];</div><div class="line">res.render = createFunction(compiled.render, fnGenErrors);</div><div class="line">res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123;</div><div class="line">  return createFunction(code, fnGenErrors)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>baseCompile 的主要核心代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var ast =parse(template.trim(), options);</div></pre></td></tr></table></figure></p>
<p>parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">optimize(ast, options);</div></pre></td></tr></table></figure></p>
<p>optimize 的主要作用是标记 static 静态节点，<br>这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时<br>会有一个 patch 的过程， diff 算法会直接跳过静态节点<br>从而减少了比较的过程，优化了 patch 的性能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var code =generate(ast, options);</div></pre></td></tr></table></figure></p>
<p>生成目标平台所需的代码，将 AST 转化成 render function 字符串的过程<br>得到结果是 render 的字符串以及 staticRenderFns 字符串。</p>
<h1 id="编译器的基本知识"><a href="#编译器的基本知识" class="headerlink" title="编译器的基本知识"></a>编译器的基本知识</h1><p>编译器的技术分为词法分析、语法分析和语义分析三个部分，通常编译器的第一项工作叫做词法分析。就像阅读文章一样，文章是由一个个的中文单词组成的。程序处理也一样，只不过这里不叫单词，而是叫做“词法记号”，英文叫 Token。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot; v-if=&quot;ret&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>其实，我们可以手写程序制定一些规则来区分每个不同的 Token，这些规则用“正则文法”表达，符合正则文法的表达式称为“正则表达式”。通过他们来完成具体的词法分析工作。</p>
<p>编译器下一个阶段的工作是语法分析。词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构，是计算机容易理解和执行的。<br>程序也要定义良好的语法结构，它的语法分析过程，就是构造这么一棵树。一个程序就是一棵树，这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。</p>
<p>而我们这里要讲的 parser 就是在编译器对源代码处理的第一步，parser 把某种特定格式的文本（字符串）转换成某种数据结构的程序(对象)，并且这个数据结构是编译器能够理解的，因为编译器的后续步骤，比如上面提到的 句法分析，类型检查/推导，代码优化，代码生成 等等都依赖于该数据结构。</p>
<p><b>注：parse &amp; parser 这两个单词，不要混淆，parse 是动词，代表“解析”的过程，parser 是名词，代表“解析器”。</b><br>Vue 的编译器也不例外, 在词法分析阶段 Vue 会把字符串模板解析成一个个的令牌(token)，该令牌将用于句法分析阶段，在句法分析阶段会根据令牌生成一棵 AST，最后再根据该 AST生成最终的渲染函数，这样就完成了代码的生成。</p>
<h1 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h1><p>进入baseCompile第一步就是调用parse,Convert HTML string to AST 将HTML转成AST<br>//parse函数中会声明一系列变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">warn$2 = options.warn || baseWarn; //打印警告信息</div><div class="line">//一个编译器选项，其作用是通过给定的标签名字判断该标签是否是 pre 标签。</div><div class="line">platformIsPreTag = options.isPreTag || no;</div><div class="line">//一个编译器选项，其作用是用来检测一个属性在标签中是否要使用元素对象原生的 prop 进行绑定。</div><div class="line">platformMustUseProp = options.mustUseProp || no;</div><div class="line">//一个编译器选项，其作用是用来获取元素(标签)的命名空间。</div><div class="line">platformGetTagNamespace = options.getTagNamespace || no;</div><div class="line"></div><div class="line">transforms = pluckModuleFunction(options.modules, &apos;transformNode&apos;);</div><div class="line">preTransforms = pluckModuleFunction(options.modules, &apos;preTransformNode&apos;);</div><div class="line">postTransforms = pluckModuleFunction(options.modules, &apos;postTransformNode&apos;);</div><div class="line"></div><div class="line">delimiters = options.delimiters;//在创建 Vue 实例对象时所传递的 delimiters 选项。</div><div class="line"></div><div class="line">var stack = [];//存储开始标签，与解析到的闭合标签对比，进行一元标签处理和双标签判断处理</div><div class="line">//一个布尔值并且它的值与编译器选项中的options.preserveWhitespace选项有关，</div><div class="line">//只要 options.preserveWhitespace 的值不为false，那么 preserveWhitespace 的值就为真。</div><div class="line">//其中 options.preserveWhitespace 选项用来告诉编译器在编译 html 字符串时是否放弃标签之间的空格</div><div class="line">//如果为 true 则代表放弃。</div><div class="line">var preserveWhitespace = options.preserveWhitespace !== false;</div><div class="line">var whitespaceOption = options.whitespace;</div><div class="line">var currentParent;//维护元素描述对象之间的父子关系，当前节点父元素</div><div class="line">var inVPre = false;//初始值：false。标识当前解析的标签是否在拥有 v-pre 的标签之内。</div><div class="line">var inPre = false;//初始值：false。标识当前正在解析的标签是否在 &lt;pre&gt;&lt;/pre&gt; 标签之内。</div><div class="line">var root;//存储最终生成的AST</div></pre></td></tr></table></figure></p>
<p>parse 函数中会执行parseHTML函数，然后返回root,即AST<br>parseHTML 函数的作用就是用来做词法分析的<br>parse函数的作用则是在词法分析的基础上利用回调，做句法分析从而生成一棵AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">parseHTML(template, &#123;</div><div class="line">  warn: warn$2,</div><div class="line">  expectHTML: options.expectHTML,</div><div class="line">  isUnaryTag: options.isUnaryTag,</div><div class="line">  canBeLeftOpenTag: options.canBeLeftOpenTag,</div><div class="line">  shouldDecodeNewlines: options.shouldDecodeNewlines,</div><div class="line">  shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,</div><div class="line">  shouldKeepComment: options.comments,//对应配置项comments,true为保留模板中注释语句</div><div class="line">  outputSourceRange: options.outputSourceRange,</div><div class="line">  start: function start (tag, attrs, unary, start$1, end) &#123; //解析完一段模板的开始标签后的回调</div><div class="line">    // check namespace.</div><div class="line">    // inherit parent ns if there is one</div><div class="line">    var ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag);</div></pre></td></tr></table></figure></p>
<p>定义了 ns 变量，它的值为标签的命名空间，如何获取当前元素的命名空间呢？首先检测currentParent 变量是否存在，我们知道 currentParent 变量为当前元素的父级元素描述对象，如果当前元素存在父级并且父级元素存在命名空间，则使用父级的命名空间作为当前元素的命名空间。</p>
<p>如果父级元素不存在或父级元素没有命名空间那么会调用platformGetTagNamespace函数，platformGetTagNamespace 函数只会获取 svg 和 math 这两个标签的命名空间，但这两个标签的所有子标签都会继承它们两个的命名空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// handle IE svg bug</div><div class="line">/* istanbul ignore if */</div><div class="line">if (isIE &amp;&amp; ns === &apos;svg&apos;) &#123;</div><div class="line">  attrs = guardIESVGBug(attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过isIE来判断宿主环境是不是IE浏览器，并且前元素的命名空间为svg， 如果是通过guardIESVGBug处理当前元素的属性数组attrs，并使用处理后的结果重新赋值给attrs变量。<br>该问题是svg标签中渲染多余的属性，如下svg标签：<br>&lt;svg xmlns:feature=”<a href="http://www.openplans.org/topp&quot;&gt;&lt;/svg&amp;gt" target="_blank" rel="external">http://www.openplans.org/topp&quot;&gt;&lt;/svg&amp;gt</a>;<br>被渲染为：<br>&lt;svg xmlns:NS1=”” NS1:xmlns:feature=”<a href="http://www.openplans.org/topp&quot;&quot;&gt;&lt;/svg&amp;gt" target="_blank" rel="external">http://www.openplans.org/topp&quot;&quot;&gt;&lt;/svg&amp;gt</a>;<br>标签中多了 ‘xmlns:NS1=”” NS1:’ 这段字符串，解决办法也很简单，将整个多余的字符串去掉即可。而 guardIESVGBug 函数就是用来修改NS1:xmlns:feature属性并移除xmlns:NS1=”” 属性的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//创建虚拟元素，返回一个描述该标签的对象结构</div><div class="line">var element = createASTElement(tag, attrs, currentParent); </div><div class="line">if (ns) &#123;</div><div class="line">  element.ns = ns;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>createASTElement 它将生成当前标签的元素描述对象并且赋值给 element 变量。紧接着检查当前元素是否存在命名空间 ns ，如果存在则在元素对象上添加 ns 属性，其值为命名空间的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  if (options.outputSourceRange) &#123; //处理虚拟节点占用原模板源码范围</div><div class="line">    element.start = start$1;</div><div class="line">    element.end = end;</div><div class="line">    element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) &#123;</div><div class="line">      cumulated[attr.name] = attr;</div><div class="line">      return cumulated</div><div class="line">    &#125;, &#123;&#125;);</div><div class="line">  &#125;</div><div class="line">  attrs.forEach(function (attr) &#123;</div><div class="line">    if (invalidAttributeRE.test(attr.name)) &#123; //属性名是否符合规则</div><div class="line">      warn$2(</div><div class="line">        &quot;Invalid dynamic argument expression: attribute names cannot contain &quot; +</div><div class="line">        &quot;spaces, quotes, &lt;, &gt;, / or =.&quot;,</div><div class="line">        &#123;</div><div class="line">          start: attr.start + attr.name.indexOf(&quot;[&quot;),</div><div class="line">          end: attr.start + attr.name.length</div><div class="line">        &#125;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (isForbiddenTag(element) &amp;&amp; !isServerRendering()) &#123; //是否是不允许的style或者script标签，而且不是在服务端渲染的情况下</div><div class="line">  element.forbidden = true;</div><div class="line">  warn$2(</div><div class="line">    &apos;Templates should only be responsible for mapping the state to the &apos; +</div><div class="line">    &apos;UI. Avoid placing tags with side-effects in your templates, such as &apos; +</div><div class="line">    &quot;&lt;&quot; + tag + &quot;&gt;&quot; + &apos;, as they will not be parsed.&apos;,</div><div class="line">    &#123; start: element.start &#125;</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断在非服务端渲染情况下，当前解析的开始标签是否是禁止在模板中使用的标签<br>isForbiddenTag函数会检测tag是否为style，script以及属性是否有type,并配置了’text/javascript’<br>在 &lt;script&gt; 元素上添加 type=”text/x-template” 属性。 此时的script不会被禁止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// apply pre-transforms</div><div class="line">for (var i = 0; i &lt; preTransforms.length; i++) &#123;</div><div class="line">  element = preTransforms[i](element, options) || element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>preTransforms 是通过pluckModuleFunction 函数从options.modules 选项中筛选出名字为preTransformNode 函数所组成的数组。<br>实际上 preTransforms 数组中只有一个 preTransformNode 函数该函数只用来处理 input 标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//inVpre 定义在parse函数中，一开始为false</div><div class="line">   if (!inVPre) &#123;</div><div class="line">     //解析是否有配置v-pre指令，有的话删除</div><div class="line">     //v-pre指令可以跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。</div><div class="line">     //跳过大量没有指令的节点会加快编译。</div><div class="line">     processPre(element); </div><div class="line">     if (element.pre) &#123;</div><div class="line">       inVPre = true;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   if (platformIsPreTag(element.tag)) &#123;</div><div class="line">     inPre = true;</div><div class="line">   &#125;</div><div class="line">   if (inVPre) &#123;</div><div class="line">     processRawAttrs(element);</div><div class="line">   &#125; else if (!element.processed) &#123;</div><div class="line">     // structural directives都从attrsList数组里面踢出，</div><div class="line">     ////处理v-for配置的表达式，将解析的结果挂到element上，</div><div class="line">     //这个解析结果只是对表达式进行解析，in/of前后配置的啥，解析出来</div><div class="line">     processFor(element);</div><div class="line">     processIf(element);//处理v-if,v-else,v-else-if的表达式</div><div class="line">     processOnce(element);//处理v-once指令</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>所有process* 系列函数的作用都是为了让一个元素的描述对象更加充实，使这个对象能更加详细地描述一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!root) &#123;</div><div class="line">  root = element;//root节点没有挂载东西时，挂上，即找到了根节点</div><div class="line">  &#123;</div><div class="line">    checkRootConstraints(root);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编写 Vue 模板的时候会受到两种约束，首先模板必须有且仅有一个被渲染的根元素，第二不能使用 slot 标签和 template 标签作为模板的根元素<br>checkRootConstraints 函数内部首先通过判断 el.tag === ‘slot’ || el.tag === ‘template’ 来判断根元素是否是slot 标签或 template 标签，如果是则打印警告信息。接着又判断当前元素是否使用了 v-for 指令，因为v-for 指令会渲染多个节点所以根元素是不允许使用 v-for 指令的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line">    //这里的stack是parse函数中定义的stack</div><div class="line">    if (!unary) &#123;//非一元标签</div><div class="line">      currentParent = element;//确定当前节点即接下来标签的父节点</div><div class="line">      stack.push(element);//存入栈中，到时供结束标签判断，前一个标签是一元标签还是最近的开始标签</div><div class="line">    &#125; else &#123;//一元的话调用结束标签函数，在parseHTML函数调用前，parse函数中定义，</div><div class="line">      closeElement(element);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  end: function end (tag, start, end$1) &#123;</div><div class="line">    var element = stack[stack.length - 1];</div><div class="line">    // pop stack</div><div class="line">    //每当遇到一个非一元标签的结束标签时，</div><div class="line">    //都会回退 currentParent 变量的值为之前的值，这样我们就修正了当前正在解析的元素的父级元素</div><div class="line">    //在解析兄弟节点时有必要</div><div class="line">    stack.length -= 1;</div><div class="line">    currentParent = stack[stack.length - 1];</div><div class="line">    if (options.outputSourceRange) &#123;</div><div class="line">      element.end = end$1;</div><div class="line">    &#125;</div><div class="line">    closeElement(element);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  chars: function chars (text, start, end) &#123; //处理非标签内容（text内容）</div><div class="line">    if (!currentParent) &#123; //一些边界情况处理</div><div class="line">      &#123;//没有根元素，只有文本。</div><div class="line">        if (text === template) &#123; </div><div class="line">          warnOnce(</div><div class="line">            &apos;Component template requires a root element, rather than just text.&apos;,</div><div class="line">            &#123; start: start &#125;</div><div class="line">          );</div><div class="line">        &#125; else if ((text = text.trim())) &#123; //文本在根元素之外</div><div class="line">          warnOnce(</div><div class="line">            (&quot;text \&quot;&quot; + text + &quot;\&quot; outside root element will be ignored.&quot;),</div><div class="line">            &#123; start: start &#125;</div><div class="line">          );</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return</div><div class="line">    &#125;</div><div class="line">    //来解决 IE 浏览器中渲染 &lt;textarea&gt; 标签的 placeholder 属性时存在的 bug 的</div><div class="line">    /* istanbul ignore if */</div><div class="line">    if (isIE &amp;&amp;</div><div class="line">      currentParent.tag === &apos;textarea&apos; &amp;&amp;</div><div class="line">      currentParent.attrsMap.placeholder === text</div><div class="line">    ) &#123;</div><div class="line">      return</div><div class="line">    &#125;</div><div class="line">    var children = currentParent.children;</div><div class="line">    //对空格空行进行删除,编译器只会保留那些 不存在于开始标签之后的空格。</div><div class="line">    if (inPre || text.trim()) &#123; </div><div class="line">      //isTextTag判断是不是style或者script标签</div><div class="line">      //检测了当前文本节点的父节点是否是文本标签，如果是文本标签则直接使用原始文本，</div><div class="line">      //否则使用decodeHTMLCached 函数对文本进行解码。</div><div class="line">      text = isTextTag(currentParent) ? text : decodeHTMLCached(text);</div><div class="line">    &#125; else if (!children.length) &#123;</div><div class="line">      // remove the whitespace-only node right after an opening tag</div><div class="line">      text = &apos;&apos;;</div><div class="line">    &#125; else if (whitespaceOption) &#123;</div><div class="line">      if (whitespaceOption === &apos;condense&apos;) &#123;</div><div class="line">        // in condense mode, remove the whitespace node if it contains</div><div class="line">        // line break, otherwise condense to a single space</div><div class="line">        text = lineBreakRE.test(text) ? &apos;&apos; : &apos; &apos;;</div><div class="line">      &#125; else &#123;</div><div class="line">        text = &apos; &apos;;</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      //preserveWhitespace 是一个布尔值代表着是否保留空格，只有它为真的情况下才会保留空格。</div><div class="line">      //但即使preserveWhitespace 常量的值为真，如果当前节点的父节点没有子元素则也不会保留空格，</div><div class="line">      text = preserveWhitespace ? &apos; &apos; : &apos;&apos;;</div><div class="line">    &#125;</div><div class="line">    if (text) &#123;</div><div class="line">      if (!inPre &amp;&amp; whitespaceOption === &apos;condense&apos;) &#123;</div><div class="line">        // condense consecutive whitespaces into single space</div><div class="line">        text = text.replace(whitespaceRE$1, &apos; &apos;);</div><div class="line">      &#125;</div><div class="line">      var res;</div><div class="line">      var child;</div><div class="line">      //模板中存在的文本节点包含了 Vue 语法中的字面量表达式，</div><div class="line">      //而 parseText 函数的作用就是用来解析这段包含了字面量表达式的文本的</div><div class="line">      if (!inVPre &amp;&amp; text !== &apos; &apos; &amp;&amp; (res = parseText(text, delimiters))) &#123;//含有表达式或者变量的</div><div class="line">        child = &#123;</div><div class="line">          type: 2,</div><div class="line">          expression: res.expression,</div><div class="line">          tokens: res.tokens,</div><div class="line">          text: text</div><div class="line">        &#125;;</div><div class="line">      &#125; else if (text !== &apos; &apos; || !children.length || children[children.length - 1].text !== &apos; &apos;) &#123;//纯常量字符串</div><div class="line">        child = &#123;</div><div class="line">          type: 3,</div><div class="line">          text: text</div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">      if (child) &#123;</div><div class="line">        if (options.outputSourceRange) &#123;</div><div class="line">          child.start = start;</div><div class="line">          child.end = end;</div><div class="line">        &#125;</div><div class="line">        children.push(child);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  comment: function comment (text, start, end) &#123;</div><div class="line">    // adding anyting as a sibling to the root node is forbidden</div><div class="line">    // comments should still be allowed, but ignored</div><div class="line">    if (currentParent) &#123;</div><div class="line">      //普通文本节点与注释节点的元素描述对象的类型是一样的都是 3 ，</div><div class="line">      //不同的是注释节点的元素描述对象拥有 isComment 属性，并且该属性的值为 true，</div><div class="line">      //目的就是用来与普通文本节点作区分的。</div><div class="line">      var child = &#123;</div><div class="line">        type: 3,</div><div class="line">        text: text,</div><div class="line">        isComment: true</div><div class="line">      &#125;;</div><div class="line">      if (options.outputSourceRange) &#123;</div><div class="line">        child.start = start;</div><div class="line">        child.end = end;</div><div class="line">      &#125;</div><div class="line">      currentParent.children.push(child);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div></pre></td><td class="code"><pre><div class="line">//解析HTML</div><div class="line">function parseHTML (html, options) &#123;</div><div class="line">  var stack = [];//在 while 循环中处理 html 字符流的时候每当遇到一个非单标签，都会将该开始标签 push 到该数组。它的作用模板中 DOM 结构规范性的检测</div><div class="line">  var expectHTML = options.expectHTML;</div><div class="line">  var isUnaryTag$$1 = options.isUnaryTag || no; //用来检测一个标签是否是一元标签</div><div class="line">  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;//用来检测一个标签是否是可以省略闭合标签的非一元标签</div><div class="line">  var index = 0; //标识着当前字符流的读入位置</div><div class="line">  //last 存储剩余还未编译的 html 字符串</div><div class="line">  //lastTag 始终存储着位于 stack 栈顶的元素</div><div class="line">  var last, lastTag;</div><div class="line">  while (html) &#123;</div><div class="line">    last = html; //HTML为待解析的HTML片段，last 保留最原始的片段，advance会在解析过程中切割html</div><div class="line">    // Make sure we&apos;re not in a plaintext content element like script/style</div><div class="line">    //var isPlainTextElement = makeMap(&apos;script,style,textarea&apos;, true);</div><div class="line">    if (!lastTag || !isPlainTextElement(lastTag)) &#123;</div><div class="line">      var textEnd = html.indexOf(&apos;&lt;&apos;);</div><div class="line">      if (textEnd === 0) &#123; //如果以&lt;开头</div><div class="line">        // Comment:</div><div class="line">        if (comment.test(html)) &#123; // comment = /^&lt;!\--/;如果是以注释开头的</div><div class="line">          var commentEnd = html.indexOf(&apos;--&gt;&apos;); //拿到注释结尾的位置</div><div class="line"></div><div class="line">          if (commentEnd &gt;= 0) &#123; //如果有完整注释</div><div class="line">            //根据new vue时传递进来的comments选项值判断是否保留模板中注释</div><div class="line">            if (options.shouldKeepComment) &#123;</div><div class="line">              //options.comment在parse函数调用parseHTML时传递进来，</div><div class="line">              //该函数会将html.substring拿到注释的内容包装成 type:3的节点，然后push进其父节点的children属性</div><div class="line">              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);</div><div class="line">            &#125;</div><div class="line">            advance(commentEnd + 3);//裁剪html模板，位移index的值</div><div class="line">            continue</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment</div><div class="line">        if (conditionalComment.test(html)) &#123;</div><div class="line">          var conditionalEnd = html.indexOf(&apos;]&gt;&apos;);</div><div class="line"></div><div class="line">          if (conditionalEnd &gt;= 0) &#123;</div><div class="line">            advance(conditionalEnd + 2);</div><div class="line">            continue</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Doctype:</div><div class="line">        var doctypeMatch = html.match(doctype);</div><div class="line">        if (doctypeMatch) &#123;</div><div class="line">          advance(doctypeMatch[0].length);</div><div class="line">          continue</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // End tag:</div><div class="line">        var endTagMatch = html.match(endTag);//  var endTag = new RegExp((&quot;^&lt;\\/&quot; + qnameCapture + &quot;[^&gt;]*&gt;&quot;)); qnameCapture详见parseStartTag函数</div><div class="line">        if (endTagMatch) &#123;</div><div class="line">          var curIndex = index;</div><div class="line">          advance(endTagMatch[0].length);</div><div class="line">          parseEndTag(endTagMatch[1], curIndex, index);//处理stack中开标签/一元标签</div><div class="line">          continue</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Start tag:</div><div class="line">        var startTagMatch = parseStartTag();//如果是正常编写的标签(由&lt;&gt;包裹)返回一个描述开始标签的对象</div><div class="line">        if (startTagMatch) &#123;</div><div class="line">          handleStartTag(startTagMatch);</div><div class="line">          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) &#123;</div><div class="line">            advance(1);</div><div class="line">          &#125;</div><div class="line">          continue</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      //处理html非尖括号开头情况</div><div class="line">      var text = (void 0), rest = (void 0), next = (void 0);</div><div class="line">      if (textEnd &gt;= 0) &#123; //此时html非尖括号开头，但还含有尖括号</div><div class="line">        rest = html.slice(textEnd);//截断尖括号以前的内容</div><div class="line">        while ( 第一个尖括号就不是开始标签也不是结束或者评论标签</div><div class="line">          !endTag.test(rest) &amp;&amp;</div><div class="line">          !startTagOpen.test(rest) &amp;&amp;</div><div class="line">          !comment.test(rest) &amp;&amp;</div><div class="line">          !conditionalComment.test(rest)</div><div class="line">        ) &#123;</div><div class="line">          // &lt; in plain text, be forgiving and treat it as text</div><div class="line">          next = rest.indexOf(&apos;&lt;&apos;, 1);//从第二个字符开始找剩下html里面的第一个尖括号</div><div class="line">          if (next &lt; 0) &#123; break &#125; //如果没有，直接结束</div><div class="line">          textEnd += next;//如果有的话，重制text结束位置为该尖括号位置</div><div class="line">          rest = html.slice(textEnd);//截取html，在判断尖括号是否是标签或者注释</div><div class="line">        &#125;//while循环的作用是找出非标签内容</div><div class="line">        text = html.substring(0, textEnd);//最终得到非标签内容</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (textEnd &lt; 0) &#123; //html里面没尖括号了</div><div class="line">        text = html;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (text) &#123;</div><div class="line">        advance(text.length);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (options.chars &amp;&amp; text) &#123;</div><div class="line">        options.chars(text, index - text.length, index);//处理含动态表达式或者纯静态字符串</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      var endTagLength = 0;</div><div class="line">      var stackedTag = lastTag.toLowerCase();</div><div class="line">      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(&apos;([\\s\\S]*?)(&lt;/&apos; + stackedTag + &apos;[^&gt;]*&gt;)&apos;, &apos;i&apos;));</div><div class="line">      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) &#123;</div><div class="line">        endTagLength = endTag.length;</div><div class="line">        if (!isPlainTextElement(stackedTag) &amp;&amp; stackedTag !== &apos;noscript&apos;) &#123;</div><div class="line">          text = text</div><div class="line">            .replace(/&lt;!\--([\s\S]*?)--&gt;/g, &apos;$1&apos;) // #7298</div><div class="line">            .replace(/&lt;!\[CDATA\[([\s\S]*?)]]&gt;/g, &apos;$1&apos;);</div><div class="line">        &#125;</div><div class="line">        if (shouldIgnoreFirstNewline(stackedTag, text)) &#123;</div><div class="line">          text = text.slice(1);</div><div class="line">        &#125;</div><div class="line">        if (options.chars) &#123;</div><div class="line">          options.chars(text);</div><div class="line">        &#125;</div><div class="line">        return &apos;&apos;</div><div class="line">      &#125;);</div><div class="line">      index += html.length - rest$1.length;</div><div class="line">      html = rest$1;</div><div class="line">      parseEndTag(stackedTag, index - endTagLength, index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (html === last) &#123;</div><div class="line">      options.chars &amp;&amp; options.chars(html);</div><div class="line">      if (!stack.length &amp;&amp; options.warn) &#123;</div><div class="line">        options.warn((&quot;Mal-formatted tag at end of template: \&quot;&quot; + html + &quot;\&quot;&quot;), &#123; start: index + html.length &#125;);</div><div class="line">      &#125;</div><div class="line">      break</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Clean up any remaining tags</div><div class="line">  parseEndTag();</div><div class="line"></div><div class="line">  function advance (n) &#123;</div><div class="line">    index += n;</div><div class="line">    html = html.substring(n);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  function parseStartTag () &#123;</div><div class="line">    //使用unicode letters为基础的正则startTagOpen匹配html tag</div><div class="line">    //unicode letters会用于比较标签名，组件名以及属性路径</div><div class="line">    //var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;</div><div class="line">    // var ncname = &quot;[a-zA-Z_][\\-\\.0-9_a-zA-Z&quot; + (unicodeRegExp.source) + &quot;]*&quot;;</div><div class="line">    //var qnameCapture = &quot;((?:&quot; + ncname + &quot;\\:)?&quot; + ncname + &quot;)&quot;;</div><div class="line">    //var startTagOpen = new RegExp((&quot;^&lt;&quot; + qnameCapture)); 标签开头正则</div><div class="line">    //【正则表达式的source属性是其表达式的字符串形式】</div><div class="line">    var start = html.match(startTagOpen);</div><div class="line">    if (start) &#123;</div><div class="line">      var match = &#123;</div><div class="line">        tagName: start[1],</div><div class="line">        attrs: [],//用来存储将来被匹配到的属性</div><div class="line">        start: index //初始值为 index，是当前字符流读入位置在整个 html 字符串中的相对位置</div><div class="line">      &#125;;</div><div class="line">      advance(start[0].length);</div><div class="line">      var end, attr;</div><div class="line">      //startTagClose = /^\s*(\/?)&gt;/;标签结束正则,只可以匹配&gt;或者/&gt;，或者之前有n个空格</div><div class="line">      //attribute = /^\s*([^\s&quot;&apos;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&apos;([^&apos;]*)&apos;+|([^\s&quot;&apos;=&lt;&gt;`]+)))?/;</div><div class="line">      //dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s&quot;&apos;&lt;&gt;\/=]*)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&apos;([^&apos;]*)&apos;+|([^\s&quot;&apos;=&lt;&gt;`]+)))?/;</div><div class="line">      //dynamicArgAttribute捕获标签上配置的属性push到节点的attr属性里面</div><div class="line">      //得到的结果是[&apos;key=val&apos;,&apos;key&apos;,&apos;=&apos;,&apos;val&apos;,]</div><div class="line">      //while条件是没有匹配到开始标签的结束部分，并且匹配到了开始标签中的属性，这个时候循环体将被执行，直到遇到开始标签的结束部分为止</div><div class="line">      while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123;</div><div class="line">        attr.start = index;</div><div class="line">        advance(attr[0].length);</div><div class="line">        attr.end = index;</div><div class="line">        match.attrs.push(attr);</div><div class="line">      &#125;</div><div class="line">      &lt;!-- 即使匹配到了开始标签的开始部分以及属性部分但是却没有匹配到开始标签的结束部分，这说明这根本就不是一个开始标签。所以只有当变量end存在，即匹配到了开始标签的结束部分时，才能说明这是一个完整的开始标签 --&gt;</div><div class="line">      if (end) &#123;</div><div class="line">        match.unarySlash = end[1];//是否是单标签，双标签该值为空字符串，单标签该值为&apos;/&apos;</div><div class="line">        advance(end[0].length);//位移一个标签结束符&apos;&gt;&apos;或者&apos;/&gt;&apos;加前面n个空格的距离</div><div class="line">        match.end = index;</div><div class="line">        return match//一个html双标签的开头标签或者单标签解析完毕</div><div class="line">      &#125;</div><div class="line">       &lt;!-- 只有当变量end存在时，即能够确定确实解析到了一个开始标签的时候parseStartTag函数才会有返回值，并且返回值是match对象，其他情况下parseStartTag全部返回undefined --&gt;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //处理开始标签的解析结果</div><div class="line">  function handleStartTag (match) &#123;</div><div class="line">    var tagName = match.tagName;</div><div class="line">    var unarySlash = match.unarySlash;</div><div class="line">    </div><div class="line">    if (expectHTML) &#123; //baseOptions中默认设置为true</div><div class="line">    //最近一次遇到的开始标签是 p 标签，并且当前正在解析的开始标签必须不能是段落式内容(Phrasing content)模型</div><div class="line">    // 每一个 html 元素都拥有一个或多个内容模型(content model)，其中p 标签本身的内容模型是流式内容(Flow content)，</div><div class="line">    //并且 p 标签的特性是只允许包含段落式内容(Phrasing content)。</div><div class="line">    //所以条件成立的情况如下：&lt;p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/p&gt;</div><div class="line">    //在解析上面这段 html 字符串的时候，首先遇到p标签的开始标签，此时lastTag被设置为 p ，</div><div class="line">    //紧接着会遇到 h1 标签的开始标签，由于 h2 标签的内容模型属于非段落式内容(Phrasing content)模型，//所以会立即调用 parseEndTag(lastTag) 函数闭合 p 标签，此时由于强行插入了&lt;/p&gt; 标签，</div><div class="line">    //所以解析后的字符串将变为如下内容：&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/p&gt;</div><div class="line">    //继续解析该字符串，会遇到 &lt;h2&gt;&lt;/h2&gt; 标签并正常解析之，</div><div class="line">    //最后解析器会遇到一个单独的p 标签的结束标签，即：&lt;/p&gt;。</div><div class="line">    //这个时候就回到了我们前面讲过的，当解析器遇到 p 标签或者 br 标签的结束标签时会补全他们，</div><div class="line">    //最终&lt;p&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/p&gt; 这段 html 字符串将被解析为：&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt; --&gt;</div><div class="line">      if (lastTag === &apos;p&apos; &amp;&amp; isNonPhrasingTag(tagName)) &#123;</div><div class="line">        parseEndTag(lastTag);//处理结束标签</div><div class="line">      &#125;</div><div class="line">      //当前正在解析的标签是一个可以省略结束标签的标签，并且与上一次解析到的开始标签相同</div><div class="line">      //例&lt;p&gt;max&lt;p&gt;kaixin</div><div class="line">      //当解析到一个p标签的开始标签并且下一次遇到的标签也是p标签的开始标签时，会立即关闭第二个p标签。//即调用：parseEndTag(tagName) 函数，然后由于第一个p标签缺少闭合标签所以会Vue会给你一个警告。</div><div class="line">      if (canBeLeftOpenTag$$1(tagName) &amp;&amp; lastTag === tagName) &#123;</div><div class="line">        parseEndTag(tagName);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //通过isUnaryTag来判断，其原理通过传递的标签名判断是否有跟预设标准HTML中规定的那些一元标签一致。</div><div class="line">    var unary = isUnaryTag$$1(tagName) || !!unarySlash;//是否是一元标签</div><div class="line"></div><div class="line">    var l = match.attrs.length;</div><div class="line">    var attrs = new Array(l);//整理属性</div><div class="line">    for (var i = 0; i &lt; l; i++) &#123; </div><div class="line">      var args = match.attrs[i];</div><div class="line">      var value = args[3] || args[4] || args[5] || &apos;&apos;;</div><div class="line">      var shouldDecodeNewlines = tagName === &apos;a&apos; &amp;&amp; args[1] === &apos;href&apos; //对于a标签是否插入换行编码</div><div class="line">        ? options.shouldDecodeNewlinesForHref</div><div class="line">        : options.shouldDecodeNewlines;</div><div class="line">      attrs[i] = &#123;</div><div class="line">        name: args[1],</div><div class="line">        value: decodeAttr(value, shouldDecodeNewlines)//decodeAttr 函数的作用是对属性值中所包含的 html 实体进行解码，将其转换为实体对应的字符。</div><div class="line">      &#125;;</div><div class="line">      if (options.outputSourceRange) &#123;</div><div class="line">        attrs[i].start = args.start + args[0].match(/^\s*/).length;</div><div class="line">        attrs[i].end = args.end;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //如果开始标签是非一元标签，则将该开始标签的信息入栈，即push到stack数组中，并将lastTag的值设置为该标签名。</div><div class="line">    if (!unary) &#123;//这里的stack是parseHTML中定义的stack</div><div class="line">      stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end &#125;);</div><div class="line">      lastTag = tagName;//lastTag 所存储的标签名字始终保存着 stack 栈顶的元素</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (options.start) &#123; 调用配置的开头标签处理函数，是parse函数中传输parseHTML函数的参数</div><div class="line">      options.start(tagName, attrs, unary, match.start, match.end);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //创建虚拟节点</div><div class="line">  function createASTElement (</div><div class="line">    tag,</div><div class="line">    attrs,</div><div class="line">    parent</div><div class="line">  ) &#123;</div><div class="line">    return &#123;</div><div class="line">      type: 1,</div><div class="line">      tag: tag,</div><div class="line">      attrsList: attrs,</div><div class="line">      attrsMap: makeAttrsMap(attrs),</div><div class="line">      rawAttrsMap: &#123;&#125;,</div><div class="line">      parent: parent,</div><div class="line">      children: []</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  function parseEndTag (tagName, start, end) &#123;</div><div class="line">    var pos, lowerCasedTagName;</div><div class="line">    //当 start 和 end 不存在时，将这两个变量的值设置为当前字符流的读入位置，即index</div><div class="line">    //在handleStartTag 函数中会被这样这样调用</div><div class="line">    if (start == null) &#123; start = index; &#125;</div><div class="line">    if (end == null) &#123; end = index; &#125;</div><div class="line">    //找到最近的相同类型的开始标签的位置</div><div class="line">    // Find the closest opened tag of the same type</div><div class="line">    if (tagName) &#123;</div><div class="line">      lowerCasedTagName = tagName.toLowerCase();</div><div class="line">      for (pos = stack.length - 1; pos &gt;= 0; pos--) &#123;</div><div class="line">        if (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</div><div class="line">          break</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;//调用 parseEndTag() 函数时不传递任何参数，就能够处理stack栈中剩余未处理的标签,</div><div class="line">      // If no tag name is provided, clean shop</div><div class="line">      pos = 0;</div><div class="line">    &#125;</div><div class="line">    //删除最近开始标签 以后的开始标签(可能是一元标签)</div><div class="line">    if (pos &gt;= 0) &#123;//检测是否缺少闭合标签</div><div class="line">      // Close all the open elements, up the stack</div><div class="line">      for (var i = stack.length - 1; i &gt;= pos; i--) &#123;</div><div class="line">        if (i &gt; pos || !tagName &amp;&amp;  //如果发现 stack 数组中存在索引大于 pos 的元素，那么该元素一定是缺少闭合标签的</div><div class="line">          options.warn</div><div class="line">        ) &#123;</div><div class="line">          options.warn(</div><div class="line">            (&quot;tag &lt;&quot; + (stack[i].tag) + &quot;&gt; has no matching end tag.&quot;),</div><div class="line">            &#123; start: stack[i].start, end: stack[i].end &#125;</div><div class="line">          );</div><div class="line">        &#125;</div><div class="line">        if (options.end) &#123;</div><div class="line">          options.end(stack[i].tag, start, end);//回调parse函数调用时传递进来的回调函数</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // Remove the open elements from the stack</div><div class="line">      stack.length = pos;</div><div class="line">      lastTag = pos &amp;&amp; stack[pos - 1].tag;//将lastTag重制为stack栈顶元素</div><div class="line">    &#125; else if (lowerCasedTagName === &apos;br&apos;) &#123;为了与浏览器的行为相同，专门处理br与p的结束标签，即：&lt;/br&gt; 和&lt;/p&gt;。&lt;/br&gt; 标签被正常解析为 &lt;br&gt; 标签，而&lt;/p&gt;标签被正常解析为 &lt;p&gt;&lt;/p&gt;</div><div class="line">      if (options.start) &#123;</div><div class="line">        options.start(tagName, [], true, start, end);</div><div class="line">      &#125;</div><div class="line">    &#125; else if (lowerCasedTagName === &apos;p&apos;) &#123;</div><div class="line">      if (options.start) &#123;</div><div class="line">        options.start(tagName, [], false, start, end);</div><div class="line">      &#125;</div><div class="line">      if (options.end) &#123;</div><div class="line">        options.end(tagName, start, end);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">function isForbiddenTag(el) &#123;</div><div class="line">	return (</div><div class="line">		el.tag === &apos;style&apos; ||</div><div class="line">		(el.tag === &apos;script&apos; &amp;&amp; (</div><div class="line">			!el.attrsMap.type ||</div><div class="line">			el.attrsMap.type === &apos;text/javascript&apos;</div><div class="line">		))</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/vue/" rel="tag"># vue</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/knowledge/css.html" rel="next" title="关于css的一些事">
                <i class="fa fa-chevron-left"></i> 关于css的一些事
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/vue/vueroutersrc.html" rel="prev" title="vueRouter 源码">
                vueRouter 源码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/psb.jpg"
               alt="YooHannah" />
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">187</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#mount挂载函数的巧妙设计"><span class="nav-number">1.</span> <span class="nav-text">$mount挂载函数的巧妙设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#compileToFunctions"><span class="nav-number">2.</span> <span class="nav-text">compileToFunctions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些变量参数说明"><span class="nav-number">3.</span> <span class="nav-text">一些变量参数说明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量之间关系"><span class="nav-number">3.1.</span> <span class="nav-text">变量之间关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#baseOptions"><span class="nav-number">3.2.</span> <span class="nav-text">baseOptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#compileToFunctions传入的参数"><span class="nav-number">3.3.</span> <span class="nav-text">compileToFunctions传入的参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#compiler编译器生成"><span class="nav-number">4.</span> <span class="nav-text">compiler编译器生成</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编译器的基本知识"><span class="nav-number">5.</span> <span class="nav-text">编译器的基本知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#parse"><span class="nav-number">6.</span> <span class="nav-text">parse</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
