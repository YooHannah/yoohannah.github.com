<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Little World</title>
  <subtitle>learn and share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoohannah.github.io/"/>
  <updated>2020-02-19T08:36:18.118Z</updated>
  <id>http://yoohannah.github.io/</id>
  
  <author>
    <name>YooHannah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个发版问题</title>
    <link href="http://yoohannah.github.io/post/knowledge/editionproblem.html"/>
    <id>http://yoohannah.github.io/post/knowledge/editionproblem.html</id>
    <published>2020-02-19T08:17:37.000Z</published>
    <updated>2020-02-19T08:36:18.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>用户正在使用某个页面期间，后台发布新的版本，用户再切换其他页面，<br>浏览器会报一个资源找不到的error,导致页面崩溃</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>最终发布的版本会经过打包处理，每次打包的产物，文件名会不同<br>新发布的版本是最新打包的结果，上个版本发布的是上次发版前的结果<br>后台发布到服务器的项目新版本不再包含上个版本发布的文件<br>即服务器仅有新版本的文件<br>如果触发切换页面，此时浏览器向服务器发起请求上个版本的文件<br>服务器仅有最新版本文件，不再包含上个版本文件<br>故返回404，浏览器崩溃</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>使用vue框架编写项目，使用vue-router进行路由切换</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="利用路由"><a href="#利用路由" class="headerlink" title="利用路由"></a>利用路由</h2><p>在路由生命钩子函数中添加onerror的处理，<br>让当前页面重新load一下，把资源拉回来，再让用户自己去点击要切换的页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">router.onError((error) =&gt; &#123;</div><div class="line">  const pattern = /Loading chunk (\d)+ failed/g</div><div class="line">  const isChunkLoadFailed = error.message.match(pattern)</div><div class="line">  if (isChunkLoadFailed) &#123;</div><div class="line">    $Message(&apos;系统更新，页面将进行刷新操作！&apos;)</div><div class="line">    window.location.reload()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>使用webpack打包的时候生成一个hash.json的文件，然后前端轮询，<br>发现hash改变，就弹窗提示用户进行更新</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;用户正在使用某个页面期间，后台发布新的版本，用户再切换其他页面，&lt;br&gt;浏览器会报一个资源找不到的error,导致页面崩溃&lt;/p&gt;
&lt;h1 
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>vueRouter 源码</title>
    <link href="http://yoohannah.github.io/post/vue/vueroutersrc.html"/>
    <id>http://yoohannah.github.io/post/vue/vueroutersrc.html</id>
    <published>2020-02-19T02:48:15.000Z</published>
    <updated>2020-02-24T15:56:19.364Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;div id = &apos;app&apos; class=&apos;hello&apos;&gt;</div><div class="line">    &lt;p&gt;</div><div class="line">      &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</div><div class="line">      &lt;router-link to=&quot;/bar/user&quot;&gt;Go to Bar&lt;/router-link&gt;</div><div class="line">    &lt;/p&gt;</div><div class="line">    &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;vue-router.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">    const Foo = &#123; template: &apos;&lt;div&gt;foo&lt;/div&gt;&apos;,mounted()&#123;&#125;&#125;//路由foo组件</div><div class="line">    const Bar = &#123; </div><div class="line">      template: &apos;&lt;div&gt;bar&lt;div&gt;&#123;&#123;id&#125;&#125;&lt;/div&gt;&lt;a @click=&quot;aa&quot;&gt;go to foo&lt;/a&gt;&lt;/div&gt;&apos;,//路由bar组件</div><div class="line">      data()&#123;</div><div class="line">        return &#123;</div><div class="line">          id:&apos;&apos;,</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      methods:&#123;</div><div class="line">        aa()&#123;</div><div class="line">          console.log(this.$router)</div><div class="line">          this.$router.push(&#123;name:&apos;foo&apos;,params:&#123;name:&apos;jck&apos;&#125;&#125;)</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      mounted()&#123;</div><div class="line">        console.log(this.$route,this.$router)</div><div class="line">        this.id = this.$route.params.id</div><div class="line">      &#125; </div><div class="line">      &#125;</div><div class="line">    const routes = [</div><div class="line">        &#123; path: &apos;/foo/:name&apos;,name:&apos;foo&apos;, component: Foo &#125;,</div><div class="line">        &#123; path: &apos;/bar/:id?&apos;,name:&apos;bar&apos;, component: Bar &#125;</div><div class="line">      ]</div><div class="line">    const router = new VueRouter(&#123;routes&#125;)</div><div class="line">    let app = new Vue(&#123;</div><div class="line">      el:&apos;#app&apos;,</div><div class="line">      data:&#123;&#125;,</div><div class="line">      method:&#123;&#125;,</div><div class="line">      router,</div><div class="line">    &#125;)</div><div class="line">  &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<h1 id="执行vue-Router-js文件"><a href="#执行vue-Router-js文件" class="headerlink" title="执行vue-Router.js文件"></a>执行vue-Router.js文件</h1><p>引入vue-router之前会先引入vue.js文件，执行会生成vue构造函数,<br>因为vue-router的执行过程会用到vue构造函数这个对象上的方法<br>当代码引入vue-router.js时，里面相应的代码会执行一遍，<br>此时vue构造函数已经生成<br>所以vue-router.js运行后，<br>不仅会生成vue-router的构造对象<br>还会调用vue构造函数上的use方法将与router相关的信息挂到vue构造函数对象上<br>即做一些注册挂载的初始化工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">(function (global, factory) &#123;</div><div class="line">  global.VueRouter = factory());</div><div class="line">&#125;(this, function () &#123; &apos;use strict&apos;;</div><div class="line">  //vue-router的构造对象</div><div class="line">  var VueRouter = function VueRouter (options) &#123; </div><div class="line">    if ( options === void 0 ) options = &#123;&#125;;</div><div class="line">    //options即new vueRouter时传进来的参数对象，这里只有一个属性即路由配置对象routes</div><div class="line">    this.app = null;</div><div class="line">    this.apps = [];</div><div class="line">    this.options = options;</div><div class="line">    this.beforeHooks = [];</div><div class="line">    this.resolveHooks = [];</div><div class="line">    this.afterHooks = [];</div><div class="line">    //该函数会根据路由配合生成路由表，返回两个函数，一个match函数用来匹配路由，另一个addRoutes用来动态增加路由，详见下文具体分析</div><div class="line">    this.matcher = createMatcher(options.routes || [], this);</div><div class="line">    var mode = options.mode || &apos;hash&apos;;//路由对象模式，没有配置的话默认初始化为&apos;hash&apos;</div><div class="line">    //fallback参数用于配置当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式</div><div class="line">    //默认值为 true 官文：https://router.vuejs.org/zh/api/#fallback</div><div class="line">    this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false;</div><div class="line">    if (this.fallback) &#123; //history模式下在不支持pushstate方法且配置允许回退hash的情况下回退hash模式</div><div class="line">      mode = &apos;hash&apos;;</div><div class="line">    &#125;</div><div class="line">    if (!inBrowser) &#123; //没有在浏览器中，那应该是在nodejs中，模式重置为abstract</div><div class="line">      mode = &apos;abstract&apos;;</div><div class="line">    &#125;</div><div class="line">    this.mode = mode;//模式确定</div><div class="line"></div><div class="line">    switch (mode) &#123; //初始化history对象，三种类型的history构造函数继承自同一父类构造函数History</div><div class="line">      case &apos;history&apos;:</div><div class="line">        this.history = new HTML5History(this, options.base);</div><div class="line">        break</div><div class="line">      case &apos;hash&apos;:</div><div class="line">        this.history = new HashHistory(this, options.base, this.fallback);</div><div class="line">        break</div><div class="line">      case &apos;abstract&apos;:</div><div class="line">        this.history = new AbstractHistory(this, options.base);</div><div class="line">        break</div><div class="line">      default:</div><div class="line">        &#123;</div><div class="line">          assert(false, (&quot;invalid mode: &quot; + mode));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  VueRouter.install = install;</div><div class="line">  VueRouter.version = &apos;3.1.5&apos;;</div><div class="line"></div><div class="line">  function install (Vue) &#123; &#125; //挂到VueRouter上，被vue.use函数调用</div><div class="line"></div><div class="line">  if (inBrowser &amp;&amp; window.Vue) &#123; //只在浏览器环境自动挂载，说明在node.js中需要自己调用Vue.use手动挂载</div><div class="line">    window.Vue.use(VueRouter);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return VueRouter;</div><div class="line"></div><div class="line">&#125;));</div></pre></td></tr></table></figure></p>
<h2 id="vue-use-与-VueRouter-install"><a href="#vue-use-与-VueRouter-install" class="headerlink" title="vue.use 与 VueRouter.install"></a>vue.use 与 VueRouter.install</h2><p>vue的use方法会调用插件的install方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//在运行initGlobalAPI(Vue)函数时调用initUse挂载到VUE上</div><div class="line">Vue.use = function (plugin) &#123;</div><div class="line">  var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));//this是指Vue哦</div><div class="line">  if (installedPlugins.indexOf(plugin) &gt; -1) &#123; //避免重复挂载</div><div class="line">    return this</div><div class="line">  &#125;</div><div class="line">  //这个方法会从arguments中取出从第一个数以后的所有参数，这里返回空数组===&gt;[]</div><div class="line">  var args = toArray(arguments, 1);</div><div class="line">  args.unshift(this);//this是vue,将vue传给组件进行初始化 ==&gt;[vue]</div><div class="line">  if (typeof plugin.install === &apos;function&apos;) &#123;  //组件定义了plugin.install方法，执行组件plugin.install方法</div><div class="line">    plugin.install.apply(plugin, args);</div><div class="line">  &#125; else if (typeof plugin === &apos;function&apos;) &#123; //没定义定义plugin.install方法且组件本身是函数，则调用自身</div><div class="line">    plugin.apply(null, args);</div><div class="line">  &#125;</div><div class="line">  installedPlugins.push(plugin);//将插件推入vue对象上的installedPlugins集合中</div><div class="line">  return this</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>VueRouter.install方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">function install (Vue) &#123; //挂到VueRouter上，被vue.use函数调用</div><div class="line">    if (install.installed &amp;&amp; _Vue === Vue) &#123; return &#125;//避免重复挂载</div><div class="line">    install.installed = true;</div><div class="line"></div><div class="line">    _Vue = Vue;</div><div class="line"></div><div class="line">    var isDef = function (v) &#123; return v !== undefined; &#125;;</div><div class="line"></div><div class="line">    var registerInstance = function (vm, callVal) &#123;</div><div class="line">      var i = vm.$options._parentVnode;</div><div class="line">      if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) &#123;</div><div class="line">        i(vm, callVal);//如果定义了registerRouteInstance就执行</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    //调用vue.mixin方法 将beforeCreate 和 destroyed，两个生命周期函数存到到对应的钩子函数的集合中</div><div class="line">    //在执行new vue时会调用callHook执行 beforeCreate相关的钩子函数</div><div class="line">    //在vue中执行destroyed钩子函数时，同样也会调用这里定义好的生命周期函数</div><div class="line">    Vue.mixin(&#123; </div><div class="line">      beforeCreate: function beforeCreate () &#123; //这里this指向vue</div><div class="line">        if (isDef(this.$options.router)) &#123;</div><div class="line">          this._routerRoot = this;</div><div class="line">          this._router = this.$options.router;</div><div class="line">          //调用vueRouter对象上的init方法,主要功能是初始化当前路由，设置监听 详见下文</div><div class="line">          this._router.init(this);</div><div class="line">          Vue.util.defineReactive(this, &apos;_route&apos;, this._router.history.current);</div><div class="line">          //defineReactive会对数据进行劫持，进行依赖收集，方便之后页面切换进行监听</div><div class="line">        &#125; else &#123;//如果没有在new vue时传进vuerouter对象</div><div class="line">          this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this;</div><div class="line">        &#125;</div><div class="line">        registerInstance(this, this);</div><div class="line">      &#125;,</div><div class="line">      destroyed: function destroyed () &#123;</div><div class="line">        registerInstance(this);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    //访问this.$router,返回new vueRouter生成的对象</div><div class="line">    Object.defineProperty(Vue.prototype, &apos;$router&apos;, &#123; </div><div class="line">      get: function get () &#123; return this._routerRoot._router &#125;</div><div class="line">    &#125;);</div><div class="line">    //访问this.$route,当前页面路由对象 this._router.history.current</div><div class="line">    Object.defineProperty(Vue.prototype, &apos;$route&apos;, &#123;</div><div class="line">      get: function get () &#123; return this._routerRoot._route &#125;</div><div class="line">    &#125;);</div><div class="line">    //挂载RouterView，RouterLink两个组件</div><div class="line">    Vue.component(&apos;RouterView&apos;, View); </div><div class="line">    Vue.component(&apos;RouterLink&apos;, Link);</div><div class="line">    //使用vue生命钩子函数合并策略定义路由生命周期钩子函数合并策略 其实就是mergeHook函数</div><div class="line">    var strats = Vue.config.optionMergeStrategies;</div><div class="line">    // use the same hook merging strategy for route hooks</div><div class="line">    strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>vueRouter在执行阶段会做以下两件事<br>1.生成vue-router的构造对象<br>2.挂载vuerouter相关信息到vue对象</p>
<p>挂载到vue对象时会做以下几件事<br>1.注入两个生命周期函数：beforeCreate和 destroyed<br>2.指定vue的$router和$route分别指向传进去的vueRouter对象的本身和history.current属性<br>3.挂载RouterView,RouterLink两个组件<br>4.指定路由生命周期函数合并策略使用vue中生命周期函数的合并策略</p>
<p>beforeCreate会在new vue时被调用，主要做以下几件事<br>1.在vue对象上指定与router相关的属性<br>2.调用vuerouter的init方法，初始化当前路由，设置监听<br>3.对当前路由进行数据劫持，进行监听</p>
<p>在new vueRouter时，会做以下几件事<br>1.根据路由配置数组生成路由表，匹配函数以及动态增加路由的函数<br>2.确定路由模式<br>3。根据路由模式创建history属性</p>
<h1 id="一个疑惑"><a href="#一个疑惑" class="headerlink" title="一个疑惑"></a>一个疑惑</h1><p>当跳转的路由带有query或者params时，将其中的值插入到页面中为什么不会引起XSS攻击？<br>因为拿到的值类型都是原始js类型，vue在替换值时只是当做字符串替换，不会进行innerHTML</p>
<h2 id="使用js跳转路由"><a href="#使用js跳转路由" class="headerlink" title="使用js跳转路由"></a>使用js跳转路由</h2><p>比如this.$router.push({name:foo,query:{id:1}})方法跳转路由<br>目的页面拿到的query/params数据，就是调用push函数传入的数据<br>当我们调用push函数时，就是在调用这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">VueRouter.prototype.push = function push (location, onComplete, onAbort) &#123;</div><div class="line">    var this$1 = this;</div><div class="line">    if (!onComplete &amp;&amp; !onAbort &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</div><div class="line">      return new Promise(function (resolve, reject) &#123;//进行异步跳转</div><div class="line">        this$1.history.push(location, resolve, reject);</div><div class="line">      &#125;)</div><div class="line">    &#125; else &#123;//进行同步跳转</div><div class="line">      this.history.push(location, onComplete, onAbort);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>location就是我们传入的参数，没有传入 onComplete, onAbort，所以会进入if分支<br>可见无论进入哪个分支都会调用history对象的push方法<br>由于在new VueRouter对象时，在构造函数中history是根据传入的选项生成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var mode = options.mode || &apos;hash&apos;;</div><div class="line">  this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false;</div><div class="line">  if (this.fallback) &#123;</div><div class="line">    mode = &apos;hash&apos;;</div><div class="line">  &#125;</div><div class="line">  if (!inBrowser) &#123;</div><div class="line">    mode = &apos;abstract&apos;;</div><div class="line">  &#125;</div><div class="line">  this.mode = mode;</div><div class="line"></div><div class="line">  switch (mode) &#123;</div><div class="line">    case &apos;history&apos;:</div><div class="line">      this.history = new HTML5History(this, options.base);</div><div class="line">      break</div><div class="line">    case &apos;hash&apos;:</div><div class="line">      this.history = new HashHistory(this, options.base, this.fallback);</div><div class="line">      break</div><div class="line">    case &apos;abstract&apos;:</div><div class="line">      this.history = new AbstractHistory(this, options.base);</div><div class="line">      break</div><div class="line">    default:</div><div class="line">      &#123;</div><div class="line">        assert(false, (&quot;invalid mode: &quot; + mode));</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>所以push方法的实现可能为以下三种情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">HTML5History.prototype.push = function push (location, onComplete, onAbort) &#123;</div><div class="line">  var this$1 = this;</div><div class="line"></div><div class="line">  var ref = this;</div><div class="line">  var fromRoute = ref.current;</div><div class="line">  this.transitionTo(location, function (route) &#123;</div><div class="line">    pushState(cleanPath(this$1.base + route.fullPath));</div><div class="line">    handleScroll(this$1.router, route, fromRoute, false);</div><div class="line">    onComplete &amp;&amp; onComplete(route);</div><div class="line">  &#125;, onAbort);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">HashHistory.prototype.push = function push (location, onComplete, onAbort) &#123;</div><div class="line">  var this$1 = this;</div><div class="line">  var ref = this;</div><div class="line">  var fromRoute = ref.current;</div><div class="line">  this.transitionTo(</div><div class="line">    location,</div><div class="line">    function (route) &#123;</div><div class="line">      pushHash(route.fullPath);//更改url</div><div class="line">      handleScroll(this$1.router, route, fromRoute, false);</div><div class="line">      onComplete &amp;&amp; onComplete(route);</div><div class="line">    &#125;,</div><div class="line">    onAbort</div><div class="line">  );</div><div class="line">&#125;;</div><div class="line">AbstractHistory.prototype.push = function push (location, onComplete, onAbort) &#123;</div><div class="line">  var this$1 = this;</div><div class="line">  this.transitionTo(</div><div class="line">    location,</div><div class="line">    function (route) &#123;</div><div class="line">      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);</div><div class="line">      this$1.index++;</div><div class="line">      onComplete &amp;&amp; onComplete(route);</div><div class="line">    &#125;,</div><div class="line">    onAbort</div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可见三种模式下都会调用共同的父类History上的transitionTo方法<br>接下来以HashHistory为基础分析接下来的流程</p>
<p>在HashHistory push调用transitionTo时，<br>传入三个参数：<br>location 即我们调用push时传入的参数<br>onAbort 调用push时没有传入，故该值为undefined<br>第三个参数是一个匿名函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function (route) &#123;</div><div class="line">  pushHash(route.fullPath);//更改url</div><div class="line">  handleScroll(this$1.router, route, fromRoute, false);//处理页面滚动相关功能</div><div class="line">  onComplete &amp;&amp; onComplete(route);//调用push时没有传入onComplete,故onComplete=&gt;undefined,不会被执行</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>可见匿名函数内将来要执行pushHash函数</p>
<h3 id="pushHash函数更改浏览器url"><a href="#pushHash函数更改浏览器url" class="headerlink" title="pushHash函数更改浏览器url"></a>pushHash函数更改浏览器url</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function pushHash (path) &#123;</div><div class="line">  if (supportsPushState) &#123; 使用history.pushState更改URl</div><div class="line">    pushState(getUrl(path));</div><div class="line">  &#125; else &#123;//如果不支持history.pushState则直接更改hash值</div><div class="line">    window.location.hash = path;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">function getUrl (path) &#123;</div><div class="line">  var href = window.location.href;</div><div class="line">  var i = href.indexOf(&apos;#&apos;);</div><div class="line">  var base = i &gt;= 0 ? href.slice(0, i) : href;</div><div class="line">  return (base + &quot;#&quot; + path)</div><div class="line">&#125;</div><div class="line">function pushState (url, replace) &#123;</div><div class="line">  saveScrollPosition();</div><div class="line">  // try...catch the pushState call to get around Safari</div><div class="line">  // DOM Exception 18 where it limits to 100 pushState calls</div><div class="line">  var history = window.history;</div><div class="line">  try &#123;</div><div class="line">    if (replace) &#123; //在使用replace函数跳转路由会走该分支，由replaceState函数调用，replace传入为true</div><div class="line">      // 保留现有的历史记录状态，因为用户可能会覆盖它</div><div class="line">      var stateCopy = extend(&#123;&#125;, history.state);</div><div class="line">      stateCopy.key = getStateKey();</div><div class="line">      history.replaceState(stateCopy, &apos;&apos;, url); //使用window的history上的方法</div><div class="line">    &#125; else &#123; //没有传入replace，故进入该分支</div><div class="line">      history.pushState(&#123; key: setStateKey(genStateKey()) &#125;, &apos;&apos;, url);</div><div class="line">    &#125;</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">    window.location[replace ? &apos;replace&apos; : &apos;assign&apos;](url);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以pushHash函数最终的目的是更改浏览器中的url<br>handleScroll函数处理页面滚动状态，这里暂不做深入<br>onComplete 值为undefined,故不执行</p>
<h3 id="transitionTo"><a href="#transitionTo" class="headerlink" title="transitionTo"></a>transitionTo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">History.prototype.transitionTo = function transitionTo (</div><div class="line">    location,</div><div class="line">    onComplete,</div><div class="line">    onAbort</div><div class="line">  ) &#123;</div><div class="line">    var this$1 = this;</div><div class="line">    var route = this.router.match(location, this.current);//得到目的路由的route对象</div><div class="line">    this.confirmTransition(...暂时省略));</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>transitionTo函数中第一步就是根据根据当前路由信息和传入的目的路由信息生成目的路由对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var route = this.router.match(location, this.current);</div></pre></td></tr></table></figure></p>
<p>location 是我们调用push函数传入的参数，<br>this.current即当前页面路由信息对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">VueRouter.prototype.match = function match (</div><div class="line">  raw,</div><div class="line">  current,</div><div class="line">  redirectedFrom</div><div class="line">) &#123;</div><div class="line">  return this.matcher.match(raw, current, redirectedFrom)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">this.matcher = createMatcher(options.routes || [], this); //new vuerouter时在构造函数中生成</div></pre></td></tr></table></figure>
<h3 id="createMatcher"><a href="#createMatcher" class="headerlink" title="createMatcher"></a>createMatcher</h3><p>createMatcher函数即创造匹配器的函数，主要做三件事<br>1.生成路由表<br>2.生成匹配器，用于将当然路由对象和目的路由信息对象合成目的路由对象<br>3.生成动态添加路由的函数，因这里可以直接使用路由表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">function createMatcher (</div><div class="line">  routes,</div><div class="line">  router</div><div class="line">) &#123;</div><div class="line">  var ref = createRouteMap(routes);//根据路由配置生成路由表</div><div class="line">  var pathList = ref.pathList;</div><div class="line">  var pathMap = ref.pathMap;</div><div class="line">  var nameMap = ref.nameMap;</div><div class="line"></div><div class="line">  function addRoutes (routes) &#123; //动态增加路由</div><div class="line">    createRouteMap(routes, pathList, pathMap, nameMap);</div><div class="line">  &#125;</div><div class="line">  //根据当前路由对象和目的路由信息以及是否重定向等条件合成目的路由对象返回</div><div class="line">  function match ( </div><div class="line">    raw,</div><div class="line">    currentRoute,</div><div class="line">    redirectedFrom</div><div class="line">  ) &#123;</div><div class="line">    //统一路由参数，合并params给到目的路由</div><div class="line">    var location = normalizeLocation(raw, currentRoute, false, router);</div><div class="line">    var name = location.name;</div><div class="line">    if (name) &#123;//走这条分支</div><div class="line">      var record = nameMap[name];</div><div class="line">      &#123;</div><div class="line">        warn(record, (&quot;Route with name &apos;&quot; + name + &quot;&apos; does not exist&quot;));</div><div class="line">      &#125;</div><div class="line">      if (!record) &#123; return _createRoute(null, location) &#125;</div><div class="line">      var paramNames = record.regex.keys //没有在路由path中配置动态参数，keys数组为空</div><div class="line">        .filter(function (key) &#123; return !key.optional; &#125;)</div><div class="line">        .map(function (key) &#123; return key.name; &#125;);</div><div class="line"></div><div class="line">      if (typeof location.params !== &apos;object&apos;) &#123;</div><div class="line">        location.params = &#123;&#125;; //给location 挂上params</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (currentRoute &amp;&amp; typeof currentRoute.params === &apos;object&apos;) &#123;</div><div class="line">        for (var key in currentRoute.params) &#123;//params中有相同key值时，从当前路由将值给到目的路由</div><div class="line">          if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) &#123;</div><div class="line">            location.params[key] = currentRoute.params[key];</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      //如果path有动态参数，使用params将path补全，//以name发起的跳转，挂上了path</div><div class="line">      location.path = fillParams(record.path, location.params, (&quot;named route \&quot;&quot; + name + &quot;\&quot;&quot;));</div><div class="line">      return _createRoute(record, location, redirectedFrom) 可知返回一route对象</div><div class="line">    &#125; else if (location.path) &#123; //详见link跳转分析</div><div class="line">      location.params = &#123;&#125;;</div><div class="line">      for (var i = 0; i &lt; pathList.length; i++) &#123;</div><div class="line">        var path = pathList[i];</div><div class="line">        var record$1 = pathMap[path];</div><div class="line">        if (matchRoute(record$1.regex, location.path, location.params)) &#123;</div><div class="line">          console.log(location)</div><div class="line">          return _createRoute(record$1, location, redirectedFrom)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    // no match</div><div class="line">    return _createRoute(null, location)</div><div class="line">  &#125;</div><div class="line">  function redirect () &#123;...对重定向一系列的处理，会返回createRoute()&#125;</div><div class="line">  function alias () &#123;...对路由配置中的别名进行处理，会返回createRoute()&#125;</div><div class="line">  function _createRoute ( //会生成fullpath</div><div class="line">    record,</div><div class="line">    location,</div><div class="line">    redirectedFrom</div><div class="line">  ) &#123;</div><div class="line">    if (record &amp;&amp; record.redirect) &#123;</div><div class="line">      return redirect(record, redirectedFrom || location)</div><div class="line">    &#125;</div><div class="line">    if (record &amp;&amp; record.matchAs) &#123;</div><div class="line">      return alias(record, location, record.matchAs)</div><div class="line">    &#125;</div><div class="line">    return createRoute(record, location, redirectedFrom, router)</div><div class="line">  &#125;</div><div class="line">  return &#123;</div><div class="line">    match: match,</div><div class="line">    addRoutes: addRoutes</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="路由表生成"><a href="#路由表生成" class="headerlink" title="路由表生成"></a>路由表生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">function createRouteMap ( //生成路由表</div><div class="line">  routes,</div><div class="line">  oldPathList,</div><div class="line">  oldPathMap,</div><div class="line">  oldNameMap</div><div class="line">) &#123;</div><div class="line">  // the path list is used to control path matching priority</div><div class="line">  var pathList = oldPathList || [];</div><div class="line">  // $flow-disable-line</div><div class="line">  var pathMap = oldPathMap || Object.create(null);</div><div class="line">  // $flow-disable-line</div><div class="line">  var nameMap = oldNameMap || Object.create(null);</div><div class="line"></div><div class="line">  routes.forEach(function (route) &#123;</div><div class="line">    addRouteRecord(pathList, pathMap, nameMap, route);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  // ensure wildcard(通配符) routes are always at the end</div><div class="line">  for (var i = 0, l = pathList.length; i &lt; l; i++) &#123;</div><div class="line">    if (pathList[i] === &apos;*&apos;) &#123;</div><div class="line">      pathList.push(pathList.splice(i, 1)[0]);</div><div class="line">      l--;</div><div class="line">      i--;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    // warn if routes do not include leading slashes(斜线)</div><div class="line">    var found = pathList</div><div class="line">    // check for missing leading slash</div><div class="line">      .filter(function (path) &#123; return path &amp;&amp; path.charAt(0) !== &apos;*&apos; &amp;&amp; path.charAt(0) !== &apos;/&apos;; &#125;);</div><div class="line"></div><div class="line">    if (found.length &gt; 0) &#123;</div><div class="line">      var pathNames = found.map(function (path) &#123; return (&quot;- &quot; + path); &#125;).join(&apos;\n&apos;);</div><div class="line">      warn(false, (&quot;Non-nested routes must include a leading slash character. Fix the following routes: \n&quot; + pathNames));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    pathList: pathList,//数组，存放path值的集合</div><div class="line">    pathMap: pathMap,//对象，有配置path的路由record集合</div><div class="line">    nameMap: nameMap//对象，有配置name的路由record的集合</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//根据配置的路由将其转换成内部使用的路由对象record,并根据配置情况放到不同路由集合(前三个参数)中，</div><div class="line">function addRouteRecord ( </div><div class="line">  pathList,</div><div class="line">  pathMap,</div><div class="line">  nameMap,</div><div class="line">  route,//具体配置的route</div><div class="line">  parent,//用于处理配置了children，被递归调用时传入，</div><div class="line">  matchAs</div><div class="line">) &#123;</div><div class="line">  var path = route.path;</div><div class="line">  var name = route.name;</div><div class="line"> </div><div class="line">  var pathToRegexpOptions =</div><div class="line">    route.pathToRegexpOptions || &#123;&#125;;</div><div class="line">  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);</div><div class="line"></div><div class="line">  if (typeof route.caseSensitive === &apos;boolean&apos;) &#123;</div><div class="line">    pathToRegexpOptions.sensitive = route.caseSensitive;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var record = &#123;</div><div class="line">    path: normalizedPath,</div><div class="line">    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),</div><div class="line">    components: route.components || &#123; default: route.component &#125;,</div><div class="line">    instances: &#123;&#125;,</div><div class="line">    name: name,</div><div class="line">    parent: parent,</div><div class="line">    matchAs: matchAs,</div><div class="line">    redirect: route.redirect,</div><div class="line">    beforeEnter: route.beforeEnter,</div><div class="line">    meta: route.meta || &#123;&#125;,</div><div class="line">    props:</div><div class="line">      route.props == null</div><div class="line">        ? &#123;&#125;</div><div class="line">        : route.components</div><div class="line">          ? route.props</div><div class="line">          : &#123; default: route.props &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  if (route.children) &#123;...&#125;</div><div class="line"></div><div class="line">  if (!pathMap[record.path]) &#123;</div><div class="line">    pathList.push(record.path);</div><div class="line">    pathMap[record.path] = record;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (route.alias !== undefined) &#123;...&#125;</div><div class="line"></div><div class="line">  if (name) &#123;</div><div class="line">    if (!nameMap[name]) &#123;</div><div class="line">      nameMap[name] = record;</div><div class="line">    &#125; else if ( !matchAs) &#123;</div><div class="line">      warn(</div><div class="line">        false,</div><div class="line">        &quot;Duplicate named routes definition: &quot; +</div><div class="line">          &quot;&#123; name: \&quot;&quot; + name + &quot;\&quot;, path: \&quot;&quot; + (record.path) + &quot;\&quot; &#125;&quot;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并params"><a href="#合并params" class="headerlink" title="合并params"></a>合并params</h3><p>在match函数中首先会整理参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">function normalizeLocation (</div><div class="line">   raw,</div><div class="line">   current,</div><div class="line">   append,</div><div class="line">   router</div><div class="line"> ) &#123;</div><div class="line">   //link标签点击传入的raw是to标签指令的值， 为字符串</div><div class="line">   var next = typeof raw === &apos;string&apos; ? &#123; path: raw &#125; : raw;</div><div class="line">   // named target</div><div class="line">   if (next._normalized) &#123;//已经处理过</div><div class="line">     return next</div><div class="line">   &#125; else if (next.name) &#123; //当前调用push使用name标记路由，只会走这个分支</div><div class="line">     next = extend(&#123;&#125;, raw);</div><div class="line">     var params = next.params;</div><div class="line">     if (params &amp;&amp; typeof params === &apos;object&apos;) &#123;</div><div class="line">       next.params = extend(&#123;&#125;, params);</div><div class="line">     &#125;</div><div class="line">     return next</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // relative params</div><div class="line">   if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123;</div><div class="line">     next = extend(&#123;&#125;, next);</div><div class="line">     next._normalized = true;</div><div class="line">     var params$1 = extend(extend(&#123;&#125;, current.params), next.params);</div><div class="line">     if (current.name) &#123;</div><div class="line">       next.name = current.name;</div><div class="line">       next.params = params$1;</div><div class="line">     &#125; else if (current.matched.length) &#123;</div><div class="line">       var rawPath = current.matched[current.matched.length - 1].path;</div><div class="line">       next.path = fillParams(rawPath, params$1, (&quot;path &quot; + (current.path)));</div><div class="line">     &#125; else &#123;</div><div class="line">       warn(false, &quot;relative params navigation requires a current route.&quot;);</div><div class="line">     &#125;</div><div class="line">     return next</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   var parsedPath = parsePath(next.path || &apos;&apos;);</div><div class="line">   var basePath = (current &amp;&amp; current.path) || &apos;/&apos;;</div><div class="line">   var path = parsedPath.path</div><div class="line">     ? resolvePath(parsedPath.path, basePath, append || next.append)</div><div class="line">     : basePath;</div><div class="line"></div><div class="line">   var query = resolveQuery(</div><div class="line">     parsedPath.query,</div><div class="line">     next.query,</div><div class="line">     router &amp;&amp; router.options.parseQuery</div><div class="line">   );</div><div class="line"></div><div class="line">   var hash = next.hash || parsedPath.hash;</div><div class="line">   if (hash &amp;&amp; hash.charAt(0) !== &apos;#&apos;) &#123;</div><div class="line">     hash = &quot;#&quot; + hash;</div><div class="line">   &#125;</div><div class="line">   return &#123;</div><div class="line">     _normalized: true,</div><div class="line">     path: path,</div><div class="line">     query: query,</div><div class="line">     hash: hash</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建路由route对象"><a href="#创建路由route对象" class="headerlink" title="创建路由route对象"></a>创建路由route对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">function createRoute (</div><div class="line">  record,</div><div class="line">  location,</div><div class="line">  redirectedFrom,</div><div class="line">  router</div><div class="line">) &#123;</div><div class="line">  var stringifyQuery = router &amp;&amp; router.options.stringifyQuery;</div><div class="line"></div><div class="line">  var query = location.query || &#123;&#125;;</div><div class="line">  try &#123;</div><div class="line">    query = clone(query);</div><div class="line">  &#125; catch (e) &#123;&#125;</div><div class="line"></div><div class="line">  var route = &#123;</div><div class="line">    name: location.name || (record &amp;&amp; record.name),</div><div class="line">    meta: (record &amp;&amp; record.meta) || &#123;&#125;,</div><div class="line">    path: location.path || &apos;/&apos;,</div><div class="line">    hash: location.hash || &apos;&apos;,</div><div class="line">    query: query,//调用push函数传递进来的query，赋值时只能赋值js数据类型，拿到的也是js数据类型</div><div class="line">    params: location.params || &#123;&#125;,</div><div class="line">    fullPath: getFullPath(location, stringifyQuery),//生成fullPath</div><div class="line">    matched: record ? formatMatch(record) : []</div><div class="line">  &#125;;</div><div class="line">  if (redirectedFrom) &#123;</div><div class="line">    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);</div><div class="line">  &#125;</div><div class="line">  return Object.freeze(route) //禁止改动route对象</div><div class="line">&#125;</div><div class="line">function getFullPath ( //根据query生成fullPath</div><div class="line">    ref,</div><div class="line">    _stringifyQuery</div><div class="line">  ) &#123;</div><div class="line">    var path = ref.path;</div><div class="line">    var query = ref.query; if ( query === void 0 ) query = &#123;&#125;;</div><div class="line">    var hash = ref.hash; if ( hash === void 0 ) hash = &apos;&apos;;</div><div class="line"></div><div class="line">    var stringify = _stringifyQuery || stringifyQuery;</div><div class="line">    return (path || &apos;/&apos;) + stringify(query) + hash</div><div class="line">  &#125;</div><div class="line">//组装url上参数的部分</div><div class="line">function stringifyQuery (obj) &#123;</div><div class="line">  var res = obj ? Object.keys(obj).map(function (key) &#123;</div><div class="line">    var val = obj[key];</div><div class="line"></div><div class="line">    if (val === undefined) &#123;</div><div class="line">      return &apos;&apos;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (val === null) &#123;</div><div class="line">      return encode(key)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (Array.isArray(val)) &#123;</div><div class="line">      var result = [];</div><div class="line">      val.forEach(function (val2) &#123;</div><div class="line">        if (val2 === undefined) &#123;</div><div class="line">          return</div><div class="line">        &#125;</div><div class="line">        if (val2 === null) &#123;</div><div class="line">          result.push(encode(key));</div><div class="line">        &#125; else &#123;</div><div class="line">          result.push(encode(key) + &apos;=&apos; + encode(val2));</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">      return result.join(&apos;&amp;&apos;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return encode(key) + &apos;=&apos; + encode(val)</div><div class="line">  &#125;).filter(function (x) &#123; return x.length &gt; 0; &#125;).join(&apos;&amp;&apos;) : null;</div><div class="line">  return res ? (&quot;?&quot; + res) : &apos;&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以在调用完match之后会得到route,接着会调用confirmTransition</p>
<h3 id="confirmTransition"><a href="#confirmTransition" class="headerlink" title="confirmTransition"></a>confirmTransition</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line">在transitionTo调用时</div><div class="line">this.confirmTransition(</div><div class="line">  route,</div><div class="line">  function () &#123;</div><div class="line">    this$1.updateRoute(route);//更新router对象</div><div class="line">    onComplete &amp;&amp; onComplete(route);//调用transitionTo时传入的第二个参数函数，里面有pushHash来更改url</div><div class="line">    this$1.ensureURL();</div><div class="line"></div><div class="line">    // fire ready cbs once</div><div class="line">    if (!this$1.ready) &#123;</div><div class="line">      this$1.ready = true;</div><div class="line">      this$1.readyCbs.forEach(function (cb) &#123;</div><div class="line">        cb(route);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  function (err) &#123;</div><div class="line">    if (onAbort) &#123;</div><div class="line">      onAbort(err);</div><div class="line">    &#125;</div><div class="line">    if (err &amp;&amp; !this$1.ready) &#123;</div><div class="line">      this$1.ready = true;</div><div class="line">      this$1.readyErrorCbs.forEach(function (cb) &#123;</div><div class="line">        cb(err);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) &#123;</div><div class="line">  var this$1 = this;</div><div class="line"></div><div class="line">  var current = this.current;</div><div class="line">  var abort = function (err) &#123;</div><div class="line">    // after merging https://github.com/vuejs/vue-router/pull/2771 we</div><div class="line">    // When the user navigates through history through back/forward buttons</div><div class="line">    // we do not want to throw the error. We only throw it if directly calling</div><div class="line">    // push/replace. That&apos;s why it&apos;s not included in isError</div><div class="line">    if (!isExtendedError(NavigationDuplicated, err) &amp;&amp; isError(err)) &#123;</div><div class="line">      if (this$1.errorCbs.length) &#123;</div><div class="line">        this$1.errorCbs.forEach(function (cb) &#123;</div><div class="line">          cb(err);</div><div class="line">        &#125;);</div><div class="line">      &#125; else &#123;</div><div class="line">        warn(false, &apos;uncaught error during route navigation:&apos;);</div><div class="line">        console.error(err);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    onAbort &amp;&amp; onAbort(err);</div><div class="line">  &#125;;</div><div class="line">  if (</div><div class="line">    isSameRoute(route, current) &amp;&amp;</div><div class="line">    // in the case the route map has been dynamically appended to</div><div class="line">    route.matched.length === current.matched.length</div><div class="line">  ) &#123;</div><div class="line">    this.ensureURL();</div><div class="line">    return abort(new NavigationDuplicated(route))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var ref = resolveQueue(</div><div class="line">    this.current.matched,</div><div class="line">    route.matched</div><div class="line">  );</div><div class="line">    var updated = ref.updated;</div><div class="line">    var deactivated = ref.deactivated;</div><div class="line">    var activated = ref.activated;</div><div class="line"></div><div class="line">  var queue = [].concat(</div><div class="line">    // in-component leave guards</div><div class="line">    extractLeaveGuards(deactivated),</div><div class="line">    // global before hooks</div><div class="line">    this.router.beforeHooks,</div><div class="line">    // in-component update hooks</div><div class="line">    extractUpdateHooks(updated),</div><div class="line">    // in-config enter guards</div><div class="line">    activated.map(function (m) &#123; return m.beforeEnter; &#125;),</div><div class="line">    // async components</div><div class="line">    resolveAsyncComponents(activated)</div><div class="line">  );</div><div class="line"></div><div class="line">  this.pending = route;</div><div class="line">  var iterator = function (hook, next) &#123;</div><div class="line">    if (this$1.pending !== route) &#123;</div><div class="line">      return abort()</div><div class="line">    &#125;</div><div class="line">    try &#123;</div><div class="line">      hook(route, current, function (to) &#123;</div><div class="line">        if (to === false || isError(to)) &#123;</div><div class="line">          // next(false) -&gt; abort navigation, ensure current URL</div><div class="line">          this$1.ensureURL(true);</div><div class="line">          abort(to);</div><div class="line">        &#125; else if (</div><div class="line">          typeof to === &apos;string&apos; ||</div><div class="line">          (typeof to === &apos;object&apos; &amp;&amp;</div><div class="line">            (typeof to.path === &apos;string&apos; || typeof to.name === &apos;string&apos;))</div><div class="line">        ) &#123;</div><div class="line">          // next(&apos;/&apos;) or next(&#123; path: &apos;/&apos; &#125;) -&gt; redirect</div><div class="line">          abort();</div><div class="line">          if (typeof to === &apos;object&apos; &amp;&amp; to.replace) &#123;</div><div class="line">            this$1.replace(to);</div><div class="line">          &#125; else &#123;</div><div class="line">            this$1.push(to);</div><div class="line">          &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">          // confirm transition and pass on the value</div><div class="line">          next(to);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125; catch (e) &#123;</div><div class="line">      abort(e);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  runQueue(queue, iterator, function () &#123;</div><div class="line">    var postEnterCbs = [];</div><div class="line">    var isValid = function () &#123; return this$1.current === route; &#125;;</div><div class="line">    // wait until async components are resolved before</div><div class="line">    // extracting in-component enter guards</div><div class="line">    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);</div><div class="line">    var queue = enterGuards.concat(this$1.router.resolveHooks);</div><div class="line">    runQueue(queue, iterator, function () &#123;</div><div class="line">      if (this$1.pending !== route) &#123;</div><div class="line">        return abort()</div><div class="line">      &#125;</div><div class="line">      this$1.pending = null;</div><div class="line">      onComplete(route);//所有需要运行的钩子函数运行完执行更改url,更新current,处理页面滚动</div><div class="line">      if (this$1.router.app) &#123;</div><div class="line">        this$1.router.app.$nextTick(function () &#123;</div><div class="line">          postEnterCbs.forEach(function (cb) &#123;</div><div class="line">            cb();</div><div class="line">          &#125;);</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"> function runQueue (queue, fn, cb) &#123;</div><div class="line">  var step = function (index) &#123;</div><div class="line">    if (index &gt;= queue.length) &#123;</div><div class="line">      cb();</div><div class="line">    &#125; else &#123;</div><div class="line">      if (queue[index]) &#123;</div><div class="line">        fn(queue[index], function () &#123;</div><div class="line">          step(index + 1);</div><div class="line">        &#125;);</div><div class="line">      &#125; else &#123;</div><div class="line">        step(index + 1);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  step(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">History.prototype.updateRoute = function updateRoute (route) &#123;</div><div class="line">  var prev = this.current;</div><div class="line">  this.current = route;</div><div class="line">  this.cb &amp;&amp; this.cb(route); //通知app更改_route属性值，即更改$route值</div><div class="line">  this.router.afterHooks.forEach(function (hook) &#123;</div><div class="line">    hook &amp;&amp; hook(route, prev);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line">this.cb在install的时候被定义如果获取</div><div class="line">History.prototype.listen = function listen (cb) &#123;</div><div class="line">  this.cb = cb;</div><div class="line">&#125;;</div><div class="line">//在new vue时被定义</div><div class="line">VueRouter.prototype.init = function init (app ) &#123;</div><div class="line">  history.listen(function (route) &#123;</div><div class="line">    this$1.apps.forEach(function (app) &#123;</div><div class="line">      app._route = route;</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">//install的时候</div><div class="line">function install (Vue) &#123;</div><div class="line">  Object.defineProperty(Vue.prototype, &apos;$route&apos;, &#123;</div><div class="line">    get: function get () &#123; return this._routerRoot._route &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="link标签跳转路由"><a href="#link标签跳转路由" class="headerlink" title="link标签跳转路由"></a>link标签跳转路由</h2><p>点击link标签时，根据绑定函数即可知道，同样会调用router.push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var router = this.$router;</div><div class="line">var current = this.$route;</div><div class="line">var ref = router.resolve(</div><div class="line">  this.to,</div><div class="line">  current,</div><div class="line">  this.append</div><div class="line">);</div><div class="line"></div><div class="line">var location = ref.location;</div><div class="line">var route = ref.route;</div><div class="line">var href = ref.href;</div><div class="line"></div><div class="line">var handler = function (e) &#123;</div><div class="line">  if (guardEvent(e)) &#123;</div><div class="line">    if (this$1.replace) &#123;</div><div class="line">      router.replace(location, noop);</div><div class="line">    &#125; else &#123;</div><div class="line">      router.push(location, noop);//push,直接走同步流程</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var on = &#123; click: guardEvent &#125;;</div><div class="line">if (Array.isArray(this.event)) &#123;</div><div class="line">  this.event.forEach(function (e) &#123;</div><div class="line">    on[e] = handler;</div><div class="line">  &#125;);</div><div class="line">&#125; else &#123;</div><div class="line">  on[this.event] = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，经过resolve处理过的to标签属性的值，会生成统一规范的后续需要使用的location,route<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">VueRouter.prototype.resolve = function resolve (</div><div class="line">  to,</div><div class="line">  current,</div><div class="line">  append</div><div class="line">) &#123;</div><div class="line">  current = current || this.history.current;</div><div class="line">  var location = normalizeLocation(</div><div class="line">    to,</div><div class="line">    current,</div><div class="line">    append,</div><div class="line">    this</div><div class="line">  );</div><div class="line">  var route = this.match(location, current);</div><div class="line">  var fullPath = route.redirectedFrom || route.fullPath;</div><div class="line">  var base = this.history.base;</div><div class="line">  var href = createHref(base, fullPath, this.mode);</div><div class="line">  return &#123;</div><div class="line">    location: location,</div><div class="line">    route: route,</div><div class="line">    href: href,</div><div class="line">    // for backwards compat</div><div class="line">    normalizedTo: location,</div><div class="line">    resolved: route</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>location 会在normalizeLocation中以第三个return的位置返回如下结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  _normalized: true,</div><div class="line">  path: path,</div><div class="line">  query: query,</div><div class="line">  hash: hash</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样相当于提前normalizeLocation调用，所以在match再调用的时候直接返回自身<br>在接下来的match流程中,会进入以path为依据的流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">else if (location.path) &#123;</div><div class="line">  location.params = &#123;&#125;;</div><div class="line">  for (var i = 0; i &lt; pathList.length; i++) &#123;</div><div class="line">    var path = pathList[i];</div><div class="line">    var record$1 = pathMap[path];//根据path拿到record对象</div><div class="line">    if (matchRoute(record$1.regex, location.path, location.params)) &#123;</div><div class="line">      return _createRoute(record$1, location, redirectedFrom)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据标签to赋予的path值，和生成路由表时拿到的path配置值，根据正则表达式解析params对象，<br>也说明了，为什么跳转路包含动态参数的path时，要跟params配对使用</p>
<h3 id="matchRoute"><a href="#matchRoute" class="headerlink" title="matchRoute"></a>matchRoute</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function matchRoute (</div><div class="line">    regex,</div><div class="line">    path,</div><div class="line">    params</div><div class="line">  ) &#123;</div><div class="line">    var m = path.match(regex);</div><div class="line">    if (!m) &#123;//当前路由不符合route定义时格式</div><div class="line">      return false</div><div class="line">    &#125; else if (!params) &#123;</div><div class="line">      return true</div><div class="line">    &#125;</div><div class="line">    //匹配路由组装params</div><div class="line">    for (var i = 1, len = m.length; i &lt; len; ++i) &#123;</div><div class="line">      var key = regex.keys[i - 1];</div><div class="line">      var val = typeof m[i] === &apos;string&apos; ? decodeURIComponent(m[i]) : m[i];//始终为子字符串</div><div class="line">      if (key) &#123;</div><div class="line">        // Fix #1994: using * with props: true generates a param named 0</div><div class="line">        params[key.name || &apos;pathMatch&apos;] = val;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return true</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="直接更改url跳转"><a href="#直接更改url跳转" class="headerlink" title="直接更改url跳转"></a>直接更改url跳转</h2><p>在浏览器直接更改含有动态路由的的url，回车跳转，会根据事先绑定的监听事件进行解析处理<br>在new vue时初始化完当前路由，以执行回调的方式绑定监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  VueRouter.prototype.init = function init (app /* Vue component instance */) &#123;</div><div class="line">  var this$1 = this;</div><div class="line"></div><div class="line">  this.app = app;</div><div class="line"></div><div class="line">  var history = this.history;</div><div class="line"></div><div class="line">  if (history instanceof HTML5History) &#123; //h5history在new h5history时，在构造函数中设置popstate事件监听</div><div class="line">    history.transitionTo(history.getCurrentLocation());</div><div class="line">  &#125; else if (history instanceof HashHistory) &#123;</div><div class="line">    var setupHashListener = function () &#123;</div><div class="line">      history.setupListeners();//设置监听</div><div class="line">    &#125;;</div><div class="line">    history.transitionTo( //无论成功与否都绑定</div><div class="line">      history.getCurrentLocation(),</div><div class="line">      setupHashListener, </div><div class="line">      setupHashListener</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  history.listen(function (route) &#123; //route改变时调用，this.cb</div><div class="line">    this$1.apps.forEach(function (app) &#123;</div><div class="line">      app._route = route;</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>设置监听具体内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">HashHistory.prototype.setupListeners = function setupListeners () &#123;</div><div class="line">    var this$1 = this;</div><div class="line"></div><div class="line">    var router = this.router;</div><div class="line">    var expectScroll = router.options.scrollBehavior;</div><div class="line">    var supportsScroll = supportsPushState &amp;&amp; expectScroll;</div><div class="line"></div><div class="line">    if (supportsScroll) &#123;</div><div class="line">      setupScroll();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    window.addEventListener(</div><div class="line">      supportsPushState ? &apos;popstate&apos; : &apos;hashchange&apos;,</div><div class="line">      function () &#123;</div><div class="line">        var current = this$1.current;</div><div class="line">        if (!ensureSlash()) &#123;</div><div class="line">          return</div><div class="line">      &#125;</div><div class="line">       //直接调用transitionTo进行路由更新</div><div class="line">      this$1.transitionTo(getHash(), function (route) &#123; //成功回调不用pushHash更新url</div><div class="line">        if (supportsScroll) &#123;</div><div class="line">          handleScroll(this$1.router, route, current, true);</div><div class="line">        &#125;</div><div class="line">        if (!supportsPushState) &#123;</div><div class="line">          replaceHash(route.fullPath);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可见通过监听事件触发的路由改变会直接调用transitionTo函数进行跳转</p>
<h1 id="两个收获"><a href="#两个收获" class="headerlink" title="两个收获"></a>两个收获</h1><p>1.normalizeLocation函数发挥的作用，根据第一参数location对象不同的属性状态进行不同的处理，用于在上游的不同情境(不同方式导致跳转)使用中统一调用<br>2.在transitionTo函数中调用comfirmTransition,为什么不直接在transitionTo函数中书写confirmTransition函数内容呢，为什么要单独摘出来呢？同样，comfirmTransition函数不止会在transition中调用,<br>还会在AbstractHistory的go函数中被直接调用，HashHistory和HTML5History的go方法会直接使用window.history.go(n);nodejs全局对象是global,不是windows,所以需要特殊处理</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 源码学习二【编译器】</title>
    <link href="http://yoohannah.github.io/post/vue/src2.html"/>
    <id>http://yoohannah.github.io/post/vue/src2.html</id>
    <published>2020-02-05T04:41:15.000Z</published>
    <updated>2020-02-29T15:46:37.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/lifecycle.png" alt="Vue声明周期"><br>分析官网的流程图可知<br>new Vue时，进行一系列initxxx初始化工作后会根据选项el和template配置情况去做编译<br>即<br>情况1：挂载了el和template情况下直接去将template编译成渲染函数<br>情况2：挂载了el而没有挂载template情况下，将以el外部的html为template进行编译<br>情况3：没有挂载el的情况下，需要手动调用$mount函数挂载，这时再去判断有没有挂载template，在进行依据template有无继续接下来的编译工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._init = function (options) &#123;</div><div class="line">    var vm = this;</div><div class="line">    vm._uid = uid$3++;</div><div class="line">    var startTag, endTag;</div><div class="line">    vm._isVue = true;  // 防止被监听的标识</div><div class="line">    //合并内置选项与传进来的选项</div><div class="line">    if (options &amp;&amp; options._isComponent) &#123;</div><div class="line">      initInternalComponent(vm, options);</div><div class="line">    &#125; else &#123;</div><div class="line">      vm.$options = mergeOptions(</div><div class="line">        resolveConstructorOptions(vm.constructor),</div><div class="line">        options || &#123;&#125;,</div><div class="line">        vm</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">    /* istanbul ignore else */</div><div class="line">    &#123;</div><div class="line">      initProxy(vm);</div><div class="line">    &#125;</div><div class="line">    //进行一系列初始化</div><div class="line">    vm._self = vm;</div><div class="line">    initLifecycle(vm);</div><div class="line">    initEvents(vm);</div><div class="line">    initRender(vm);</div><div class="line">    callHook(vm, &apos;beforeCreate&apos;);</div><div class="line">    initInjections(vm); </div><div class="line">    initState(vm);//对数据进行劫持</div><div class="line">    initProvide(vm); </div><div class="line">    callHook(vm, &apos;created&apos;);</div><div class="line"></div><div class="line">    if (vm.$options.el) &#123; //判断有没有配置el,有则调用vm.$mount进入情况1和2，没有则进入情况3，等待手动调用vm.$mount</div><div class="line">      vm.$mount(vm.$options.el);//生成渲染函数后，给option挂上render，staticRenderFns属性</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="mount挂载函数的巧妙设计"><a href="#mount挂载函数的巧妙设计" class="headerlink" title="$mount挂载函数的巧妙设计"></a>$mount挂载函数的巧妙设计</h1><p>一开始定义的$mount仅用于运行时，功能是将编译好的渲染函数运行实现挂载组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$mount = function ( </div><div class="line">  el,</div><div class="line">  hydrating</div><div class="line">) &#123;</div><div class="line">  el = el &amp;&amp; inBrowser ? query(el) : undefined;</div><div class="line">  return mountComponent(this, el, hydrating)</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>之后会将运行时定义存放到另一个变量<br>方便定义之后包含编译步骤的挂载函数，<br>同时编译运行方案还会调用这个函数<br>这样在打包时，就可以方便的去掉进行编译过程的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var mount = Vue.prototype.$mount;</div></pre></td></tr></table></figure></p>
<p>在定义含有编译过程的挂载函数，将template编译成渲染函数<br>再调用运行时$mount(这时依托在mount变量上)，进行挂载组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$mount = function (</div><div class="line">  el,</div><div class="line">  hydrating</div><div class="line">) &#123;</div><div class="line">  el = el &amp;&amp; query(el);//query检查挂载点dom是否存在</div><div class="line">  //不要挂载到&lt;body&gt;元素或者&lt;html&gt;元素,</div><div class="line">  //因为挂载点的本意是组件挂载的占位，它将会被组件自身的模板替换掉，而&lt;body&gt;元素和&lt;html&gt;元素是不能被替换掉的。</div><div class="line">  if (el === document.body || el === document.documentElement) &#123;</div><div class="line">    warn(</div><div class="line">      &quot;Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.&quot;</div><div class="line">    );</div><div class="line">    return this</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var options = this.$options;</div><div class="line">  // 解析 template/el 转换成render函数</div><div class="line">  if (!options.render) &#123;</div><div class="line">    var template = options.template;</div><div class="line">    if (template) &#123; //配置了template</div><div class="line">      if (typeof template === &apos;string&apos;) &#123;</div><div class="line">        //如果第一个字符是 #，那么会把该字符串作为 css 选择符</div><div class="line">        //去选中对应的元素，并把该元素的 innerHTML 作为模板</div><div class="line">        if (template.charAt(0) === &apos;#&apos;) &#123;</div><div class="line">          template = idToTemplate(template);</div><div class="line">          if (!template) &#123;</div><div class="line">            warn((&quot;Template element not found or is empty: &quot; + (options.template)),this);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; else if (template.nodeType) &#123; </div><div class="line">        //如果第一个字符不是 #，且template的类型是元素节点,</div><div class="line">        //那就用 template 自身的字符串值作为模板</div><div class="line">        template = template.innerHTML;</div><div class="line">      &#125; else &#123;&#123; warn(&apos;invalid template option:&apos; + template, this);&#125;</div><div class="line">        //否则报错不存在配置的template</div><div class="line">        return this</div><div class="line">      &#125;</div><div class="line">    &#125; else if (el) &#123; //如果template选项不存在，那么使用el元素的outerHTML作为模板内容</div><div class="line">      template = getOuterHTML(el);</div><div class="line">    &#125;</div><div class="line">    if (template) &#123;</div><div class="line">      //编译生成静态结点渲染函数和动态结点渲染函数</div><div class="line">      var ref = compileToFunctions(template, &#123;...参数下文有说明&#125;, this);</div><div class="line">      var render = ref.render;</div><div class="line">      var staticRenderFns = ref.staticRenderFns;</div><div class="line">      //生成渲染函数后，给option挂上render，staticRenderFns渲染函数属性</div><div class="line">      options.render = render;</div><div class="line">      options.staticRenderFns = staticRenderFns;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return mount.call(this, el, hydrating) //调用运行时挂载函数</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="compileToFunctions"><a href="#compileToFunctions" class="headerlink" title="compileToFunctions"></a>compileToFunctions</h1><p>compileToFunctions 作用就两个<br>1.调用compile编译生成渲染函数字符串<br>2.将渲染函数字符串生成渲染返回返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">function createCompileToFunctionFn (compile) &#123;</div><div class="line">  var cache = Object.create(null);</div><div class="line">  return function compileToFunctions (template, options,vm) &#123;</div><div class="line">    options = extend(&#123;&#125;, options);</div><div class="line">    var warn$$1 = options.warn || warn;</div><div class="line">    delete options.warn;</div><div class="line">      &#123;  //检测 new Function() 是否可用，</div><div class="line">         //在某些极端情况下(如CSP限制)给一个有用的提示</div><div class="line">        try &#123;new Function(&apos;return 1&apos;);&#125; catch (e) &#123;</div><div class="line">          if (e.toString().match(/unsafe-eval|CSP/)) &#123;</div><div class="line">            warn$$1(...警告内容);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    // 有缓存直接返回缓存，不用在进行编译一次，</div><div class="line">    // cache在闭包父域定义，相当于全局，</div><div class="line">    // 所以每次编译的结果都可以缓存起来</div><div class="line">    //options.delimiters这个选项是配置纯文本插入分隔符</div><div class="line">    //这里用来拼接做缓存key值</div><div class="line">    var key = options.delimiters </div><div class="line">      ? String(options.delimiters) + template</div><div class="line">      : template;</div><div class="line">    if (cache[key]) &#123;</div><div class="line">      return cache[key]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //调用 baseCompile编译模板并返回其生成的值 </div><div class="line">    var compiled = compile(template, options);</div><div class="line"></div><div class="line">    //将字符串代码转换成函数</div><div class="line">    var res = &#123;&#125;;</div><div class="line">    var fnGenErrors = [];</div><div class="line">    res.render = createFunction(compiled.render, fnGenErrors);</div><div class="line">    res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123;</div><div class="line">      return createFunction(code, fnGenErrors)</div><div class="line">    &#125;);</div><div class="line">    return (cache[key] = res)//缓存字符串模板的编译结果，防止重复编译，提升性能</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>try-catch语句如果有错误发生且错误的内容中<br>包含如 ‘unsafe-eval’ 或者 ‘CSP’ 这些字样的信息时就会给出一个警告</p>
<p>CSP全称Content Security Policy ,可以直接翻译为内容安全策略<br>就是为了页面内容安全而制定的一系列防护策略<br>通过CSP所约束的的规责指定可信的内容来源<br>（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。<br>通过CSP协定，让WEB处于一个安全的运行环境中</p>
<p>如果你的策略比较严格，那么 new Function() 将会受到影响，从而不能够使用<br>但是将模板字符串编译成渲染函数又依赖 new Function()，所以解决方案有两个：<br>1、放宽你的CSP策略<br>2、预编译</p>
<h1 id="一些变量参数说明"><a href="#一些变量参数说明" class="headerlink" title="一些变量参数说明"></a>一些变量参数说明</h1><p>因为之后分析会用到，事先了解一下</p>
<h2 id="变量之间关系"><a href="#变量之间关系" class="headerlink" title="变量之间关系"></a>变量之间关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var modules$1 = [</div><div class="line">	klass$1,</div><div class="line">	style$1,</div><div class="line">	model$1</div><div class="line">];</div><div class="line"></div><div class="line">var klass$1 = &#123;</div><div class="line">	staticKeys: [&apos;staticClass&apos;],</div><div class="line">	transformNode: transformNode,</div><div class="line">	genData: genData</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var style$1 = &#123;</div><div class="line">	staticKeys: [&apos;staticStyle&apos;],</div><div class="line">	transformNode: transformNode$1,</div><div class="line">	genData: genData$1</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var model$1 = &#123;</div><div class="line">	preTransformNode: preTransformNode</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="baseOptions"><a href="#baseOptions" class="headerlink" title="baseOptions"></a>baseOptions</h2><p>baseOptions包含编译器在运作的时候所需的基本配置选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var baseOptions = &#123;</div><div class="line">  expectHTML: true,</div><div class="line">  modules: modules$1,</div><div class="line">  directives: directives$1,</div><div class="line">  isPreTag: isPreTag,</div><div class="line">  isUnaryTag: isUnaryTag,</div><div class="line">  mustUseProp: mustUseProp,</div><div class="line">  canBeLeftOpenTag: canBeLeftOpenTag,</div><div class="line">  isReservedTag: isReservedTag,</div><div class="line">  getTagNamespace: getTagNamespace,</div><div class="line">  staticKeys: genStaticKeys(modules$1)</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>第三个属性：directives 值是三个属性 (model、text、html) 的对象，且属性的值都是函数。<br>第四个属性：isPreTag 它是一个函数，其作用是通过给定的标签名字检查标签是否是 ‘pre’ 标签。<br>第五个属性：isUnaryTag 是一个通过makeMap生成的函数，该函数的作用是检测给定的标签是否是一元标签。<br>第六个属性：mustUseProp 它是一个函数，其作用是用来检测一个属性在标签中是否要使用props进行绑定。<br>第七个属性：canBeLeftOpenTag 一个使用makeMap生成的函数，它的作用是检测非一元标签，但却可以自己补全并闭合的标签。比如 div 标签是一个双标签，你需要这样使用&lt;div&gt; text &lt;/div&gt;，但是你依然可以省略闭合标签，直接这样写：&lt;div&gt; text ，且浏览器会自动补全。但是有些标签你不可以这样用，它们是严格的双标签。<br>第八个属性：isReservedTag 它是一个函数，其作用是检查给定的标签是否是保留的标签。<br>第九个属性：getTagNamespace 它也是一个函数，其作用是获取元素(标签)的命名空间。<br>第十个属性：staticKeys 它的值是通过以 modules 为参数调用 genStaticKeys 函数的返回值得到的。 其作用是根据编译器选项的 modules 选项生成一个静态键字符串。</p>
<h2 id="compileToFunctions传入的参数"><a href="#compileToFunctions传入的参数" class="headerlink" title="compileToFunctions传入的参数"></a>compileToFunctions传入的参数</h2><p>实际调用时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ref = compileToFunctions(template, &#123;</div><div class="line">  outputSourceRange: &quot;development&quot; !== &apos;production&apos;,</div><div class="line">  shouldDecodeNewlines: shouldDecodeNewlines,</div><div class="line">  shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,</div><div class="line">  delimiters: options.delimiters,//更改纯文本插入符</div><div class="line">  comments: options.comments//设置为true时，保留且渲染模板HTML注释，false时舍弃注释</div><div class="line">&#125;, this);</div></pre></td></tr></table></figure></p>
<p>参数说明<br>在我们innerHTML获取内容时，换行符和制表符分别被转换成了&amp;#10和&amp;#9。<br>在IE中，不仅仅是 a 标签的 href 属性值，任何属性值都存在这个问题<br>这就会影响Vue的编译器在对模板进行编译后的结果，为了避免这些问题Vue需要知道什么时候要做兼容工作，<br>如果 shouldDecodeNewlines 为 true，意味着 Vue 在编译模板的时候，要对属性值中的换行符或制表符做兼容处理。<br>而shouldDecodeNewlinesForHref为true 意味着Vue在编译模板的时候，要对a标签的 href 属性值中的换行符或制表符做兼容处理。<br>delimiters和comments都是 Vue 提供的选项，Vue实例的$options属性<br>delimiters代表纯文本插入分隔符<br>comments代表编译时是否保留注释，会在parse阶段进行判断</p>
<h1 id="compiler编译器生成"><a href="#compiler编译器生成" class="headerlink" title="compiler编译器生成"></a>compiler编译器生成</h1><p>compiler的爷爷createCompilerCreator，<br>会生成compiler的爸爸createCompiler<br>createCompiler会生成compiler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">function createCompilerCreator (baseCompile) &#123;</div><div class="line">  return function createCompiler (baseOptions) &#123;</div><div class="line">    function compile (</div><div class="line">      template,</div><div class="line">      options</div><div class="line">    ) &#123;</div><div class="line">      //所有的配置选项最终都会挂载在这个finalOptions 对象上</div><div class="line">      var finalOptions = Object.create(baseOptions);</div><div class="line">      var errors = [];</div><div class="line">      var tips = [];</div><div class="line">      var warn = function (msg, range, tip) &#123; (tip ? tips : errors).push(msg) &#125;;</div><div class="line">      //options为调用 compileToFunctions 函数时传递的选项参数。</div><div class="line">      //baseOptions理解为编译器的默认选项或者基本选项，options 是用来提供定制能力的扩展选项</div><div class="line">      if (options) &#123;</div><div class="line">        // merge custom modules</div><div class="line">        //如果 options.modules 存在，就在 finalOptions 对象上添加 modules 属性，</div><div class="line">        //其值为 baseOptions.modules 和 options.modules 这两个数组合并后的新数组</div><div class="line">        if (options.modules) &#123;</div><div class="line">          finalOptions.modules =</div><div class="line">            (baseOptions.modules || []).concat(options.modules);</div><div class="line">        &#125;</div><div class="line">        // merge custom directives</div><div class="line">        //对于directives 采用原型链的原理实现扩展属性对基本属性的覆盖</div><div class="line">        if (options.directives) &#123;</div><div class="line">          finalOptions.directives = extend(</div><div class="line">            Object.create(baseOptions.directives || null),</div><div class="line">            options.directives</div><div class="line">          );</div><div class="line">        &#125;</div><div class="line">        // copy other options</div><div class="line">        for (var key in options) &#123;</div><div class="line">          if (key !== &apos;modules&apos; &amp;&amp; key !== &apos;directives&apos;) &#123;</div><div class="line">            finalOptions[key] = options[key];</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      finalOptions.warn = warn;</div><div class="line"></div><div class="line">      var compiled = baseCompile(template.trim(), finalOptions);//调用 baseCompile并返回其生成的值</div><div class="line">      &#123;</div><div class="line">        detectErrors(compiled.ast, warn);</div><div class="line">      &#125;</div><div class="line">      compiled.errors = errors;</div><div class="line">      compiled.tips = tips;</div><div class="line">      return compiled</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">      compile: compile,</div><div class="line">      compileToFunctions: createCompileToFunctionFn(compile)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>传入实际编译器生成createCompiler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var createCompiler = createCompilerCreator(function baseCompile (</div><div class="line">  template,</div><div class="line">  options</div><div class="line">) &#123;</div><div class="line">  var ast = parse(template.trim(), options);</div><div class="line">  if (options.optimize !== false) &#123;</div><div class="line">    optimize(ast, options);</div><div class="line">  &#125;</div><div class="line">  var code = generate(ast, options);</div><div class="line">  return &#123;</div><div class="line">    ast: ast,</div><div class="line">    render: code.render,</div><div class="line">    staticRenderFns: code.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">var ref$1 = createCompiler(baseOptions);</div><div class="line">var compile = ref$1.compile;</div><div class="line">var compileToFunctions = ref$1.compileToFunctions;</div></pre></td></tr></table></figure></p>
<p>可见compileToFunctions也由createCompiler函数生成<br>createCompiler函数 由 createCompilerCreator函数在传入函数 baseCompile 条件下生成<br>在createCompiler函数中会声明compile函数,在compile中会调用 baseCompile并返回其生成的值<br>然后对 createCompileToFunctionFn 函数传入compile函数，返回一个函数即compileToFunctions<br>在compileToFunctions 函数中会调用compile函数并处理其返回值<br>最终生成render和staticRenderFns属性<br>所以可见在compileToFunctions还是在调用baseCompile来生成render和staticRenderFns属性，<br>现在摘出来主要逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//base函数</div><div class="line">function baseCompile (</div><div class="line">  template,</div><div class="line">  options</div><div class="line">) &#123;</div><div class="line">  var ast = parse(template.trim(), options);</div><div class="line">  if (options.optimize !== false) &#123;</div><div class="line">    optimize(ast, options);</div><div class="line">  &#125;</div><div class="line">  var code = generate(ast, options);</div><div class="line">  return &#123;</div><div class="line">    ast: ast,</div><div class="line">    render: code.render,</div><div class="line">    staticRenderFns: code.staticRenderFns</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// compileToFunctions调用compile</div><div class="line">// 实际调用 baseCompile得到其生成的值</div><div class="line">var compiled = compile(template, options);</div><div class="line"></div><div class="line">// 调用后处理</div><div class="line">//将字符串转成函数</div><div class="line">var res = &#123;&#125;;</div><div class="line">var fnGenErrors = [];</div><div class="line">res.render = createFunction(compiled.render, fnGenErrors);</div><div class="line">res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123;</div><div class="line">  return createFunction(code, fnGenErrors)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>baseCompile 的主要核心代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var ast =parse(template.trim(), options);</div></pre></td></tr></table></figure></p>
<p>parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">optimize(ast, options);</div></pre></td></tr></table></figure></p>
<p>optimize 的主要作用是标记 static 静态节点，<br>这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时<br>会有一个 patch 的过程， diff 算法会直接跳过静态节点<br>从而减少了比较的过程，优化了 patch 的性能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var code =generate(ast, options);</div></pre></td></tr></table></figure></p>
<p>生成目标平台所需的代码，将 AST 转化成 render function 字符串的过程<br>得到结果是 render 的字符串以及 staticRenderFns 字符串。</p>
<h1 id="编译器的基本知识"><a href="#编译器的基本知识" class="headerlink" title="编译器的基本知识"></a>编译器的基本知识</h1><p>编译器的技术分为词法分析、语法分析和语义分析三个部分<br>通常编译器的第一项工作叫做词法分析<br>就像阅读文章一样，文章是由一个个的中文单词组成的<br>程序处理也一样，只不过这里不叫单词，而是叫做“词法记号”，英文叫 Token<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot; v-if=&quot;ret&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>其实，我们可以手写程序制定一些规则来区分每个不同的 Token，<br>这些规则用“正则文法”表达，符合正则文法的表达式称为“正则表达式”<br>通过他们来完成具体的词法分析工作</p>
<p>编译器下一个阶段的工作是语法分析<br>词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构<br>这个结构是一个树状结构，是计算机容易理解和执行的<br>程序也要定义良好的语法结构，它的语法分析过程，就是构造这么一棵树<br>一个程序就是一棵树，这棵树叫做抽象语法树（Abstract Syntax Tree，AST)<br>树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。</p>
<p>而我们这里要讲的 parser 就是在编译器对源代码处理的第一步<br>parser 把某种特定格式的文本（字符串）转换成某种数据结构的程序(对象)<br>并且这个数据结构是编译器能够理解的<br>因为编译器的后续步骤<br>比如上面提到的 句法分析，类型检查/推导，代码优化，代码生成 等等都依赖于该数据结构</p>
<p><b>注：parse &amp; parser 这两个单词，不要混淆，parse 是动词，代表“解析”的过程，parser 是名词，代表“解析器”。</b><br>Vue 的编译器也不例外, 在词法分析阶段 Vue 会把字符串模板解析成一个个的令牌(token)<br>该令牌将用于句法分析阶段，在句法分析阶段会根据令牌生成一棵 AST<br>最后再根据该 AST生成最终的渲染函数，这样就完成了代码的生成</p>
<h1 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h1><p>进入baseCompile第一步就是调用parse,将HTML转成AST</p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>parse函数中会声明一系列变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">warn$2 = options.warn || baseWarn; //打印警告信息</div><div class="line">//一个编译器选项，其作用是通过给定的标签名字判断该标签是否是 pre 标签</div><div class="line">platformIsPreTag = options.isPreTag || no;</div><div class="line">//一个编译器选项，其作用是用来检测一个属性在标签中是否要使用元素对象原生的 prop 进行绑定</div><div class="line">platformMustUseProp = options.mustUseProp || no;</div><div class="line">//一个编译器选项，其作用是用来获取元素(标签)的命名空间</div><div class="line">platformGetTagNamespace = options.getTagNamespace || no;</div><div class="line"></div><div class="line">transforms = pluckModuleFunction(options.modules, &apos;transformNode&apos;);</div><div class="line">preTransforms = pluckModuleFunction(options.modules, &apos;preTransformNode&apos;);</div><div class="line">postTransforms = pluckModuleFunction(options.modules, &apos;postTransformNode&apos;);</div><div class="line"></div><div class="line">delimiters = options.delimiters;//在创建 Vue 实例对象时所传递的 delimiters 选项</div><div class="line">/**存储开始标签，与解析到的闭合标签对比，进行一元标签处理和双标签判断处理**/</div><div class="line">var stack = [];</div><div class="line">//options.preserveWhitespace 选项用来告诉编译器在编译 html 字符串时是否放弃标签之间的空格</div><div class="line">//如果为 true 则代表放弃。</div><div class="line">var preserveWhitespace = options.preserveWhitespace !== false;</div><div class="line">var whitespaceOption = options.whitespace;</div><div class="line">var currentParent;/**维护元素描述对象之间的父子关系，当前节点父元素**/</div><div class="line">var inVPre = false;//标识当前解析的标签是否在拥有 v-pre 的标签之内</div><div class="line">var inPre = false;//标识当前正在解析的标签是否在 &lt;pre&gt;&lt;/pre&gt; 标签之内</div><div class="line">var root;/**存储最终生成的AST**/</div></pre></td></tr></table></figure></p>
<h2 id="parseHTML"><a href="#parseHTML" class="headerlink" title="parseHTML"></a>parseHTML</h2><p>parse 函数中会执行parseHTML函数，然后返回root,即AST<br>parseHTML 函数的作用就是用来做词法分析的<br>parse函数的作用则是在词法分析的基础上传入回调，做句法分析从而生成一棵AST<br>被调用时传入参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">parseHTML(template, &#123;</div><div class="line">  warn: warn$2,</div><div class="line">  expectHTML: options.expectHTML,</div><div class="line">  isUnaryTag: options.isUnaryTag,</div><div class="line">  canBeLeftOpenTag: options.canBeLeftOpenTag,</div><div class="line">  shouldDecodeNewlines: options.shouldDecodeNewlines,</div><div class="line">  shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,</div><div class="line">  shouldKeepComment: options.comments,//对应配置项comments,true为保留模板中注释语句</div><div class="line">  outputSourceRange: options.outputSourceRange,</div></pre></td></tr></table></figure></p>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p> 解析完一段模板的开始标签后的回调<br> 例如：&lt;div id=’jk’ class=’menu’ v-if=’isShow’&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;<br> 解析完&lt;div id=’jk’ class=’menu’ v-if=’isShow’&gt;的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">start: function start (tag, attrs, unary, start$1, end) &#123;</div><div class="line">  // check namespace.</div><div class="line">  // inherit parent ns if there is one</div><div class="line">  var ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag);</div></pre></td></tr></table></figure></p>
<p>ns 变量，代表标签的命名空间<br>platformGetTagNamespace 函数只会获取 svg 和 math 这两个标签的命名空间<br>但这两个标签的所有子标签都会继承它们两个的命名空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// handle IE svg bug</div><div class="line">/* istanbul ignore if */</div><div class="line">if (isIE &amp;&amp; ns === &apos;svg&apos;) &#123;</div><div class="line">  attrs = guardIESVGBug(attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里通过isIE来判断宿主环境是不是IE浏览器，并且前元素的命名空间为svg<br>如果是通过guardIESVGBug处理当前元素的属性数组attrs，并使用处理后的结果重新赋值给attrs变量<br>该问题是svg标签中渲染多余的属性，如下svg标签：<br>&lt;svg xmlns:feature=”<a href="http://www.openplans.org/topp&quot;&gt;&lt;/svg&amp;gt" target="_blank" rel="external">http://www.openplans.org/topp&quot;&gt;&lt;/svg&amp;gt</a>;<br>被渲染为:<br>&lt;svg xmlns:NS1=”” NS1:xmlns:feature=”<a href="http://www.openplans.org/topp&quot;&quot;&gt;&lt;/svg&amp;gt" target="_blank" rel="external">http://www.openplans.org/topp&quot;&quot;&gt;&lt;/svg&amp;gt</a>;<br>标签中多了 ‘xmlns:NS1=”” NS1:’ 这段字符串，解决办法也很简单，将整个多余的字符串去掉即可<br>而 guardIESVGBug 函数就是用来修改NS1:xmlns:feature属性并移除xmlns:NS1=”” 属性的</p>
<p>接着start函数会创建虚拟结点，返回一个描述该标签的对象结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var element = createASTElement(tag, attrs, currentParent); //下文有代码</div><div class="line">if (ns) &#123;</div><div class="line">  element.ns = ns;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  if (options.outputSourceRange) &#123; //处理虚拟节点占用原模板源码范围</div><div class="line">    element.start = start$1;</div><div class="line">    element.end = end;</div><div class="line">    element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) &#123;</div><div class="line">      cumulated[attr.name] = attr;</div><div class="line">      return cumulated</div><div class="line">    &#125;, &#123;&#125;);</div><div class="line">  &#125;</div><div class="line">  //检查每个属性名是否符合规则</div><div class="line">  attrs.forEach(function (attr) &#123;</div><div class="line">    if (invalidAttributeRE.test(attr.name)) &#123; </div><div class="line">      warn$2(&apos;属性名不能包含空格引号&lt;, &gt;, / 或者 =&apos;,</div><div class="line">        &#123;start: attr.start + attr.name.indexOf(&quot;[&quot;),end: attr.start + attr.name.length&#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">//是否是不允许的style或者script标签，而且不是在服务端渲染的情况下 isForbiddenTag下文有</div><div class="line">if (isForbiddenTag(element) &amp;&amp; !isServerRendering()) &#123; </div><div class="line">  element.forbidden = true;</div><div class="line">  warn$2(...警告内容，&#123; start: element.start &#125;);</div><div class="line">&#125;</div><div class="line">for (var i = 0; i &lt; preTransforms.length; i++) &#123;</div><div class="line">  element = preTransforms[i](element, options) || element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>preTransforms 是通过pluckModuleFunction 函数从options.modules 选项中筛选出名字为preTransformNode 函数所组成的数组<br>实际上 preTransforms 数组中只有一个 preTransformNode 函数该函数只用来处理 input 标签</p>
<p>inVpre 定义在parse函数中，一开始为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">if (!inVPre) &#123;</div><div class="line">  //解析是否有配置v-pre指令，有的话删除</div><div class="line">  //v-pre指令可以跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。</div><div class="line">  //跳过大量没有指令的节点会加快编译。</div><div class="line">  processPre(element); </div><div class="line">  if (element.pre) &#123;</div><div class="line">    inVPre = true;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (platformIsPreTag(element.tag)) &#123;</div><div class="line">  inPre = true;</div><div class="line">&#125;</div><div class="line">if (inVPre) &#123;</div><div class="line">  processRawAttrs(element);</div><div class="line">&#125; else if (!element.processed) &#123;  // 处理结构指令v-for,v-if,v-once</div><div class="line">  //processFor会将解析的结果挂到element上</div><div class="line">  //&#123;for:in后面的数组表达式，alias:in前的表达式&#125;</div><div class="line">  //解析结果只是对表达式进行解析,in/of前后配置的啥，解析出来</div><div class="line">  processFor(element);</div><div class="line">  processIf(element);//处理v-if,v-else,v-else-if的表达式</div><div class="line">  processOnce(element);//处理v-once指令</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所有process<em> 系列函数的作用都会先拿到解析的配置的值，<br>然后将v-</em>属性从attrsList列表里面移除，只剩下纯html支持的属性<br>将针对v-*属性的解析结果挂到虚拟节点对象上<br>使这个对象能更加详细地描述一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!root) &#123;</div><div class="line">  root = element;//root节点没有挂载东西时，挂上，即找到了根节点</div><div class="line">  &#123;</div><div class="line">    checkRootConstraints(root);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编写 Vue 模板的时候会受到两种约束<br>首先模板必须有且仅有一个被渲染的根元素<br>第二不能使用 slot 标签和 template 标签作为模板的根元素<br>checkRootConstraints 函数内部首先通过判断el.tag === ‘slot’ || el.tag === ‘template’<br>来判断根元素是否是slot 标签或 template 标签<br>如果是则打印警告信息<br>接着会判断当前元素是否使用了 v-for 指令<br>因为v-for 指令会渲染多个节点所以根元素是不允许使用 v-for 指令的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">  //这里的stack是parse函数中定义的stack</div><div class="line">  if (!unary) &#123;//非一元标签</div><div class="line">    currentParent = element;//确定当前节点即接下来标签的父节点</div><div class="line">    stack.push(element);//存入栈中，到时供结束标签判断，前一个标签是一元标签还是最近的开始标签</div><div class="line">  &#125; else &#123;</div><div class="line">    //如果是一元的话，解析结束，调用结束标签函数，该函数在parseHTML函数调用前，parse函数中定义</div><div class="line">    closeElement(element);//会建立父子结点关系</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在解析完开始标签后，回调函数会做以下几件事<br>1.针对ie浏览器对svg和math标签属性做一个兼容性处理<br>2.生成虚拟dom对象<br>3.标识开始标签在原始代码所在的位置<br>4.检查属性命名是否规则<br>5.检查是不是不允许的script和style标签<br>6.处理配置的v-for,v-if,v-once属性<br>7.如果根结点还没有被挂载，则挂载到根结点root上，然后检查是否允许挂到根结点(template,slot,v-for)<br>8.如果是一元标签,解析结束;如果不是，更新当前父元素结点为该虚拟dom,并存入stack,用于配对结束标签</p>
<h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p>解析完一个结束标签时调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">end: function end (tag, start, end$1) &#123;</div><div class="line">  var element = stack[stack.length - 1];</div><div class="line">  //每当遇到一个非一元标签的结束标签时，</div><div class="line">  //都会回退 currentParent 变量的值为之前的值</div><div class="line">  //这样我们就修正了当前正在解析的元素的父级元素</div><div class="line">  //在解析兄弟节点时是必须要这样做的</div><div class="line">  stack.length -= 1;</div><div class="line">  currentParent = stack[stack.length - 1];</div><div class="line">  if (options.outputSourceRange) &#123;</div><div class="line">    element.end = end$1;</div><div class="line">  &#125;</div><div class="line">  closeElement(element);</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="chars"><a href="#chars" class="headerlink" title="chars"></a>chars</h3><p>解析到一段非标签内容后调用<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>拿到’hello‘这一段后调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">chars: function chars (text, start, end) &#123; </div><div class="line">  if (!currentParent) &#123; //一些边界情况处理</div><div class="line">    &#123;//没有根元素，只有文本。</div><div class="line">      if (text === template) &#123; </div><div class="line">        warnOnce(&apos;Component template requires a root element, rather than just text.&apos;,&#123; start: start &#125;</div><div class="line">        );</div><div class="line">      &#125; else if ((text = text.trim())) &#123; //文本在根元素之外</div><div class="line">        warnOnce((&quot;text \&quot;&quot; + text + &quot;\&quot; outside root element will be ignored.&quot;),&#123; start: start &#125;</div><div class="line">        );</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  //来解决 IE 浏览器中渲染 &lt;textarea&gt; 标签的 placeholder 属性时存在的 bug 的</div><div class="line">  if (isIE &amp;&amp; currentParent.tag === &apos;textarea&apos; &amp;&amp; currentParent.attrsMap.placeholder === text</div><div class="line">  ) &#123;return&#125;</div><div class="line"></div><div class="line">  var children = currentParent.children;</div><div class="line">  //对空格空行进行删除,编译器只会保留那些 不存在于开始标签之后的空格。</div><div class="line">  if (inPre || text.trim()) &#123; </div><div class="line">    //isTextTag判断是不是style或者script标签</div><div class="line">    //decodeHTMLCached 函数对文本进行解码。</div><div class="line">    text = isTextTag(currentParent) ? text : decodeHTMLCached(text);</div><div class="line">  &#125; else if (!children.length) &#123;</div><div class="line">    text = &apos;&apos;;</div><div class="line">  &#125; else if (whitespaceOption) &#123;</div><div class="line">    if (whitespaceOption === &apos;condense&apos;) &#123;</div><div class="line">      //代码压缩模式下，如果包含换行符，删除这样的空白结点，否则压缩成空格</div><div class="line">      text = lineBreakRE.test(text) ? &apos;&apos; : &apos; &apos;;</div><div class="line">    &#125; else &#123;</div><div class="line">      text = &apos; &apos;;</div><div class="line">    &#125;</div><div class="line">  &#125; else &#123;</div><div class="line">    //preserveWhitespace 是一个布尔值代表着是否保留空格，只有它为真的情况下才会保留空格。</div><div class="line">    //但即使preserveWhitespace 常量的值为真，如果当前节点的父节点没有子元素则也不会保留空格，</div><div class="line">    text = preserveWhitespace ? &apos; &apos; : &apos;&apos;;</div><div class="line">  &#125;</div><div class="line">  if (text) &#123;</div><div class="line">    if (!inPre &amp;&amp; whitespaceOption === &apos;condense&apos;) &#123;</div><div class="line">      //将连续的空格压缩为单个空格</div><div class="line">      text = text.replace(whitespaceRE$1, &apos; &apos;);</div><div class="line">    &#125;</div><div class="line">    var res;</div><div class="line">    var child;</div><div class="line">    //模板中存在的文本节点包含了 Vue 语法中的字面量表达式，</div><div class="line">    //而 parseText 函数的作用就是用来解析这段包含了字面量表达式的文本的</div><div class="line">    if (!inVPre &amp;&amp; text !== &apos; &apos; &amp;&amp; (res = parseText(text, delimiters))) &#123;</div><div class="line">      //含有表达式或者变量的情况</div><div class="line">      //res返回动态变量的描述</div><div class="line">      //例&#123;&#123;a&#125;&#125;,返回:&#123;expression: &quot;_s(a)&quot;,tokens: [&#123;@binding: &quot;a&quot;&#125;]</div><div class="line">      child = &#123;</div><div class="line">        type: 2,</div><div class="line">        expression: res.expression,</div><div class="line">        tokens: res.tokens,</div><div class="line">        text: text</div><div class="line">      &#125;;</div><div class="line">    &#125; else if (text !== &apos; &apos; || !children.length || children[children.length - 1].text !== &apos; &apos;) &#123;</div><div class="line">      //纯常量字符串的情况</div><div class="line">      child = &#123;</div><div class="line">        type: 3,</div><div class="line">        text: text</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    if (child) &#123;</div><div class="line">      if (options.outputSourceRange) &#123;</div><div class="line">        child.start = start;</div><div class="line">        child.end = end;</div><div class="line">      &#125;</div><div class="line">      children.push(child);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>主要作用就是处理换行符，空格符，<br>然后按照常量字符串和动态字符串分别创建虚拟dom,<br>因为动态字符串需要进行一下解析<br>对虚拟dom挂载在源码中起止位置信息<br>将虚拟dom推入父节点children属性</p>
<h3 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h3><p>针对解析到的注释进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">  comment: function comment (text, start, end) &#123;</div><div class="line">    //只会处理被标签包裹的注释，因为根节点不允许有兄弟结点</div><div class="line">    if (currentParent) &#123;</div><div class="line">      //普通文本节点与注释节点的元素描述对象的类型是一样的都是 3 ，</div><div class="line">      //不同的是注释节点的元素描述对象拥有 isComment 属性，并且该属性的值为 true，</div><div class="line">      //目的就是用来与普通文本节点作区分的。</div><div class="line">      var child = &#123;</div><div class="line">        type: 3,</div><div class="line">        text: text,</div><div class="line">        isComment: true</div><div class="line">      &#125;;</div><div class="line">      if (options.outputSourceRange) &#123;</div><div class="line">        child.start = start;</div><div class="line">        child.end = end;</div><div class="line">      &#125;</div><div class="line">      currentParent.children.push(child);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="真正的parseHTML"><a href="#真正的parseHTML" class="headerlink" title="真正的parseHTML"></a>真正的parseHTML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">//解析HTML</div><div class="line">function parseHTML (html, options) &#123;</div><div class="line">  var stack = [];//在 while 循环中处理 html 字符流的时候每当遇到一个非单标签，都会将该开始标签 push 到该数组。它的作用模板中 DOM 结构规范性的检测</div><div class="line">  var expectHTML = options.expectHTML;</div><div class="line">  var isUnaryTag$$1 = options.isUnaryTag || no; //用来检测一个标签是否是一元标签</div><div class="line">  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;//用来检测一个标签是否是可以省略闭合标签的非一元标签</div><div class="line">  var index = 0; //标识着当前字符流的读入位置</div><div class="line">  //last 存储剩余还未编译的 html 字符串</div><div class="line">  //lastTag 始终存储着位于 stack 栈顶的元素</div><div class="line">  var last, lastTag;</div><div class="line">  while (html) &#123;</div><div class="line">    last = html; //HTML为待解析的HTML片段，last 保留最原始的片段，advance会在解析过程中切割html</div><div class="line">    // 确保没有在script/style纯文本标签里面</div><div class="line">    //var isPlainTextElement = makeMap(&apos;script,style,textarea&apos;, true);</div><div class="line">    if (!lastTag || !isPlainTextElement(lastTag)) &#123;</div><div class="line">      var textEnd = html.indexOf(&apos;&lt;&apos;);</div><div class="line">      if (textEnd === 0) &#123; //如果以&lt;开头</div><div class="line">        // comment = /^&lt;!\--/;如果是以注释开头的</div><div class="line">        if (comment.test(html)) &#123; </div><div class="line">          var commentEnd = html.indexOf(&apos;--&gt;&apos;); //拿到注释结尾的位置</div><div class="line">          if (commentEnd &gt;= 0) &#123; //如果有完整注释</div><div class="line">            //根据new vue时传递进来的comments选项值判断是否保留模板中注释</div><div class="line">            if (options.shouldKeepComment) &#123;</div><div class="line">              //options.comment在parse函数调用parseHTML时传递进来，即回调</div><div class="line">              //该函数会将html.substring拿到注释的内容包装成 type:3的节点，</div><div class="line">              //然后push进其父节点的children属性</div><div class="line">              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);</div><div class="line">            &#125;</div><div class="line">            advance(commentEnd + 3);//裁剪html模板，位移index的值</div><div class="line">            continue</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 不处理条件注释,直接略过</div><div class="line">        if (conditionalComment.test(html)) &#123;</div><div class="line">          var conditionalEnd = html.indexOf(&apos;]&gt;&apos;);</div><div class="line"></div><div class="line">          if (conditionalEnd &gt;= 0) &#123;</div><div class="line">            advance(conditionalEnd + 2);</div><div class="line">            continue</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // var doctype = /^&lt;!DOCTYPE [^&gt;]+&gt;/i;</div><div class="line">        //不处理&lt;!DOCTYPE&gt;标签</div><div class="line">        var doctypeMatch = html.match(doctype);</div><div class="line">        if (doctypeMatch) &#123;</div><div class="line">          advance(doctypeMatch[0].length);</div><div class="line">          continue</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //var endTag = new RegExp((&quot;^&lt;\\/&quot; + qnameCapture + &quot;[^&gt;]*&gt;&quot;)); </div><div class="line">        //qnameCapture详见parseStartTag函数</div><div class="line">        var endTagMatch = html.match(endTag);</div><div class="line">        if (endTagMatch) &#123;</div><div class="line">          var curIndex = index;</div><div class="line">          advance(endTagMatch[0].length);</div><div class="line">          parseEndTag(endTagMatch[1], curIndex, index);//处理stack中开标签/一元标签</div><div class="line">          continue</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果是正常编写的标签(由&lt;&gt;包裹)返回一个描述开始标签的对象</div><div class="line">        var startTagMatch = parseStartTag();</div><div class="line">        if (startTagMatch) &#123;</div><div class="line">          handleStartTag(startTagMatch);</div><div class="line">          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) &#123;</div><div class="line">            advance(1);</div><div class="line">          &#125;</div><div class="line">          continue</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      //处理html非尖括号开头情况,即解析到文本内容的时候</div><div class="line">      var text = (void 0), rest = (void 0), next = (void 0);</div><div class="line">      if (textEnd &gt;= 0) &#123; //此时html非尖括号开头，但剩下的里面还含有尖括号</div><div class="line">        rest = html.slice(textEnd);//截断尖括号以前的内容，拿到剩下的内容</div><div class="line">        while ( 第一个尖括号不是开始标签也不是结束或者评论标签</div><div class="line">          !endTag.test(rest) &amp;&amp;</div><div class="line">          !startTagOpen.test(rest) &amp;&amp;</div><div class="line">          !comment.test(rest) &amp;&amp;</div><div class="line">          !conditionalComment.test(rest)</div><div class="line">        ) &#123;</div><div class="line">          // 处理文本里的尖括号，直到找到是标签的尖括号的位置，即文本结束的位置</div><div class="line">          next = rest.indexOf(&apos;&lt;&apos;, 1);//从第二个字符开始找剩下html里面的第一个尖括号</div><div class="line">          if (next &lt; 0) &#123; break &#125; //如果没有，直接结束</div><div class="line">          textEnd += next;//如果有的话，重制text结束位置为该尖括号位置</div><div class="line">          rest = html.slice(textEnd);//截取html，在判断尖括号是否是标签或者注释</div><div class="line">        &#125;//while循环的作用是找出非标签内容</div><div class="line">        text = html.substring(0, textEnd);//最终得到非标签内容</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (textEnd &lt; 0) &#123; //html里面没尖括号了</div><div class="line">        text = html;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (text) &#123;</div><div class="line">        advance(text.length);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (options.chars &amp;&amp; text) &#123;</div><div class="line">        options.chars(text, index - text.length, index);//调用回调，处理文本结点</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      //处理textarea内容和结束标签</div><div class="line">      var endTagLength = 0;</div><div class="line">      var stackedTag = lastTag.toLowerCase();</div><div class="line">      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(&apos;([\\s\\S]*?)(&lt;/&apos; + stackedTag + &apos;[^&gt;]*&gt;)&apos;, &apos;i&apos;));</div><div class="line">      //直接通过end标签拿到标签之间的文本内容，从避免分析中间的尖括号内容，直接保留</div><div class="line">      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) &#123;</div><div class="line">        endTagLength = endTag.length;</div><div class="line">        if (!isPlainTextElement(stackedTag) &amp;&amp; stackedTag !== &apos;noscript&apos;) &#123;</div><div class="line">          text = text</div><div class="line">            .replace(/&lt;!\--([\s\S]*?)--&gt;/g, &apos;$1&apos;) // #7298</div><div class="line">            .replace(/&lt;!\[CDATA\[([\s\S]*?)]]&gt;/g, &apos;$1&apos;);</div><div class="line">        &#125;</div><div class="line">        if (shouldIgnoreFirstNewline(stackedTag, text)) &#123;</div><div class="line">          text = text.slice(1);</div><div class="line">        &#125;</div><div class="line">        if (options.chars) &#123;</div><div class="line">          options.chars(text);</div><div class="line">        &#125;</div><div class="line">        return &apos;&apos;</div><div class="line">      &#125;);</div><div class="line">      index += html.length - rest$1.length;</div><div class="line">      html = rest$1;</div><div class="line">      parseEndTag(stackedTag, index - endTagLength, index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (html === last) &#123;</div><div class="line">      options.chars &amp;&amp; options.chars(html);</div><div class="line">      if (!stack.length &amp;&amp; options.warn) &#123;</div><div class="line">        options.warn((&quot;Mal-formatted tag at end of template: \&quot;&quot; + html + &quot;\&quot;&quot;), &#123; start: index + html.length &#125;);</div><div class="line">      &#125;</div><div class="line">      break</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Clean up any remaining tags</div><div class="line">  parseEndTag();</div><div class="line"></div><div class="line">  function advance (n) &#123;</div><div class="line">    index += n;</div><div class="line">    html = html.substring(n);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="parseStartTag"><a href="#parseStartTag" class="headerlink" title="parseStartTag"></a>parseStartTag</h4><p>解析开始标签<br>使用unicode为基础的正则startTagOpen匹配html tag<br>unicode会用于比较标签名，组件名以及属性路径<br>var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;<br>var ncname = “[a-zA-Z_][\-\.0-9_a-zA-Z” + (unicodeRegExp.source) + “]*”;<br>var qnameCapture = “((?:” + ncname + “\:)?” + ncname + “)”;<br>var startTagOpen = new RegExp((“^&lt;” + qnameCapture)); 标签开头正则<br>【正则表达式的source属性是其表达式的字符串形式】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function parseStartTag () &#123;</div><div class="line">  var start = html.match(startTagOpen);</div><div class="line">  if (start) &#123;</div><div class="line">    var match = &#123;</div><div class="line">      tagName: start[1],</div><div class="line">      attrs: [],//用来存储将来被匹配到的属性</div><div class="line">      start: index //初始值为 index，是当前字符流读入位置在整个 html 字符串中的相对位置</div><div class="line">    &#125;;</div><div class="line">    advance(start[0].length);</div><div class="line">    var end, attr;</div><div class="line">    //startTagClose = /^\s*(\/?)&gt;/;标签结束正则,只可以匹配&gt;或者/&gt;，或者之前有n个空格</div><div class="line">    //attribute = /^\s*([^\s&quot;&apos;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&apos;([^&apos;]*)&apos;+|([^\s&quot;&apos;=&lt;&gt;`]+)))?/;</div><div class="line">    //dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s&quot;&apos;&lt;&gt;\/=]*)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&apos;([^&apos;]*)&apos;+|([^\s&quot;&apos;=&lt;&gt;`]+)))?/;</div><div class="line">    //dynamicArgAttribute捕获标签上配置的属性push到节点的attr属性里面</div><div class="line">    //得到的结果是[&apos;key=val&apos;,&apos;key&apos;,&apos;=&apos;,&apos;val&apos;,]</div><div class="line">    //while条件是没有匹配到开始标签的结束部分，并且匹配到了开始标签中的属性，这个时候循环体将被执行，直到遇到开始标签的结束部分为止</div><div class="line">    while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123;</div><div class="line">      attr.start = index;</div><div class="line">      advance(attr[0].length);</div><div class="line">      attr.end = index;</div><div class="line">      match.attrs.push(attr);</div><div class="line">    &#125;</div><div class="line">    &lt;!-- 即使匹配到了开始标签的开始部分以及属性部分但是却没有匹配到开始标签的结束部分，这说明这根本就不是一个开始标签。所以只有当变量end存在，即匹配到了开始标签的结束部分时，才能说明这是一个完整的开始标签 --&gt;</div><div class="line">    if (end) &#123;</div><div class="line">      match.unarySlash = end[1];//是否是单标签，双标签该值为空字符串，单标签该值为&apos;/&apos;</div><div class="line">      advance(end[0].length);//位移一个标签结束符&apos;&gt;&apos;或者&apos;/&gt;&apos;加前面n个空格的距离</div><div class="line">      match.end = index;</div><div class="line">      return match//一个html双标签的开头标签或者单标签解析完毕</div><div class="line">    &#125;</div><div class="line">     &lt;!-- 只有当变量end存在时，即能够确定确实解析到了一个开始标签的时候parseStartTag函数才会有返回值，并且返回值是match对象，其他情况下parseStartTag全部返回undefined --&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要作用是<br>1.正则拿到开始标签名<br>2.while循环拿到属性的key-value对象集合，对象中包含该属性在源码中所占的起止位置<br>3.标识是否为一元标签，返回解析结果</p>
<h4 id="handleStartTag"><a href="#handleStartTag" class="headerlink" title="handleStartTag"></a>handleStartTag</h4><p>处理开始标签的解析结果，对上一步结果做进一步处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function handleStartTag (match) &#123;</div><div class="line">  var tagName = match.tagName;</div><div class="line">  var unarySlash = match.unarySlash;</div><div class="line">  //baseOptions中默认设置为true</div><div class="line">  if (expectHTML) &#123;</div></pre></td></tr></table></figure></p>
<p>如果最近一次遇到的开始标签是 p 标签<br>并且当前正在解析的开始标签必须不能是段落式内容(Phrasing content)模型<br>每一个 html 元素都拥有一个或多个内容模型(content model)<br>其中p 标签本身的内容模型是流式内容(Flow content)<br>并且 p 标签的特性是只允许包含段落式内容(Phrasing content)<br>所以条件成立的情况如下：&lt;p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/p&gt;<br>在解析上面这段 html 字符串的时候，首先遇到p标签的开始标签，此时lastTag被设置为 p<br>紧接着会遇到 h1 标签的开始标签，由于 h2 标签的内容模型属于非段落式内容(Phrasing content)模型<br>所以会立即调用 parseEndTag(lastTag) 函数闭合 p 标签，此时由于强行插入了&lt;/p&gt; 标签<br>所以解析后的字符串将变为如下内容：&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/p&gt;<br>继续解析该字符串，会遇到 &lt;h2&gt;&lt;/h2&gt;标签并正常解析之<br>最后解析器会遇到一个单独的p 标签的结束标签，即：&lt;/p&gt;<br>这个时候就回到了我们前面讲过的，当解析器遇到 p 标签或者 br 标签的结束标签时会补全他们<br>最终&lt;p&gt;&lt;h2&gt;&lt;/h2&gt;&lt;/p&gt;<br>这段 html 字符串将被解析为：&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    if (lastTag === &apos;p&apos; &amp;&amp; isNonPhrasingTag(tagName)) &#123;</div><div class="line">      parseEndTag(lastTag);//处理结束标签</div><div class="line">    &#125;</div><div class="line">    //当前正在解析的标签是一个可以省略结束标签的标签，并且与上一次解析到的开始标签相同</div><div class="line">    //例&lt;p&gt;max&lt;p&gt;kaixin</div><div class="line">    //当解析到一个p标签的开始标签并且下一次遇到的标签也是p标签的开始标签时，会立即关闭第二个p标签。</div><div class="line">    //即调用：parseEndTag(tagName) 函数，然后由于第一个p标签缺少闭合标签所以会Vue会给你一个警告。</div><div class="line">    if (canBeLeftOpenTag$$1(tagName) &amp;&amp; lastTag === tagName) &#123;</div><div class="line">      parseEndTag(tagName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  var unary = isUnaryTag$$1(tagName) || !!unarySlash;//是否是一元标签</div><div class="line"></div><div class="line">  var l = match.attrs.length;</div><div class="line">  var attrs = new Array(l);//整理属性</div><div class="line">  for (var i = 0; i &lt; l; i++) &#123; </div><div class="line">    var args = match.attrs[i];</div><div class="line">    var value = args[3] || args[4] || args[5] || &apos;&apos;;</div><div class="line">    //对于a标签是否插入换行编码</div><div class="line">    var shouldDecodeNewlines = tagName === &apos;a&apos; &amp;&amp; args[1] === &apos;href&apos; </div><div class="line">      ? options.shouldDecodeNewlinesForHref</div><div class="line">      : options.shouldDecodeNewlines;</div><div class="line">    attrs[i] = &#123;</div><div class="line">      name: args[1],</div><div class="line">      //decodeAttr 用是对属性值中所包含的 html 实体进行解码，将其转换为实体对应的字符。</div><div class="line">      value: decodeAttr(value, shouldDecodeNewlines)</div><div class="line">    &#125;;</div><div class="line">    if (options.outputSourceRange) &#123;</div><div class="line">      attrs[i].start = args.start + args[0].match(/^\s*/).length;</div><div class="line">      attrs[i].end = args.end;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //如果开始标签是非一元标签，则将该开始标签的信息入栈，</div><div class="line">  //即push到stack数组中，并将lastTag的值设置为该标签名。</div><div class="line">  if (!unary) &#123;//这里的stack是parseHTML中定义的stack</div><div class="line">    stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end &#125;);</div><div class="line">    lastTag = tagName;//lastTag 所存储的标签名字始终保存着 stack 栈顶的元素</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (options.start) &#123; 调用配置的开头标签处理函数，是parse函数中传输parseHTML函数的参数</div><div class="line">    options.start(tagName, attrs, unary, match.start, match.end);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作用如下：<br>1.处理p标签闭合情况，以及a标签属性值是否插入换行的处理<br>2.进一步处理属性值结合，将正则得到的数组转成key-value对象<br>3.将节点push到stack中，进行闭合标签配对，设置lastTag为最近一次的开始标签<br>4.调用开始标签回调start</p>
<h4 id="createASTElement"><a href="#createASTElement" class="headerlink" title="createASTElement"></a>createASTElement</h4><p>创建虚拟节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function createASTElement (</div><div class="line">  tag,</div><div class="line">  attrs,</div><div class="line">  parent</div><div class="line">) &#123;</div><div class="line">  return &#123;</div><div class="line">    type: 1,</div><div class="line">    tag: tag,</div><div class="line">    attrsList: attrs,</div><div class="line">    attrsMap: makeAttrsMap(attrs),</div><div class="line">    rawAttrsMap: &#123;&#125;,</div><div class="line">    parent: parent,</div><div class="line">    children: []</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="parseEndTag"><a href="#parseEndTag" class="headerlink" title="parseEndTag"></a>parseEndTag</h4><p>处理结束标签<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">  function parseEndTag (tagName, start, end) &#123;</div><div class="line">    var pos, lowerCasedTagName;</div><div class="line">    //当 start 和 end 不存在时，将这两个变量的值设置为当前字符流的读入位置，即index</div><div class="line">    //在handleStartTag 函数中调用时会被这样这样调用</div><div class="line">    if (start == null) &#123; start = index; &#125;</div><div class="line">    if (end == null) &#123; end = index; &#125;</div><div class="line">    //找到最近的相同类型的开始标签的位置</div><div class="line">    if (tagName) &#123;</div><div class="line">      lowerCasedTagName = tagName.toLowerCase();</div><div class="line">      for (pos = stack.length - 1; pos &gt;= 0; pos--) &#123;</div><div class="line">        if (stack[pos].lowerCasedTag === lowerCasedTagName) &#123;</div><div class="line">          break</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;//调用 parseEndTag() 函数时不传递任何参数，就处理stack栈中剩余未处理的标签,</div><div class="line">      pos = 0;</div><div class="line">    &#125;</div><div class="line">    //删除最近开始标签 以后的开始标签(可能是一元标签)</div><div class="line">    if (pos &gt;= 0) &#123;//检测是否缺少闭合标签</div><div class="line">      // Close all the open elements, up the stack</div><div class="line">      for (var i = stack.length - 1; i &gt;= pos; i--) &#123;</div><div class="line">        if (i &gt; pos || !tagName &amp;&amp; options.warn) &#123;</div><div class="line">          //如果发现 stack 数组中存在索引大于 pos 的元素，那么一定有元素是缺少闭合标签的</div><div class="line">          options.warn((&quot;tag &lt;&quot; + (stack[i].tag) + &quot;&gt; has no matching end tag.&quot;),&#123; start: stack[i].start, end: stack[i].end &#125;);</div><div class="line">        &#125;</div><div class="line">        if (options.end) &#123;</div><div class="line">          options.end(stack[i].tag, start, end);//回调parse函数调用时传递进来的回调函数</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      //从stack中删除开标签</div><div class="line">      stack.length = pos;</div><div class="line">      lastTag = pos &amp;&amp; stack[pos - 1].tag;//将lastTag重制为stack栈顶元素</div><div class="line">    &#125; else if (lowerCasedTagName === &apos;br&apos;) &#123;</div><div class="line">      //为了与浏览器的行为相同，专门处理br与p的结束标签,即：&lt;/br&gt; 和&lt;/p&gt;。</div><div class="line">      //&lt;/br&gt; 标签被正常解析为 &lt;br&gt; 标签，而&lt;/p&gt;标签被正常解析为 &lt;p&gt;&lt;/p&gt;</div><div class="line">      if (options.start) &#123;</div><div class="line">        options.start(tagName, [], true, start, end);</div><div class="line">      &#125;</div><div class="line">    &#125; else if (lowerCasedTagName === &apos;p&apos;) &#123;</div><div class="line">      if (options.start) &#123;</div><div class="line">        options.start(tagName, [], false, start, end);</div><div class="line">      &#125;</div><div class="line">      if (options.end) &#123;</div><div class="line">        options.end(tagName, start, end);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要作用是<br>1.利用stack进行配对，处理stack和lastTag<br>2.特殊处理br和p标签<br>3.调用end回调函数处理父子关系</p>
<h4 id="isForbiddenTag"><a href="#isForbiddenTag" class="headerlink" title="isForbiddenTag"></a>isForbiddenTag</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function isForbiddenTag(el) &#123;</div><div class="line">	return (</div><div class="line">		el.tag === &apos;style&apos; ||</div><div class="line">		(el.tag === &apos;script&apos; &amp;&amp; (</div><div class="line">			!el.attrsMap.type ||</div><div class="line">			el.attrsMap.type === &apos;text/javascript&apos;</div><div class="line">		))</div><div class="line">	)</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/lifecycle.png&quot; alt=&quot;Vue声明周期&quot;&gt;&lt;br&gt;分析官网的流程图可知&lt;br&gt;new Vue时，进行一系列initxxx初始化工作后会根据选项el和template配置情况去做编译&lt;br&gt;即&lt;br&gt;情况1：挂载了el和tem
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于css的一些事</title>
    <link href="http://yoohannah.github.io/post/knowledge/css.html"/>
    <id>http://yoohannah.github.io/post/knowledge/css.html</id>
    <published>2020-01-27T12:41:15.000Z</published>
    <updated>2020-01-27T13:10:16.995Z</updated>
    
    <content type="html"><![CDATA[<p>1.CSS 选择器的优先级<br>!important<br>内联样式（1000）<br>id选择器（100）<br>类选择器（10）<br>元素选择器（1）</p>
<p>2.为兼容浏览器，对css基本样式做统一处理的三种方法<br>【reset】<br>消除浏览器默认样式，针对具体元素标签重写样式<br>【normalize】<br>样式规范确定的情况下，直接重写全部样式<br>【neat】<br>前两者结合，针对确定的样式直接重写，不确定的进行清除</p>
<p>3.css预处理语法工具需要具备的特性<br>可以变量声明和计算<br>支持语法表达式<br>可以定义函数进行处理<br>属性可以继承<br>可以自行实现autoprefix类似的兼容性补全功能</p>
<p>4.实现动画的6种方式<br>纯JS(利用setInternal,16ms)<br>svg(利用标签配置)<br>canvas（利用jsAPI配置）<br>css3-transition(过渡动画，不能独立实现动画)<br>css3-animation(纯css实现动画)<br>requestAnimationFrame(类似setInterval,但性能消耗低)<br>前两种兼容性良好，后四种适用于移动端</p>
<p>5.屏幕适配布局方案<br>想办法让比例不变<br>A.在html/body标签上加上zoom属性，缺点是不灵活<br>B.使用rem，相对于文档根元素font-size,<br>  利用mediaQuery对常见几种屏幕宽度设置html的font-size<br>  以font-size大小为1rem</p>
<p>6.响应式设计的两种方案<br>前端或者后端判断useragent来跳转不同站点得到不同页面<br>使用mediaQuery媒体查询让页面根据不同设备自动改变页面布局和显示</p>
<p>7.根据浏览器屏幕宽度和分辨率加载不同大小的图片<br>使用mediaQuery判断加载不同的背景图<br>使用H5的picture标签<br>模板进行判断然后渲染不同图片<br>请求图片时带上相关参数，让图片服务器吐出不同大小图片</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.CSS 选择器的优先级&lt;br&gt;!important&lt;br&gt;内联样式（1000）&lt;br&gt;id选择器（100）&lt;br&gt;类选择器（10）&lt;br&gt;元素选择器（1）&lt;/p&gt;
&lt;p&gt;2.为兼容浏览器，对css基本样式做统一处理的三种方法&lt;br&gt;【reset】&lt;br&gt;消除浏览器默认样
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Shadow DOM</title>
    <link href="http://yoohannah.github.io/post/knowledge/shadowDom.html"/>
    <id>http://yoohannah.github.io/post/knowledge/shadowDom.html</id>
    <published>2020-01-27T12:18:15.000Z</published>
    <updated>2020-01-27T12:33:42.519Z</updated>
    
    <content type="html"><![CDATA[<p>Shadow DOM是HTML的一个规范，它允许浏览器开发者封装自己的HTML标签，css样式和特定js代码<br>同时也可以让开发者常见类似video这样的自定义一级标签，<br>创建的这些新标签和相关的api被称为 WEB Component</p>
<p>Shadow host 是shadow dom 的容器元素，就是最终使用的标签元素<br>Shadow root 是shadow dom 具体内容的根节点，可以使用document.createShadowRoot()创建<br>shadow tree 是shadow dom 包含的子节点数</p>
<p>在shadow root 上可以任意通过DOM操作添加任意shadow tree，同时指定样式和处理逻辑<br>并将自己的API暴露出来<br>完成创建后需要通过document.registerElement()在文档中注册元素<br>shadow dom 创建就完成了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shadow DOM是HTML的一个规范，它允许浏览器开发者封装自己的HTML标签，css样式和特定js代码&lt;br&gt;同时也可以让开发者常见类似video这样的自定义一级标签，&lt;br&gt;创建的这些新标签和相关的api被称为 WEB Component&lt;/p&gt;
&lt;p&gt;Shadow
    
    </summary>
    
    
      <category term="html" scheme="http://yoohannah.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>vuepress相关</title>
    <link href="http://yoohannah.github.io/post/vue/vuepress.html"/>
    <id>http://yoohannah.github.io/post/vue/vuepress.html</id>
    <published>2020-01-27T05:18:15.000Z</published>
    <updated>2020-01-27T05:20:42.064Z</updated>
    
    <content type="html"><![CDATA[<p>1.使用现有主题<br>在.vuepress/config中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  theme:&apos;&apos;//主题名</div><div class="line">  themeConfig:&#123; //主题需要的相应配置</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.自定义主题styl<br>在跟目录下新建theme文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">theme</div><div class="line">|——global-components //该目录下组件会被自动注册成全局组件</div><div class="line">|</div><div class="line">|——components //VUE组件</div><div class="line">|</div><div class="line">|——layouts</div><div class="line">|  |—— layout.vue(Mandatory) //所有页面默认使用的布局组建</div><div class="line">|  |—— 404.vue //路由匹配不到的页面默认页面</div><div class="line">|</div><div class="line">|——styles //定义全局样式和调色板</div><div class="line">|  |——index.</div><div class="line">|  |——palette.styl</div><div class="line">|</div><div class="line">|__index.js //主题文件的入口文件</div></pre></td></tr></table></figure></p>
<p>3.插件<br>@vuepress/plugin-pwa 自动生成service-work，产生缓存，可供离线使用，从而让网站更块<br>@vuepress/plugin-search 基于h1,h2等标签，去vuepress源数据中查找，将得到结果重新渲染，让搜索更简单<br>@vuepress/plugin-blog 让博客主题更简单<br>@vuepress-plugin-yuque 创造纯动态数据源的可能性，将文档编写，部署，发布全部在vuepress中实现<br>4.自定义首页<br>在doc文件夹下将README.md修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">layout:layout //项目会自动到.vuepress文件夹下的component文件夹下去寻找layout组件</div><div class="line">---</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.使用现有主题&lt;br&gt;在.vuepress/config中设置&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div clas
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vuerouter源码初步学习</title>
    <link href="http://yoohannah.github.io/post/vue/vue-router.html"/>
    <id>http://yoohannah.github.io/post/vue/vue-router.html</id>
    <published>2020-01-27T04:34:15.000Z</published>
    <updated>2020-01-27T04:37:09.151Z</updated>
    
    <content type="html"><![CDATA[<p>工作流程：<br> URL改变-&gt;出发监听事件-&gt;改变vue-router里的current变量-&gt;<br> 触发current变量的监听者-&gt;获取新组件-&gt;render新组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">class HistoryRoute&#123;</div><div class="line">  constructor()&#123;</div><div class="line">    this.current=null</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">class vueRouter&#123;</div><div class="line">  constructor(options)&#123;</div><div class="line">    this.history= new HistoryRoute;</div><div class="line">    this.mode = options.mode || &apos;hash&apos;</div><div class="line">    this.routes = options.routes || []</div><div class="line">    this.routesMap = this.createMap(this.routes)</div><div class="line">    this.init()</div><div class="line">  &#125;</div><div class="line">  Init()&#123;</div><div class="line">    if(this.mode==&apos;hash&apos;)&#123;</div><div class="line">      //如果没有#号，自动加上#</div><div class="line">      location.hash?&quot;&quot;:location.hash=&apos;/&apos;</div><div class="line">      //监听hash改变</div><div class="line">      window.addEventListener(&apos;load&apos;,()=&gt;&#123;</div><div class="line">        //slice去掉#号</div><div class="line">        this.history.current=location.hash.slice(1)</div><div class="line">      &#125;)</div><div class="line">      window.addEventListener(&apos;hashchange&apos;,()=&gt;&#123;</div><div class="line">        this.history.current=location.hash.slice(1)</div><div class="line">      &#125;)</div><div class="line">    &#125;else&#123;</div><div class="line">      location.pathname?&quot;&quot;:location.pathname=&apos;/&apos;</div><div class="line">      window.addEventListener(&apos;load&apos;,()=&gt;&#123;</div><div class="line">        this.history.current=location.pathname</div><div class="line">      &#125;)</div><div class="line">      window.addEventListener(&apos;hashchange&apos;,()=&gt;&#123;</div><div class="line">        this.history.current=location.pathname</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //将路由对象[&#123;path:&apos;xxx&apos;,component:a&#125;]转成：&#123;xxx:a&#125;</div><div class="line">  createMap(routes)&#123;</div><div class="line">    return routes.reduce((memo,current)=&gt;&#123;</div><div class="line">      memo[current.path] = current.components</div><div class="line">      return memo</div><div class="line">    &#125;)</div><div class="line">  &#125;  </div><div class="line">&#125;</div><div class="line">//定义属性标签 get set ===&gt;供VUE.use使用</div><div class="line">//VUE.use(xxxx) xxx是一个函数时直接运行xxx函数，xxx是一个对象或者类时，运行其上面的install方法</div><div class="line">vueRouter.install = function(Vue)&#123;</div><div class="line">  Vue.mixin(&#123;</div><div class="line">    beforeCreate()&#123;</div><div class="line">      //this指向当前组件实例，this.$options指向创建VUE实例时传入的配置项</div><div class="line">      if(this.$options&amp;&amp;this.$option.router)&#123;</div><div class="line">        //把当前实例挂在_root上</div><div class="line">        this._root = this</div><div class="line">        this._router = this.$options.router</div><div class="line">        Vue.util.defineReactive(this,&apos;current&apos;,this._router.history) //双向绑定，对路由变化进行监听，</div><div class="line">      &#125;</div><div class="line">      Object.defineProperty(this,&quot;$router&quot;,&#123; //能够获取$router但不能修改的原理。防止用户修改_router</div><div class="line">        get()&#123;</div><div class="line">          return this._root._router;</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  Vue.components(&apos;router-view&apos;,&#123;</div><div class="line">    render(r)&#123;</div><div class="line">      //拿到当前路径</div><div class="line">      //this指向proxy,当前组件代理对象；this._self当前组件实例化对象；this._self._root当前组件对象</div><div class="line">      let current = this._self._root._router.history.current</div><div class="line">      let routeMap = this._self._root._router.routeMap</div><div class="line">      return r(routeMap[current])</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line">module.exports = vueRouter</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作流程：&lt;br&gt; URL改变-&amp;gt;出发监听事件-&amp;gt;改变vue-router里的current变量-&amp;gt;&lt;br&gt; 触发current变量的监听者-&amp;gt;获取新组件-&amp;gt;render新组件&lt;br&gt;&lt;figure class=&quot;highlight plain
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于模块化</title>
    <link href="http://yoohannah.github.io/post/js/module.html"/>
    <id>http://yoohannah.github.io/post/js/module.html</id>
    <published>2020-01-27T03:08:15.000Z</published>
    <updated>2020-01-27T04:41:18.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h1><p>  模块化就是把系统分离成独立功能的方法，从而实现需要什么功能，就加载什么功能<br>  当一个项目开发得越来越复杂时，会出现问题：命名冲突；文件依赖<br>  使用模块化开发，可以避免以上问题，并且提高开发效率：可维护性；可复用性</p>
<p>  模块化开发演变<br>  1.使用全局函数      ===&gt;早期开发就是将重复得代码封装到函数中，再将一系列的函数放到一个文件中<br>    存在的问题就是：污染全局变量；看不出相互的直接关系<br>  2.使用对象命名空间  ===&gt;通过对象命名空间的形式，从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突<br>    存在的问题是：内部状态可被外部改写；命名空间越来越来长<br>  3.私有共有成员分离  ===&gt;利用此种方式将函数包装成一个独立的作用域，私有空间的变量和函数不会影响全局作用域<br>    存在问题：解决了变量命名冲突问题，但是没有解决降低开发复杂度的问题</p>
<h1 id="Commonjs"><a href="#Commonjs" class="headerlink" title="Commonjs"></a>Commonjs</h1><p>  commomJS规范加载模块是【同步】的，也就是说，加载完成才执行后面的操作<br>  Node.js主要用于服务器编程，模块都是存在本地硬盘中加载比较快，所以Node.js采用CommonJS<br>  三个部分：<br>  module变量在每个模块内部，就代表当前模块<br>  exports属性是对外的接口，用于导出当前模块的方法或变量<br>  require()用来加载外部模块，读取并执行js文件，返回该模块的exports对象<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">加载时执行：</div><div class="line">a.js</div><div class="line">exports.done = ture</div><div class="line">var b = require(&apos;b.js&apos;)</div><div class="line">console.log(&apos;a.js-done&apos;)</div><div class="line"></div><div class="line">b.js</div><div class="line">exports.done = false</div><div class="line">var a = require(&apos;a.js&apos;)</div><div class="line">console.log(a.done)</div><div class="line">console.log(&apos;b.js-done&apos;)</div><div class="line"></div><div class="line">App.js   执行App.js</div><div class="line">var a = require(&apos;a.js&apos;) // 因为引用b.js，执行b.js代码故打印出true b.js-done，引用完毕后接着执行打印出 a.js-done</div><div class="line">var b = require(&apos;b.js&apos;)// 已经被a引用过，不再执行 直接在缓存中找出 exports &#123;done：false&#125; 返回</div><div class="line">console.log(a.done)</div><div class="line">console.log(b.done) </div><div class="line"></div><div class="line">如果a.js改成如下</div><div class="line">var b = require(&apos;b.js&apos;)</div><div class="line">exports.done = ture</div><div class="line">console.log(&apos;a.js-done&apos;)</div><div class="line">执行App.js</div><div class="line">打印结果为undefined b.js-done a.js-done true false </div><div class="line">因为a依赖b时，执行b，b再依赖a时，exports.done = ture语句还未执行，故a 的 exports 为&#123;&#125; exports.done自然为undefined</div></pre></td></tr></table></figure></p>
<p>  只有commonjs因为同步加载，加载时执行可实现循环依赖，其他模式均不可以处理循环依赖的用法</p>
<h1 id="AMD-requirejs"><a href="#AMD-requirejs" class="headerlink" title="AMD(requirejs)"></a>AMD(requirejs)</h1><p>  AMD也就是【异步】模块定义，它采用异步方式加载模块，通过define方法去定义模块，require方法去加载模块<br>  定义：<br>  define([tools],function(){return {}}) //第一个参数为数组时，说明该模块还依赖其他模块,提前声明依赖，没有依赖时，只传入function即可<br>  加载：<br>  require([‘module’],callback) //第一个参数数组内成员即要加载的模块，callback是前面所有某块都加载成功之后的回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/** a.js */</div><div class="line"></div><div class="line">define([&apos;b&apos;], function(b) &#123;</div><div class="line">  console.log(b)</div><div class="line">  var hello = function()&#123;</div><div class="line">    console.log(&apos;hello work&apos;)</div><div class="line">  &#125;</div><div class="line">  return &#123;</div><div class="line">    Hello:Hello</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/** b.js */</div><div class="line"></div><div class="line">define(function()&#123;</div><div class="line">  var name = &apos;max&apos;</div><div class="line">  return&#123;</div><div class="line">    name:name</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">/** 使用a.js,b.js */</div><div class="line"></div><div class="line">/*</div><div class="line"> &lt;script type=&apos;text/javascript&apos; src=&apos;require.js&apos;&gt;&lt;/script&gt;</div><div class="line"> &lt;script type=&apos;text/javascript&apos;&gt;</div><div class="line">  require.config(&#123;</div><div class="line">    paths:&#123;</div><div class="line">      &apos;a&apos;:&apos;./a&apos;,</div><div class="line">      &apos;b&apos;:&apos;./b&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  require([&apos;a&apos;,&apos;b&apos;],function(a,b)&#123; //启用模块加载器</div><div class="line">    console.log(a)</div><div class="line">    console.log(b)</div><div class="line">  &#125;)</div><div class="line"> &lt;/script&gt;</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<h1 id="CMD-seajs"><a href="#CMD-seajs" class="headerlink" title="CMD(seajs)"></a>CMD(seajs)</h1><p>  与AMD一样，只是定义和模块加载方式上不同<br>  一个模块一个文件<br>  define(function(require,exports,module){<br>   //require 是可以把其他模块导入进来的一个参数<br>   //exports可以把模块内的一些属性和方法导出<br>   //module是一个对象，上面存储了与当前模块相关联的一些属性和方法<br>  })<br>  CMD推崇依赖就近，延迟执行，文件是提前加载好的，只有在require的时候才去执行文件<br>  define(function(require,exports,module){<br>     var math = require(‘./math’)<br>     math.add()<br>  })<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/** a.js */</div><div class="line"></div><div class="line">define(function(require,exports,module) &#123;</div><div class="line">  var b = require(&apos;b&apos;)</div><div class="line">  console.log(b)</div><div class="line">  exports.hello = function()&#123;</div><div class="line">    console.log(&apos;hello work&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"> &lt;script type=&apos;text/javascript&apos; src=&apos;sea.js&apos;&gt;&lt;/script&gt;</div><div class="line"> &lt;script type=&apos;text/javascript&apos;&gt;</div><div class="line">  seajs.config(&#123;</div><div class="line">    alias:&#123;</div><div class="line">      &apos;a&apos;:&apos;./a&apos;,</div><div class="line">      &apos;b&apos;:&apos;./b&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  seajs.use([&apos;a&apos;,&apos;b&apos;],function(a,b)&#123; //启用模块加载器</div><div class="line">    console.log(a)</div><div class="line">    console.log(b)</div><div class="line">  &#125;)</div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h1 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h1><p>  汲取CommonJS和AMD优点，支持异步加载，未来可以成为浏览器和服务器通用的模块化解决方案<br>  export:用于把模块里的内容暴露出来， export default 为模块指定默认输出，一个模块只能有一个默认输出，所以export default 只能使用一次<br>  import： 用于引入模块提供的功能===&gt; import {x1,x2} form ‘./lib’; x1()</p>
<p>  ES6模块运行机制：<br>  ES6模块是动态引用，如果使用import从一个模块加载变量，变量不会被缓存，<br>  而是成为一个指向被加载模块的引用。等脚本执行时，根据只读引用到被加载的那个模块中去取值</p>
<p>  ES6与CommonJS模块差异<br>  CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值得引用<br>  CommonJS模块运行时加载，ES6模块编译时输出接口</p>
<h1 id="加载器结构"><a href="#加载器结构" class="headerlink" title="加载器结构"></a>加载器结构</h1><h2 id="模块部分"><a href="#模块部分" class="headerlink" title="模块部分"></a>模块部分</h2><p>   每个模块创建都先初始化数据，存储在缓存对象中<br>   <img src="/image/module1.png" alt="module1"></p>
<h3 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h3><p>  <img src="/image/module2.png" alt="module2"><br>  加载器中设计了一个名为Module的构造函数，【每个模块都是此构造函数的实例对象】<br>  构造函数中给实例对象扩展了’未来’所需要用到的属性（uri:当前模块绝对路径地址，deps:模块的依赖列表….)及方法(load,resolve:获取当前模块绝对路径…)</p>
<h3 id="模块存储"><a href="#模块存储" class="headerlink" title="模块存储"></a>模块存储</h3><p>  加载器中设计了一个名为cache的缓存对象，每个文件(模块)都会存储在cache对象中<br>  具体存储方式:{‘当前模块绝对路径’: new Module()} 注意：当前模块的绝对路径是通过资源部分，资源定位方法实现的</p>
<h2 id="资源部分"><a href="#资源部分" class="headerlink" title="资源部分"></a>资源部分</h2><p>   资源定位和依赖管理是加载器涉及的两大核心</p>
<h3 id="资源定位"><a href="#资源定位" class="headerlink" title="资源定位"></a>资源定位</h3><p>  <img src="/image/module3.png" alt="module3"><br>  加载器中设计了一个resolve()方法把模块名解析成绝对路径格式<br>  检测当前模块名称是否有路径短名称配置，是否有模块短名称配置，是否有后缀<br>  在加载器启动方法中会去调用传入数组列表中的模块，获取模块名称<br>  然后根据当前项目绝对路径和模块名称进行拼接</p>
<h4 id="动态加载script文件"><a href="#动态加载script文件" class="headerlink" title="动态加载script文件"></a>动态加载script文件</h4><p>  动态创建script标签： document.create(‘script’)； src指向当前模块绝对路径地址<br>  加载文件同时，模块加载器解析当前模块所依赖的模块，以数组形式存储，更新到deps属性中</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>  已知当前模块在cache中的形态，{‘当前模块绝对路径’: new Module()}<br>  换算成：{‘当前模块绝对路径’: {uri:’当前模块绝对路径’,deps:[]}}<br>  <img src="/image/module4.png" alt="module4"><br>    deps存储当前模块的依赖列表，依赖列表通过动态加载script文件正则解析获取<br>    重点：解析依赖—&gt;获取依赖模块绝对路径地址—-&gt;动态加载—-&gt;提取依赖—-&gt;解析依赖<br>        递归方式加载所有模块，直至模块全部加载完毕（模块的deps属性集合中没有依赖的绝对路径，即长度为0）</p>
<h2 id="如何实现一个文件一个作用域？"><a href="#如何实现一个文件一个作用域？" class="headerlink" title="如何实现一个文件一个作用域？"></a>如何实现一个文件一个作用域？</h2><p>  保证模块拥有独立作用域，采用对象命名空间的思想，即每个模块返回一个接口对象，这个独立作用域就是一个对象</p>
<h2 id="如何拿到依赖模块的接口对象？"><a href="#如何拿到依赖模块的接口对象？" class="headerlink" title="如何拿到依赖模块的接口对象？"></a>如何拿到依赖模块的接口对象？</h2><p>  参数即define传入的函数，执行函数，返回函数返回的结果即对象</p>
<h2 id="如何让寻找依赖？"><a href="#如何让寻找依赖？" class="headerlink" title="如何让寻找依赖？"></a>如何让寻找依赖？</h2><p>  拼接地址，缓存，然后递归<br>  图片：依赖加载策略 模块数据初始化 资源定位-动态加载 依赖管理解决方案</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div></pre></td><td class="code"><pre><div class="line">(function(global) &#123;</div><div class="line">  var startUp = global.startUp = &#123;</div><div class="line">    version:&apos;1.0.1&apos;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">  var data = &#123;&#125; //配置信息</div><div class="line">  var cache = &#123;&#125;</div><div class="line">  var anonymousMeta = &#123;&#125;</div><div class="line">  //模块生命周期</div><div class="line"></div><div class="line">  var status = &#123;</div><div class="line">    FETCHED: 1,</div><div class="line">    SAVED:2,</div><div class="line">    LOADING:3,</div><div class="line">    LOADED:4,</div><div class="line">    EXECTING:5,</div><div class="line">    EXECTED:6</div><div class="line">  &#125;</div><div class="line">  var isArray = function (obj) &#123;</div><div class="line">    return toString.call(obj) === &quot;[object Array]&quot;</div><div class="line">  &#125;</div><div class="line">  var isFunction = function (obj) &#123;</div><div class="line">    return toString.call(obj) === &quot;[object Function]&quot;</div><div class="line">  &#125;</div><div class="line">  var isString = function (obj) &#123;</div><div class="line">    return toString.call(obj) === &quot;[object String]&quot;</div><div class="line">  &#125;</div><div class="line">  function scripts()&#123;</div><div class="line">    return document.getElementsByTagName(&apos;script&apos;)</div><div class="line">  &#125;</div><div class="line">  function getInteractiveScript()&#123; //支持data-main属性添加默认路径: &lt;script data-main = &apos;common/js&apos; src=&apos;module.js&apos;&gt;&lt;/script&gt;</div><div class="line">    var arrS = scripts()</div><div class="line">    var dataMain,src</div><div class="line">    var exp = /^.*\.js$/</div><div class="line">    arrS = [].slice.call(arrS)</div><div class="line">    arrS.forEach(function(script)&#123;</div><div class="line">      dataMain = script.getAttribute(&apos;data-main&apos;)</div><div class="line">      if(dataMain &amp;&amp; !data.baseUrl &amp;&amp; !(exp.test(dataMain)))&#123;</div><div class="line">        if(dataMain.substring(dataMain.length-1) !== &apos;/&apos;)&#123;</div><div class="line">          dataMain = (dataMain+&apos;/&apos;)</div><div class="line">        &#125;</div><div class="line">        data.baseUrl = dataMain</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  getInteractiveScript()</div><div class="line">  //是否使用了别名</div><div class="line">  function parseAlias(id)&#123;</div><div class="line">    var alias = data.alias //是否配置别名</div><div class="line">    return alias &amp;&amp; isString(alias[id]) ? alias[id] :id //没有配置别名，返回原来值，有配置别名，返回别名对应值</div><div class="line">  &#125;</div><div class="line">  //不能以&apos;/&apos;&apos;:&apos;开头，必须是一个&apos;/&apos;后面跟随任意字符至少一个</div><div class="line">  var PATH_RE = /^([^\/:]+)(\/.+)$/ //([^\/:]+) 路径的短名称配置</div><div class="line"></div><div class="line">  //检测是否 书写路径短名称</div><div class="line">  function parsePaths(id) &#123;</div><div class="line">    var paths = data.paths; //是否配置短路径</div><div class="line">    if(paths &amp;&amp; (m=id.match(PATH_RE)) &amp;&amp; isString(paths[m[1]]))&#123;</div><div class="line">      id = paths[m[1]]+m[2]</div><div class="line">    &#125;</div><div class="line">    return id</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //检测是否添加后缀</div><div class="line">  function normalize(path)&#123;</div><div class="line">    var last = path.length-1</div><div class="line">    var lastC = path.charAt(last)</div><div class="line">    return (lastC === &apos;/&apos; || path.substring(last-2) === &apos;.js&apos;) ? path :path+&apos;.js&apos;</div><div class="line">  &#125;</div><div class="line">  //添加根目录</div><div class="line">  function addBase(id,uri)&#123;</div><div class="line">    // var result;</div><div class="line">    // //相对路径</div><div class="line">    // if(id.charAt(0) === &apos;.&apos;)&#123;</div><div class="line">    //   result = realpath( (uri ? uri.match(/[^?]*\//)[0] : data.cwd ) + id)</div><div class="line">    // &#125;else&#123;</div><div class="line">    //   result = data.cwd+id</div><div class="line">    // &#125;</div><div class="line">    var result = data.baseUrl ?data.cwd + data.baseUrl +id : data.cwd + id //支持data-main属性添加默认路径</div><div class="line">    return result</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var DOT_RE = /\/.\//g //   /a/b/./c/./d ==&gt;/a/b/c/d     /./ ==&gt;/</div><div class="line">  var DOUBLE_DOT_RE = /\/[^/]+\/\.\.\//; // a/b/c/../../d ===&gt;a/b/../d ==&gt; a/d    /xxxxx/../==&gt; /</div><div class="line">  //规范路径</div><div class="line">  function realpath(path)&#123;</div><div class="line">    path = path.replace(DOT_RE,&apos;/&apos;)</div><div class="line">    while(path.match(DOUBLE_DOT_RE))&#123;</div><div class="line">      path= path.replace(DOUBLE_DOT_RE,&apos;/&apos;)</div><div class="line">    &#125;</div><div class="line">    return path</div><div class="line">  &#125;</div><div class="line">  //生成绝对路径 资源路径解析</div><div class="line">  startUp.resolve = function (child,parent) &#123;</div><div class="line">    if(!child) return &apos;&apos;</div><div class="line">    child = parseAlias(child) //检测是否有别名</div><div class="line">    child = parsePaths(child) //检测是否有路径别名，依赖模块中引包的模块路径地址 require(&apos;app/c)</div><div class="line">    child = normalize(child) //检测是否添加后缀</div><div class="line">    return addBase(child,parent) //添加根目录</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  startUp.request = function(url,callback)&#123;</div><div class="line">    var node = document.createElement(&apos;script&apos;)</div><div class="line">    node.src = url</div><div class="line">    document.body.appendChild(node)</div><div class="line">    node.onload = function()&#123;</div><div class="line">      node.onload = null</div><div class="line">      document.body.removeChild(node) //加载依赖结束后移除加载时的script标签</div><div class="line">      callback()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  //模块加载器启用</div><div class="line">  startUp.use = function(list,callback)&#123;</div><div class="line">    //检阅有没有预先加载的模块</div><div class="line">    Module.preload(function()&#123;</div><div class="line">      Module.use(list,callback,data.cwd+&quot;_use_&quot;+cid()) //虚拟的根目录</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  //模块加载器配置</div><div class="line">  /**</div><div class="line">   * </div><div class="line">   * startUp.config(&#123;</div><div class="line">   *   alias:&#123;</div><div class="line">   *    a:&apos;common/js/a&apos;</div><div class="line">   *   &#125;,</div><div class="line">   *   preload:[c.js]</div><div class="line">   * &#125;)</div><div class="line">   */</div><div class="line">  startUp.config = function (options) &#123;</div><div class="line">    var key,curr</div><div class="line">    for(key in options)&#123;</div><div class="line">      curr = Option[key]</div><div class="line">      data[key] = curr</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //构造函数 模块初始化数据</div><div class="line">  function Module(uri,deps)&#123;</div><div class="line">    this.uri = uri;</div><div class="line">    this.deps = deps || [] //依赖项</div><div class="line">    this.exports = null</div><div class="line">    this.status = 0</div><div class="line">    this._waitings = &#123;&#125;</div><div class="line">    this._remain = 0</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //分析主干(左子树 | 右子树)上的依赖项</div><div class="line">  Module.prototype.load = function()&#123;</div><div class="line">    var m = this</div><div class="line">    m.status = status.LOADING//LOADING == 3 正在加载模块依赖项</div><div class="line">    var uris = m.resolve()//获取主干上的依赖项</div><div class="line">    var len = m.remain = uris.length</div><div class="line"></div><div class="line">    //加载主干上的依赖项(模块)</div><div class="line">    var seed</div><div class="line">    for(var i=0;i&lt;len;i++)&#123;</div><div class="line">      seed = Module.get(uris[i]) //创建缓存信息</div><div class="line">      if(seed.status &lt;status.LOADED)&#123; //LOADED == 4 准备加载执行当前模块</div><div class="line">        seed._waitings[m.uri] = seed._waitings[m.uri] || 1 //多少模块依赖于我，_waitings是依赖我的模块的路径集合</div><div class="line">      &#125;else&#123;</div><div class="line">        seed._remain--</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //如果依赖列表模块全部加载完毕</div><div class="line">    if(m._remain == 0)&#123; //递归过程到此结束</div><div class="line">      //获取模块的接口对象</div><div class="line">      m.onload()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //准备执行根目录下的依赖列表中的模块</div><div class="line">    var requestCache = &#123;&#125;</div><div class="line">    for(var i=0;i&lt;len;i++)&#123;</div><div class="line">      seed = Module.get(uris[i])</div><div class="line">      if(seed.status &lt; status.FETCHED)&#123;</div><div class="line">        seed.fetch(requestCache)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    for(uri in requestCache)&#123;</div><div class="line">      requestCache[uri]()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Module.prototype.fetch = function(requestCache)&#123;</div><div class="line">    var m =this</div><div class="line">    m.status = status.FETCHED</div><div class="line">    var uri = m.uri</div><div class="line">    requestCache[uri] = sendRequest; //Document.createElement(&apos;script)</div><div class="line">    </div><div class="line">    function sendRequest()&#123;</div><div class="line">      startUp.request(uri,onRequest) //动态加载script</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function onRequest()&#123; //事件函数 script标签加载模块结束后，onload 函数中会被调用</div><div class="line">      if(anonymousMeta)&#123; //模块的数据更新</div><div class="line">        m.save(uri,anonymousMeta)</div><div class="line">      &#125;</div><div class="line">      m.load() //递归 模块加载策略</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Module.prototype.onload = function()&#123;</div><div class="line">    var mod = this</div><div class="line">    mod.status = LOADED //4</div><div class="line">    if(mod.callback)&#123;//获取模块接口对象</div><div class="line">      mod.callback()</div><div class="line">    &#125;</div><div class="line">    var waitings = mod._waitings //依赖加载完，递归回调 被依赖模块(父)的callback</div><div class="line">    var key,m;</div><div class="line">    for(key in waitings)&#123;</div><div class="line">      var m = cache[key]</div><div class="line">      m._remain -= waitings[key]</div><div class="line">      if(m._remain == 0)&#123; //判断父模块依赖是否全部加载完</div><div class="line">        m.onload()</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  //资源定位 解析依赖项生成绝对路径</div><div class="line">  Module.prototype.resolve = function()&#123;</div><div class="line">    var mod = this</div><div class="line">    var ids = mod.deps</div><div class="line">    var uris = []</div><div class="line">    for(var i =0;i&lt;ids.length;i++)&#123;</div><div class="line">      uris[i] = startUp.resolve(ids[i],mod.uri) //依赖项（主干 | 子树）</div><div class="line">    &#125;</div><div class="line">    return uris;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">   //更改初始化数据</div><div class="line">  Module.prototype.save = function(uri,meta)&#123;</div><div class="line">    var mod = Module.get(uri)</div><div class="line">    mod.uri = uri</div><div class="line">    mod.deps = meta.deps || []</div><div class="line">    mod.factory = meta.factory</div><div class="line">    mod.status = status.SAVED</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //获取接口对象</div><div class="line">  Module.prototype.exec = function()&#123;</div><div class="line">    var module = this</div><div class="line">    //防止重复执行</div><div class="line">    if(module.status &gt;= status.EXECTING)&#123;</div><div class="line">      return module.exports</div><div class="line">    &#125;</div><div class="line">    module.status = status.EXECTING;</div><div class="line">    var uri = module.uri</div><div class="line">    function require(id)&#123; //作为参数传递到define参数的函数中</div><div class="line">      return Module.get(require.resolve(id)).exec() //获取接口对象</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    require.resolve = function(id)&#123;</div><div class="line">      return startUp.resolve(id,uri)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var factory = module.factory //define传入的函数</div><div class="line">    var exports = isFunction(factory) ? factory(require,module.exports= &#123;&#125;,module) :factory;</div><div class="line">    if(exports === undefined) &#123;</div><div class="line">      exports = module.exports</div><div class="line">    &#125;</div><div class="line">    module.exports = exports</div><div class="line">    module.status = status.EXECTED //6</div><div class="line">    return exports</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //定义一个模块</div><div class="line">  Module.define = function(factory)&#123;</div><div class="line">    var deps</div><div class="line">    if(isFunction(factory))&#123;</div><div class="line">      //正则解析依赖项</div><div class="line">      deps = parseDependencies(factory.toString())</div><div class="line">    &#125;</div><div class="line">    //存储当前模块信息</div><div class="line">    var meta = &#123;</div><div class="line">      id:&apos;&apos;,</div><div class="line">      uri:&apos;&apos;,</div><div class="line">      deps:deps,</div><div class="line">      factory:factory</div><div class="line">    &#125;</div><div class="line">    anonymousMeta = meta</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //检测缓存对象上是否有当前模块信息</div><div class="line">  Module.get = function(uri,deps)&#123;</div><div class="line">    //cache[&apos;xxxxx.js&apos;] = &#123;uri:&apos;xxxxx.js&apos;,deps:[]&#125; //module 实例对象</div><div class="line">    return cache[uri] || (cache[uri] = new Module(uri,deps))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Module.use = function(deps,callback,uri)&#123;</div><div class="line">    var m = Module.get(uri,isArray(deps)?dep:[deps])</div><div class="line">    console.log(module)</div><div class="line">    //所有模块都加载完毕</div><div class="line">    m.callback= function()&#123;</div><div class="line">      var exports = [] //所有依赖项模块的接口对象</div><div class="line">      var uris = m.resolve()</div><div class="line">      for(var i = 0;i&lt;uris.length;i++)&#123;</div><div class="line">        exports[i] = cache[uris[i]].exec() //获取模块对外定义的接口对象</div><div class="line">      &#125;</div><div class="line">      if(callback)&#123;</div><div class="line">        callback.apply(global,exports)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    m.load()</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var _cid = 0</div><div class="line"></div><div class="line">  function cid()&#123;</div><div class="line">    return _cid++</div><div class="line">  &#125;</div><div class="line">  // data.preload = []</div><div class="line">  //取消当前项目文档的URL</div><div class="line">  data.cwd = document.URL.match(/[^?]*\//)[0]</div><div class="line">  Module.preload = function(callback)&#123;</div><div class="line">    var preload = data.preload ||[]</div><div class="line">    var length = data.preload.length</div><div class="line">    if(length)&#123; //length !== 0 先加载预先设定模块</div><div class="line">      Module.use(preload,function () &#123;</div><div class="line">        preload.splice(0,length)</div><div class="line">        callback()</div><div class="line">      &#125;,data.cwd+&apos;_use_&apos;+cid())</div><div class="line">    &#125; else&#123;</div><div class="line">      callback() </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  var REQUIRE_RE = /\brequire\s*\(\s*([&quot;&apos;])(.+?)\1\s*\)/g</div><div class="line">  function parseDependencies(code)&#123;</div><div class="line">    var ret = []</div><div class="line">    code.replace(REQUIRE_RE,function(m,m1,m2)&#123;</div><div class="line">      if(m2) ret.push(m2)</div><div class="line">    &#125;)</div><div class="line">    return ret</div><div class="line">  &#125;</div><div class="line">  global.define = module.define</div><div class="line">&#125;)(this)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是模块化&quot;&gt;&lt;a href=&quot;#什么是模块化&quot; class=&quot;headerlink&quot; title=&quot;什么是模块化&quot;&gt;&lt;/a&gt;什么是模块化&lt;/h1&gt;&lt;p&gt;  模块化就是把系统分离成独立功能的方法，从而实现需要什么功能，就加载什么功能&lt;br&gt;  当一个项目开发得越
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue 源码学习四</title>
    <link href="http://yoohannah.github.io/post/vue/src4.html"/>
    <id>http://yoohannah.github.io/post/vue/src4.html</id>
    <published>2020-01-27T02:48:15.000Z</published>
    <updated>2020-02-29T04:37:56.296Z</updated>
    
    <content type="html"><![CDATA[<p>vue双向绑定原理，依赖收集是<br>在created声明周期之前，<br>render生成虚拟dom的时候</p>
<h1 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue双向绑定原理，依赖收集是&lt;br&gt;在created声明周期之前，&lt;br&gt;render生成虚拟dom的时候&lt;/p&gt;
&lt;h1 id=&quot;数据劫持&quot;&gt;&lt;a href=&quot;#数据劫持&quot; class=&quot;headerlink&quot; title=&quot;数据劫持&quot;&gt;&lt;/a&gt;数据劫持&lt;/h1&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一些关于vue的零散笔记</title>
    <link href="http://yoohannah.github.io/post/vue/usual.html"/>
    <id>http://yoohannah.github.io/post/vue/usual.html</id>
    <published>2020-01-27T02:48:15.000Z</published>
    <updated>2020-02-05T15:16:11.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="释放内部对象且能防止外部修改的方式"><a href="#释放内部对象且能防止外部修改的方式" class="headerlink" title="释放内部对象且能防止外部修改的方式"></a>释放内部对象且能防止外部修改的方式</h1><p>通过创建中间对象挂载到实例上，通过中间对象的set方法进行拦截<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function initGlobalAPI (Vue) &#123;</div><div class="line">  var configDef = &#123;&#125;;</div><div class="line">  configDef.get = function () &#123; return config; &#125;; //config对象是vue对象构建过程的内部对象，存储全局配置项</div><div class="line">  &#123;</div><div class="line">    configDef.set = function () &#123;</div><div class="line">      warn(</div><div class="line">        &apos;Do not replace the Vue.config object, set individual fields instead.&apos;</div><div class="line">      );</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  Object.defineProperty(Vue, &apos;config&apos;, configDef);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://cn.vuejs.org/v2/api/#optionMergeStrategies" target="_blank" rel="external">Vue.config.optionMergeStrategies</a> 应用中<br>Vue.config可以get,得到的即内部的config，但如果进行Vue.config = xxxx set操作就会报错<br>通过Vue.config可以获得内部config，从而可以修改内部config对象上的属性，从而修改到全局配置</p>
<h1 id="关于3-0的思考"><a href="#关于3-0的思考" class="headerlink" title="关于3.0的思考"></a>关于3.0的思考</h1><p>如何更快<br>Object.defineProperty–&gt;Proxy<br>Virtual Dom重构<br>更多编译优化：<br>Slot默认编译为函数<br>重构vnode factory，统一输入参数，进一步优化编译处理函数(Monomorphic vnode factory)<br>编译时增加vnode/children 类型信息标识，从而做进一步优化（Compiler-generated flags for vnode/children types）</p>
<p>Function based API 对比Class API 好处<br>更好的TS类型推导支持<br>更灵活的逻辑复用能力<br>Tree-shaking 友好<br>代码更容易压缩</p>
<p>现有逻辑复用模式<br>Mixins<br>高阶组件<br>基于scoped slots/作用域插槽封装逻辑的组件<br>存在问题<br>数据来源不清晰 （Function based API 数据来源清晰）<br>命名冲突（Function based API 没有命名冲突）<br>无谓的额外组件的性能消耗 （Function based API 没有额外组件性能消耗）</p>
<p>对比React Hooks<br>同样的逻辑组合，复用能力更强<br>只调用一次<br>符合JS直觉<br>没有闭包变量问题<br>没有内存/GC压力<br>不存在内联回调导致子组件永远更新问题</p>
<p>2.0<br>mergeOption 选项策略处理<br>插件开发：以默认配置优先；以用户配置为覆盖<br>策略：听过JS 增强配置选项的表达力<br>{}==&gt;function(){}  el===根实例</p>
<p>数据劫持vue3.0改用proxy原因<br>defineProperty只能监听某个属性，不能对全对象监听，使用proxy可以省去for in提升效率<br>可以监听数组，不用再去单独的对数组做特异性操作</p>
<p>vue2.0 vdom性能瓶颈<br>虽然能够保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个Vdom树<br>vdom的性能跟模板大小正相关，跟动态节点的数量无关。<br>在一些组件整个模板内只有少量动态节点的情况下，这些遍历都是性能的浪费</p>
<h1 id="编译3步骤"><a href="#编译3步骤" class="headerlink" title="编译3步骤"></a>编译3步骤</h1><p>parse：AST<br>optimize:标记静态节点<br>generate 生成目标平台所需的代码 将AST转化成render function字符串</p>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>v-model.lazy 从input事件中转变为在change事件中同步数据<br>v-model.number 可以将输入转换为Number类型<br>v-model.trim 可以自动过滤输入的首尾空格</p>
<p>v-for 循环时，key尽量赋值为不变的值，即静态值，如item.id ,否则列表增删时，会更新每一项</p>
<p>当子组件需要向父组件传递数据时，就要用到自定义事件<br>子组件用$emit来触发事件，父组件用$on()来监听子组件的事件<br>自定义组件的v-model ：一个组件上的v-model 默认会利用名为value的prop和名为input的事件<br>将原生事件绑定到组件： 使用v-on的.native修饰符监听原生事件<br>.sync修饰符：父组件监听自定义事件按需更新数据</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>动态组件：VUE 提供了一个特殊的元素&lt;component&gt;用来动态的挂载不同的组件，使用is特性来选择要挂载的组件， 还可以使用&lt;keep-alive&gt;标签使组件进行缓存</p>
<p>异步组件：VUE允许将组件定义为一个工厂函数，动态地解析组件。VUE只在组件需要渲染时触发工厂函数，并且把结果缓存起来用于后面地再次渲染</p>
<h2 id="组件创建方式"><a href="#组件创建方式" class="headerlink" title="组件创建方式"></a>组件创建方式</h2><p>1.调用Vue.extend(),创建名为xx的组件，template定义模板的标签，模板的内容需要写在该标签下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var xx = Vue.extend(&#123;</div><div class="line">    template:&apos;&lt;div&gt;this is a component&lt;/div&gt;&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>2.使用&lt;template&gt;标签创建，需要加上id属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;template id = &apos;mycom&apos;&gt;</div><div class="line">  &lt;div&gt;this is a component&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure></p>
<p>3.使用&lt;script&gt;标签创建，需要加id属性，同时还得加type=’text/x-template’ 不执行编译里面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&apos;text/x-template&apos; id = &apos;mycom&apos;&gt;</div><div class="line">  &lt;div&gt;this is a component&lt;/div&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="组件全局注册方式"><a href="#组件全局注册方式" class="headerlink" title="组件全局注册方式"></a>组件全局注册方式</h2><p>1.调用Vue.extend(),创建名为myCom的组件全局注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;my-com&apos;,myCom)</div></pre></td></tr></table></figure></p>
<p>2.template及script标签构建的组件全局注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;my-comp&apos;,&#123;</div><div class="line">    template:&apos;#mycom&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="组件局部注册"><a href="#组件局部注册" class="headerlink" title="组件局部注册"></a>组件局部注册</h2><p>1.调用Vue.extend(),创建名为myCom的组件局部注册（只能在注册该组件的实例中使用，一处注册，一处使用）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var app = new Vue(&#123;</div><div class="line">    el:&apos;#app&apos;,</div><div class="line">    components:&#123;</div><div class="line">        &apos;my-com&apos;:myCom</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>2.template及script构建的组件局部注册<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var app = new Vue(&#123;</div><div class="line">    el:&apos;#app&apos;</div><div class="line">    componnets:&#123;</div><div class="line">        &apos;my-com&apos;:&#123;</div><div class="line">            template:&apos;#myCom&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="组件化处理边界情况"><a href="#组件化处理边界情况" class="headerlink" title="组件化处理边界情况"></a>组件化处理边界情况</h2><p>1.访问根实例 this.$root.xxx<br>2.访问父组件实例：this.$parent.xxx<br>3.访问子组件实例或子元素：&lt;child ref=’xxx’&gt;&lt;/child &gt; =&gt;this.$refs.xxx<br>4.依赖注入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">provide:function()&#123; //父组件</div><div class="line">    return&#123;</div><div class="line">        getMap:this.getMap</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">inject:[getMap]//子组件</div></pre></td></tr></table></figure></p>
<p>然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。同时所提供的属性是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root做这件事都是不够好的。如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了</p>
<p>5.统一处理事件侦听器时，在组件卸载前，统一清除监听器<br>6.组件循环引用，Vue.component注册的组件允许，但是模块化导入的不允许<br>7.模板定义的替代品：<br>A:内联模板：当inline-template这个特殊的特性出现在一个子组件上时，这个组件将会使用其里面的内容作为模板<br>而不是将其作为被分发的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;myCom inline-template&gt;&lt;div&gt;&lt;p&gt;these are compiled as the component&apos;s own template&lt;/p&gt;&lt;/div&gt;&lt;/myCom&gt;</div></pre></td></tr></table></figure></p>
<p>B:x-template<br>在script标签里使用text/x-template，并且指定id,将这个id赋值给template<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&apos;text/x-template&apos; id = &apos;mycom&apos;&gt;</div><div class="line">  &lt;div&gt;this is a component&lt;/div&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">Vue.component(&apos;my-comp&apos;,&#123;</div><div class="line">    template:&apos;#mycom&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>8.强制更新<br>A：使用this.$forceUpdate<br>B：使用v-once创建低开销静态组件，组件包含大量静态内容可以在根元素上添加v-once特性以确保这些内容只计算一次然后缓存起来</p>
<h2 id="组件通信类型"><a href="#组件通信类型" class="headerlink" title="组件通信类型"></a>组件通信类型</h2><p>父子组件通信<br>1.使用props和$emit父子组件相互通信<br>2.父组件用$children或者利用ref操作子组件<br>3.子组件$parent访问父组件</p>
<p>非父子组件通信<br>1.使用中央事件总线(eventbus来处理非父子组件间的通信)<br>2.祖先元素通过provide提供数据，后代通过inject获取该数据<br>3.使用$attrs和$listeners实现祖孙组件通信<br>4.$root直接访问根组件</p>
<h1 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h1><p>Vue.use(myPlugin)本质上是调用myPlugin.install(VUE)<br>使用插件必须在new vue()启动应用之前完成，实例化之前就要配置好<br>使用Vue.use多次注册相同插件，那只会注册成功一次<br>一个测试案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import &#123;expect&#125; from &apos;chai&apos;</div><div class="line">import Counter from &apos;@/counter.vue&apos;</div><div class="line"></div><div class="line">describe(&apos;测试Counter.vue&apos;,()=&gt;&#123;</div><div class="line">    const Constructor = Vue.extend(Counter)</div><div class="line">    const vm = new Constructor().$mount()</div><div class="line">    const button = vm.$el.querySelector(&apos;button&apos;)</div><div class="line">    const clickE = new window.Event(&apos;click&apos;)</div><div class="line">    button.dispatchEvent(clickE)</div><div class="line">    vm._watcher.run()</div><div class="line">    expect(Number(vm.$el.querySelector(&apos;span&apos;).textContent)).to.equal(1)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>默认的五种基本对象<br>state:存储状态(对象)<br>getters:对数据获取之前的再次编译，可以理解为state的计算属性，对state的数据进行筛选，过滤<br>mutations:同步修改状态，并且是同步的。在组件中使用$store.commit(‘’,params)<br>actions:异步修改状态，在组件中使用是$store.dispatch(‘’)<br>modules:store的子模块，为了开发大型项目，方便状态管理而使用的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;释放内部对象且能防止外部修改的方式&quot;&gt;&lt;a href=&quot;#释放内部对象且能防止外部修改的方式&quot; class=&quot;headerlink&quot; title=&quot;释放内部对象且能防止外部修改的方式&quot;&gt;&lt;/a&gt;释放内部对象且能防止外部修改的方式&lt;/h1&gt;&lt;p&gt;通过创建中间对象挂载
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 源码学习stack</title>
    <link href="http://yoohannah.github.io/post/vue/vuesrcstack.html"/>
    <id>http://yoohannah.github.io/post/vue/vuesrcstack.html</id>
    <published>2020-01-27T02:48:15.000Z</published>
    <updated>2020-02-29T04:37:54.145Z</updated>
    
    <content type="html"><![CDATA[<p>第一个变量是 stack，它被初始化为一个空数组，在 while 循环中处理 html 字符流的时候每当遇到一个非单标签，都会将该开始标签 push 到该数组。它的作用模板中 DOM 结构规范性的检测。<br>假设我们有如下html字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;&lt;p&gt;&lt;span&gt;&lt;/p&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>在编译这个字符串的时候，首先会遇到 div 开始标签，并将该 push 到 stack 数组，然后会遇到 p 开始标签，并将该标签 push 到 stack ，接下来会遇到 span 开始标签，同样被 push 到 stack ，此时 stack 数组内包含三个元素。<br><a href="/image"></a><br>再然后便会遇到 p 结束标签，按照正常逻辑可以推理出最先遇到的结束标签，其对应的开始标签应该最后被push到 stack 中，也就是说 stack 栈顶的元素应该是 span ，如果不是 span 而是 p，这说明 span 元素缺少闭合标签。</p>
<p>这就是检测 html 字符串中是否缺少闭合标签的原理</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一个变量是 stack，它被初始化为一个空数组，在 while 循环中处理 html 字符流的时候每当遇到一个非单标签，都会将该开始标签 push 到该数组。它的作用模板中 DOM 结构规范性的检测。&lt;br&gt;假设我们有如下html字符串：&lt;br&gt;&lt;figure class
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 源码学习三</title>
    <link href="http://yoohannah.github.io/post/vue/src3.html"/>
    <id>http://yoohannah.github.io/post/vue/src3.html</id>
    <published>2020-01-27T02:48:15.000Z</published>
    <updated>2020-02-26T14:30:31.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-component"><a href="#vue-component" class="headerlink" title="vue.component"></a>vue.component</h1><p>template配置项的处理，与编译时的判断做对比</p>
<h1 id="生命周期合并策略"><a href="#生命周期合并策略" class="headerlink" title="生命周期合并策略"></a>生命周期合并策略</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var strats = config.optionMergeStrategies;</div><div class="line">LIFECYCLE_HOOKS.forEach(function (hook) &#123;</div><div class="line">    strats[hook] = mergeHook;</div><div class="line">  &#125;);</div><div class="line">function mergeHook (</div><div class="line">    parentVal,</div><div class="line">    childVal</div><div class="line">  ) &#123;</div><div class="line">    var res = childVal</div><div class="line">      ? parentVal</div><div class="line">        ? parentVal.concat(childVal)</div><div class="line">        : Array.isArray(childVal)</div><div class="line">          ? childVal</div><div class="line">          : [childVal]</div><div class="line">      : parentVal;</div><div class="line">    return res</div><div class="line">      ? dedupeHooks(res)</div><div class="line">      : res</div><div class="line">  &#125;</div><div class="line"></div><div class="line">function mergeOptions (</div><div class="line">    parent,</div><div class="line">    child,</div><div class="line">    vm</div><div class="line">  ) &#123;</div><div class="line">    &#123;</div><div class="line">      checkComponents(child);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (typeof child === &apos;function&apos;) &#123;</div><div class="line">      child = child.options;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    normalizeProps(child, vm);</div><div class="line">    normalizeInject(child, vm);</div><div class="line">    normalizeDirectives(child);</div><div class="line"></div><div class="line">    // Apply extends and mixins on the child options,</div><div class="line">    // but only if it is a raw options object that isn&apos;t</div><div class="line">    // the result of another mergeOptions call.</div><div class="line">    // Only merged options has the _base property.</div><div class="line">    if (!child._base) &#123;</div><div class="line">      if (child.extends) &#123;</div><div class="line">        parent = mergeOptions(parent, child.extends, vm);</div><div class="line">      &#125;</div><div class="line">      if (child.mixins) &#123;</div><div class="line">        for (var i = 0, l = child.mixins.length; i &lt; l; i++) &#123;</div><div class="line">          parent = mergeOptions(parent, child.mixins[i], vm);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var options = &#123;&#125;;</div><div class="line">    var key;</div><div class="line">    for (key in parent) &#123;</div><div class="line">      mergeField(key);</div><div class="line">    &#125;</div><div class="line">    for (key in child) &#123;</div><div class="line">      if (!hasOwn(parent, key)) &#123;</div><div class="line">        mergeField(key);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    function mergeField (key) &#123;</div><div class="line">      var strat = strats[key] || defaultStrat;</div><div class="line">      options[key] = strat(parent[key], child[key], vm, key);</div><div class="line">    &#125;</div><div class="line">    return options</div><div class="line">  &#125;</div><div class="line"> function initMixin$1 (Vue) &#123;</div><div class="line">    Vue.mixin = function (mixin) &#123;</div><div class="line">      this.options = mergeOptions(this.options, mixin);</div><div class="line">      return this</div><div class="line">    &#125;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vue-component&quot;&gt;&lt;a href=&quot;#vue-component&quot; class=&quot;headerlink&quot; title=&quot;vue.component&quot;&gt;&lt;/a&gt;vue.component&lt;/h1&gt;&lt;p&gt;template配置项的处理，与编译时的判断做对比&lt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue 源码学习一</title>
    <link href="http://yoohannah.github.io/post/vue/src1.html"/>
    <id>http://yoohannah.github.io/post/vue/src1.html</id>
    <published>2020-01-27T02:48:15.000Z</published>
    <updated>2020-02-19T11:02:14.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-vue时发生了什么"><a href="#new-vue时发生了什么" class="headerlink" title="new vue时发生了什么"></a>new vue时发生了什么</h1><p>平常练习时使用vue顺序是，将vue.js引入html,<br>new vue就可以开始使用vue框架写东西<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">  &lt;div id = &apos;app&apos;&gt;</div><div class="line">    &lt;p&gt;&#123;&#123;a&#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">    let app = new Vue(&#123;</div><div class="line">      el:&apos;#app&apos;,</div><div class="line">      data:&#123;</div><div class="line">        a:&apos;hello world&apos;</div><div class="line">      &#125;,</div><div class="line">      method:&#123;&#125;,</div><div class="line">    &#125;)</div><div class="line">  &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<p>代码运行顺序是，当我们在script标签引入文件时，<br>引入的vuejs文件会先执行一遍，<br>执行的结果就是帮助我们生成一个挂载在全局的，vue对象的构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(function (global, factory) &#123;</div><div class="line">  typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos; ? module.exports = factory() :</div><div class="line">  typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory) :</div><div class="line">  (global = global || self, global.Vue = factory());//将vue挂到全局上下文中</div><div class="line">&#125;(this, function () &#123; &apos;use strict&apos;;</div><div class="line">  function Vue (options) &#123;</div><div class="line">    if (!(this instanceof Vue)</div><div class="line">    ) &#123;</div><div class="line">      warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;);</div><div class="line">    &#125;</div><div class="line">    this._init(options);</div><div class="line">  &#125;</div><div class="line">  initMixin(Vue);</div><div class="line">  stateMixin(Vue);</div><div class="line">  eventsMixin(Vue);</div><div class="line">  lifecycleMixin(Vue);</div><div class="line">  renderMixin(Vue);</div><div class="line">  initGlobalAPI(Vue);</div><div class="line">  Vue.compile = compileToFunctions;</div><div class="line"></div><div class="line">  return Vue;</div><div class="line"></div><div class="line">&#125;));</div></pre></td></tr></table></figure></p>
<p>当代码运行到new vue时，代码就会调用function Vue<br>function Vue 中会【调用】自己的_init()方法，<br>对即将生成的vue对象做初始化工作，即开始生成vue对象</p>
<p>_init方法定义在initMixin函数中<br>在调用initMixin生成构造函数流程中被挂到vue上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._init = function (options) &#123;</div><div class="line">  var vm = this;</div><div class="line">  vm._uid = uid$3++;</div><div class="line"></div><div class="line">  var startTag, endTag;</div><div class="line">  vm._isVue = true;// a flag to avoid this being observed</div><div class="line">  // 合并选项,将配置项以内置选项进行合并</div><div class="line">  if (options &amp;&amp; options._isComponent) &#123;</div><div class="line">    //优化内部组件实例化过程</div><div class="line">    // 由于动态选项合并非常慢，并且内部组件选项均不需要特殊处理。</div><div class="line">    initInternalComponent(vm, options);</div><div class="line">  &#125; else &#123;</div><div class="line">    vm.$options = mergeOptions(</div><div class="line">      resolveConstructorOptions(vm.constructor),</div><div class="line">      options || &#123;&#125;,</div><div class="line">      vm</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">  /* istanbul ignore else */</div><div class="line">  &#123;</div><div class="line">    initProxy(vm);</div><div class="line">  &#125;</div><div class="line">  // expose real self</div><div class="line">  vm._self = vm;</div><div class="line">  initLifecycle(vm);</div><div class="line">  initEvents(vm);</div><div class="line">  initRender(vm);</div><div class="line">  callHook(vm, &apos;beforeCreate&apos;);//运行订阅了beforecreate钩子的相关方法</div><div class="line">  initInjections(vm); // resolve injections before data/props</div><div class="line">  initState(vm);</div><div class="line">  initProvide(vm); // resolve provide after data/props</div><div class="line">  callHook(vm, &apos;created&apos;);</div><div class="line">  if (vm.$options.el) &#123;//如果配置了el,就进行挂载处理挂载</div><div class="line">    vm.$mount(vm.$options.el);//会给给option挂上render，staticRenderFns属性</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;new-vue时发生了什么&quot;&gt;&lt;a href=&quot;#new-vue时发生了什么&quot; class=&quot;headerlink&quot; title=&quot;new vue时发生了什么&quot;&gt;&lt;/a&gt;new vue时发生了什么&lt;/h1&gt;&lt;p&gt;平常练习时使用vue顺序是，将vue.js引入htm
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>一些关于H5的知识</title>
    <link href="http://yoohannah.github.io/post/knowledge/h5.html"/>
    <id>http://yoohannah.github.io/post/knowledge/h5.html</id>
    <published>2020-01-27T02:33:58.000Z</published>
    <updated>2020-01-27T12:08:30.880Z</updated>
    
    <content type="html"><![CDATA[<p>h5 新增语义化布局标签：header,nav,section,aside,article,footer，均表现为块级<br>canvas,video,audio,sessionStorage,localStorage,<br>拖放API(源对象：ondragstart,ondrag,ondragend；源对象标签属性要设置为draggable=true<br>目标对象：ondragenter,ondragover,ondragleave,ondrop;<br>ondragover事件默认会屏蔽ondrop事件,<br>如果要触发ondrop事件，需要在ondragover事件函数中阻止默认屏蔽行为<br>event.preventDefault()<br>)<br>//谷歌浏览器v56 之后，window,document,body的touchstart,touchmove事件会被默认为pssive:true<br>//解决方法一：window.addEventListener(‘touchstart’,func,{passive:false})<br>//解决方法二，添加样式：*{touch-action:none} 取消所有元素默认事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//实现把A标签拖到B标签</div><div class="line">1.A标签开始拖动时</div><div class="line">ondragstart(event)&#123;</div><div class="line">  event.dataTransfer.setData(&apos;source&apos;,event.target.id)</div><div class="line">&#125;</div><div class="line">2.B标签监听拖拽结束后</div><div class="line">ondrop(event)&#123;</div><div class="line">  var source = document.getElementById(event.dataTransfer.getData(&apos;source&apos;))</div><div class="line">  event.target.appendChild(source)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>History常用场景<br>单页应用中：实现网页无刷新更新数据的同时，解决浏览器无法前进/后退的问题<br>pushState:每执行一次都会增加一条历史记录，浏览器在返回时，就不会返回前一个页面，并且不会刷新浏览器<br>replaceState：用来修改当前历史记录，而不是创建一个新的历史记录，点击返回按钮照样会返回上一个页面<br>onpopstate：点击后退，前进或者调用history.back()，history.forward(),history.go()方法</p>
<h1 id="跨文档通讯"><a href="#跨文档通讯" class="headerlink" title="跨文档通讯"></a>跨文档通讯</h1><p>定义：跨文档消息传送，来自不同域的页面间传递消息<br>使用场景：内嵌框架和其父文档相互进行数据传输或者通讯</p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>window.postMessage(message,origin,transfer)<br>message:发送到子文档的信息，一般转成字符串，否则可能出现浏览器不兼容<br>origin:域信息，告诉子文档，消息来源，用于判断来源是否匹配，然后才进行相关操作<br>transfer:转移消息对象，可选参数，是一串和message同时传递的Transferable对象，这些对象的所有权将被转移给消息的接收方，而发送方将不再保有所有权</p>
<h2 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h2><p>onmessage事件回调函数参数event事件对象<br>event.data:postMessage传输过来的第一个参数，通常是字符串类型，（也可以是其他类型，但可能出现浏览器不兼容情况，所以一般转成字符串传递）<br>event.origin:postMessage传输过来的第二个参数，是用来匹配来源方的域<br>event.source:来源方目标文档的window引用，通常用作单次握手回应数据（event.source.postMessage()）<br>event.ports:MessageEvent接口特有属性，用于获取消息端口集合对象</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>父文档A通过iframe内嵌框架加载B子文档<br>通过iframe内嵌框架的onload事件回调父文档的sendMsg函数<br>再sendMsg函数中通过postMessage()函数向子文档B发送消息</p>
<p>子文档B监听onmessage事件，当文档收到消息后会执行该事件回调函数<br>回调函数内通过event对象判断域是否安全，然后处理推送过来的消息，<br>可以再通过调用event.source.postMessage向父文档发送消息</p>
<h1 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h1><p>navigator.geolocation.getCurrentPosition(success,error,option)<br>success:成功得到位置时的回调函数，使用Position对象作为唯一的参数<br>error:失败时回调，使用PositionError对象作为唯一参数<br>options：可选参数，对请求做一些配置</p>
<h1 id="离线存储优势"><a href="#离线存储优势" class="headerlink" title="离线存储优势"></a>离线存储优势</h1><p>离线浏览：当用户网络断开时，可以继续访问页面<br>访问速度快：将资源缓存到本地，已缓存资源加载更快<br>减少服务器负载：浏览器将只会从服务器下载更新过或者更改过的资源</p>
<h1 id="视频播放兼容"><a href="#视频播放兼容" class="headerlink" title="视频播放兼容"></a>视频播放兼容</h1><h2 id="Flv-js"><a href="#Flv-js" class="headerlink" title="Flv.js"></a>Flv.js</h2><p>H5 Flash(FLV)播放器,纯原生js开发，使H5能够支持FLV格式的视频<br>原理：将FLV文件流转码复用为ISO BMFF(MP4碎片)片段，然后通过Media Source Extension将MP4片段汇进浏览器<br>使用es6编写，通过Babel Compiler编译成es5能够支持FLV格式的视频</p>
<h2 id="Video-js"><a href="#Video-js" class="headerlink" title="Video.js"></a>Video.js</h2><p>几乎兼容所有浏览器,且优先使用H5，在不支持的浏览器中自动使用Flash播放<br>构建视频播放页面耗时短，界面可定制，开源，纯JS和css实现，文档详细</p>
<p>#Canvas绘制动画步骤<br>1.清空canvas<br>除非接下来要画的内容会完全充满canvas(例如背景图)，否则需要清空所有，最简单<br>的做法就是clearRect方法<br>2.保存canvas状态<br>如果需要改变一些会改变canvas状态的设置(样式，变形之类的)，又要在每画一帧之时，都是原始状态的话，需要先保存一下<br>3.绘制动画图形<br>重绘动画帧<br>4.恢复canvas状态<br>如果已经保存了canvas的状态，可以先恢复它，然后重绘下一帧</p>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><p>2D功能函数组合使用时，先写的后执行<br>perspective：100px 可以设置3d旋转时的景深<br>transform-origin:可以改变中心点</p>
<h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><p>可以通过link标签配置media去使用不同比例的CSS样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=&apos;stylesheet&apos; media=&apos;screen and (max-device-width:480px)&apos; href=&apos;./css1.css&apos;&gt;</div><div class="line">&lt;link rel=&apos;stylesheet&apos; media=&apos;screen and (min-device-width:480px)&apos; href=&apos;./css2.css&apos;&gt;</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/YooHannah/algorithm/blob/master/baseJs/touchEvent.js" target="_blank" rel="external">一些触摸事件的实现</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;h5 新增语义化布局标签：header,nav,section,aside,article,footer，均表现为块级&lt;br&gt;canvas,video,audio,sessionStorage,localStorage,&lt;br&gt;拖放API(源对象：ondragstart,o
    
    </summary>
    
    
      <category term="html" scheme="http://yoohannah.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>一些vueRouter官方文档看到的</title>
    <link href="http://yoohannah.github.io/post/vue/vueRouter.html"/>
    <id>http://yoohannah.github.io/post/vue/vueRouter.html</id>
    <published>2019-11-28T15:06:15.000Z</published>
    <updated>2019-11-28T15:06:16.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复用组件"><a href="#复用组件" class="headerlink" title="复用组件"></a>复用组件</h2><p>当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。<br>因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，可以简单地 watch (监测变化) $route 对象</p>
<p>参数或查询的改变并不会触发进入/离开的导航守卫。<br>可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</p>
<h2 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h2><p>如果提供了 path，params 会被忽略，query 并不会被忽略。你需要提供路由的 name 或手写完整的带有参数的 path<br> path—–query   name—–params</p>
<h2 id="beforeRouteUpdate"><a href="#beforeRouteUpdate" class="headerlink" title="beforeRouteUpdate"></a>beforeRouteUpdate</h2><p>如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)</p>
<h2 id="router-view标签"><a href="#router-view标签" class="headerlink" title="router-view标签"></a>router-view标签</h2><p><router-view> 没有设置名字，那么默认为 default；如果设置了name，那么该视图显示路由中components中配置的name值对应的组件</router-view></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向三种形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, redirect: &apos;/b&apos; &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">2.命名的路由</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, redirect: &#123; name: &apos;foo&apos; &#125;&#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line">3.方法，动态返回重定向目标：</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, redirect: to =&gt; &#123;</div><div class="line">      // 方法接收 目标路由 作为参数</div><div class="line">      // return 重定向的 字符串路径/路径对象</div><div class="line">    &#125;&#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上,为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果</p>
<p>“重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b，<br>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>通过配置props属性实现多路由复用组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1.如果 props 被设置为 true，route.params 将会被设置为组件属性。</div><div class="line">const User = &#123;</div><div class="line">  props: [&apos;id&apos;],</div><div class="line">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;</div><div class="line">&#125;</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</div><div class="line"></div><div class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</div><div class="line">    &#123;</div><div class="line">      path: &apos;/user/:id&apos;,</div><div class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</div><div class="line">      props: &#123; default: true, sidebar: false &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">2.如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/promotion/from-newsletter&apos;, component: Promotion, props: &#123; newsletterPopup: false &#125; &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">3.创建一个函数返回 props</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line">URL /search?q=vue 会将 &#123;query: &apos;vue&apos;&#125; 作为属性传递给 SearchUser 组件</div></pre></td></tr></table></figure></p>
<p>请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应</p>
<h2 id="路由生命周期"><a href="#路由生命周期" class="headerlink" title="路由生命周期"></a>路由生命周期</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>router.beforeEach:当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">三个参数</div><div class="line">to: 即将要进入的目标 路由对象</div><div class="line">from: 当前导航正要离开的路由的路由对象</div><div class="line">next：一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数</div><div class="line">      next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</div><div class="line">      next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</div><div class="line">      next(&apos;/&apos;) 或者 next(&#123; path: &apos;/&apos; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</div><div class="line">      next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调</div></pre></td></tr></table></figure></p>
<p>router.beforeResolve:在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</p>
<p>router.afterEach:不会接受 next 函数也不会改变导航本身</p>
<h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/foo&apos;,</div><div class="line">      component: Foo,</div><div class="line">      beforeEnter: (to, from, next) =&gt; &#123;</div><div class="line">        // ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="组件内"><a href="#组件内" class="headerlink" title="组件内"></a>组件内</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const Foo = &#123;</div><div class="line">  template: `...`,</div><div class="line">  beforeRouteEnter (to, from, next) &#123;</div><div class="line">    // 在渲染该组件的对应路由被 confirm 前调用</div><div class="line">    // 不！能！获取组件实例 `this` </div><div class="line">    // 因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</div><div class="line">    //可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</div><div class="line">    next(vm =&gt; &#123; //是支持给 next 传递回调的唯一钩子，beforeRouteUpdate，beforeRouteLeave都不支持，因为可以访问的到</div><div class="line">      // 通过 `vm` 访问组件实例</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  beforeRouteUpdate (to, from, next) &#123;</div><div class="line">    // 在当前路由改变，但是该组件被复用时调用</div><div class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</div><div class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</div><div class="line">    // 可以访问组件实例 `this`</div><div class="line">  &#125;,</div><div class="line">  beforeRouteLeave (to, from, next) &#123;</div><div class="line">    // 导航离开该组件的对应路由时调用</div><div class="line">    // 可以访问组件实例 `this`</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">created () &#123;</div><div class="line">  // 组件创建完后获取数据，</div><div class="line">  // 此时 data 已经被 observed 了</div><div class="line">  this.fetchData()</div><div class="line">&#125;,</div><div class="line">watch: &#123;</div><div class="line">  // 如果路由有变化，会再次执行该方法</div><div class="line">  &apos;$route&apos;: &apos;fetchData&apos;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h3 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">beforeRouteEnter (to, from, next) &#123;</div><div class="line">  getPost(to.params.id, (err, post) =&gt; &#123;</div><div class="line">    next(vm =&gt; vm.setData(err, post))</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line">// 路由改变前，组件就已经渲染完了</div><div class="line">// 逻辑稍稍不同</div><div class="line">beforeRouteUpdate (to, from, next) &#123;</div><div class="line">  this.post = null</div><div class="line">  getPost(to.params.id, (err, post) =&gt; &#123;</div><div class="line">    this.setData(err, post)</div><div class="line">    next()</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">  setData (err, post) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">      this.error = err.toString()</div><div class="line">    &#125; else &#123;</div><div class="line">      this.post = post</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><p>scrollBehavior 这个功能只在支持 history.pushState 的浏览器中可用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [...],</div><div class="line">  scrollBehavior (to, from, savedPosition) &#123;</div><div class="line"></div><div class="line">    // return 期望滚动到哪个的位置</div><div class="line">    if (to.hash) &#123;</div><div class="line">      return &#123;</div><div class="line">        selector: to.hash //模拟“滚动到锚点”的行为</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if (savedPosition) &#123;</div><div class="line">      return savedPosition //返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样</div><div class="line">    &#125; else &#123;</div><div class="line">      return &#123; x: 0, y: 0 &#125; //让页面滚动到顶部</div><div class="line">    &#125;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123; //返回一个 Promise 来得出预期的位置描述</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&#123; x: 0, y: 0 &#125;)</div><div class="line">      &#125;, 500)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;复用组件&quot;&gt;&lt;a href=&quot;#复用组件&quot; class=&quot;headerlink&quot; title=&quot;复用组件&quot;&gt;&lt;/a&gt;复用组件&lt;/h2&gt;&lt;p&gt;当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。&lt;br&gt;因为两个路由都渲染
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>两个css问题解决</title>
    <link href="http://yoohannah.github.io/post/knowledge/calcApprence.html"/>
    <id>http://yoohannah.github.io/post/knowledge/calcApprence.html</id>
    <published>2019-11-28T14:58:58.000Z</published>
    <updated>2020-01-27T12:38:29.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子元素-position-fixed-，但宽度要和父元素一致"><a href="#子元素-position-fixed-，但宽度要和父元素一致" class="headerlink" title="子元素 position:fixed ，但宽度要和父元素一致"></a>子元素 position:fixed ，但宽度要和父元素一致</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>父元素宽度随屏幕大小变化，而且margin-left有一个固定值，假设为320px<br>子元素position:fixed<br>如果直接设置子元素宽度为100%<br>则会导致子元素有320px的宽度在可视区域外<br><img src="/image/calc.png" alt="calc.png"></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>css3的函数calc() 可以用来计算属性值<br>特点：<br>1.浏览器解析calc()结果还是calc(),不会计算参数表达式的值，<br>  意味着浏览器中的值可以更加灵活，能够响应视口的改变，即实际渲染结果始终调用calc计算结果<br>2.可以使用加减乘除，可以套嵌使用，即calc参数表达式中可以包含calc函数调用<br>3.可以进行不同单位间的计算,可以混合绝对单位(如百分比与视口单元)与相对单元(比如像素)<br>应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.居中</div><div class="line">//居中设置原来</div><div class="line">.center &#123;</div><div class="line">  position: absolute</div><div class="line">  top: 50%;</div><div class="line">  left: 50%;</div><div class="line">  marging-top: -150px;</div><div class="line">  margin-left: -150px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用calc</div><div class="line">.center &#123;</div><div class="line">  position: absolute</div><div class="line">  top: calc(50% - 150px);</div><div class="line">  left: calc(50% - 150px);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2.设置字体，在页面上的任何文本，将会根据视口自动缩放，</div><div class="line">相同比例的视口总会显示相同的文本数量，不管视口的真实尺寸是多少。</div><div class="line">html &#123;  </div><div class="line">    font-size: calc(100vw / 30);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">width:calc(100%-320px)</div></pre></td></tr></table></figure>
<h1 id="input样式兼容"><a href="#input样式兼容" class="headerlink" title="input样式兼容"></a>input样式兼容</h1><p>在safari浏览器中给input设置样式不能直接被使用，会依旧使用浏览器默认样式，<br>此时需要给样式添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-webkit-appearance: none;/*去除系统默认appearance的样式*/</div><div class="line">line-height: normal;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;子元素-position-fixed-，但宽度要和父元素一致&quot;&gt;&lt;a href=&quot;#子元素-position-fixed-，但宽度要和父元素一致&quot; class=&quot;headerlink&quot; title=&quot;子元素 position:fixed ，但宽度要和父元素一致&quot;&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>关于代理proxy</title>
    <link href="http://yoohannah.github.io/post/js/proxy.html"/>
    <id>http://yoohannah.github.io/post/js/proxy.html</id>
    <published>2019-11-08T14:19:37.000Z</published>
    <updated>2019-12-18T14:34:42.882Z</updated>
    
    <content type="html"><![CDATA[<p>代理是JS es6中引入，可用于控制对象<br>—代理可以定制对象交互时行动（例如，当读取属性或调用方法）<br>— 所有交互行为都必须通过代理，指定的行为发生时会调用代理方法<br>使用代理可以优雅实现以下内容</p>
<ul>
<li>日志记录</li>
<li>性能测试</li>
<li>数据校验</li>
<li>自动填充对象属性</li>
<li>数组负索引</li>
</ul>
<p>使用代理对对象访问添加日志 — report 函数用于添加日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function makeLoggable(target)&#123;</div><div class="line">	return new Proxy(target,&#123;</div><div class="line">		get:(target,property)=&gt;&#123;</div><div class="line">			report(&apos;READING:&apos;+property)</div><div class="line">			return target[property]</div><div class="line">		&#125;,</div><div class="line">		set:(target,property,value)=&gt;&#123;</div><div class="line">			report(&apos;writing value&apos; +value +&apos;to&apos;+&apos;property&apos;)</div><div class="line">			target[property] = value</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>proxy 用于数据校验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var personValidator = &#123;</div><div class="line">    name(val)&#123;</div><div class="line">        return typeof val === &apos;string&apos;</div><div class="line">    &#125;</div><div class="line">    age(val)&#123;</div><div class="line">        return typeof val === &apos;number&apos; &amp;&amp; val&gt;18</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class person&#123;</div><div class="line">    constructor(name,age)&#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">        return createValidator(this,personValidator)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function createValidator(target,validator)&#123;</div><div class="line">    return new Proxy(target,&#123;</div><div class="line">        _validator:validator,</div><div class="line">        set(target,key,value,proxy)&#123;</div><div class="line">            if(target.hasOwnproperty(key))&#123;</div><div class="line">                var validator = this._validator[key]</div><div class="line">                if(validator(value))&#123;</div><div class="line">                    return Reflect.set(target,key,value,proxy)</div><div class="line">                &#125;else&#123;</div><div class="line">                    throw Error(&apos;type error&apos;)</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用代理自动填充属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Folder()&#123;</div><div class="line">	return new Proxy(&#123;&#125;,&#123;</div><div class="line">		get:(target,property)=&gt;&#123;</div><div class="line">			if(!(property in target))&#123;</div><div class="line">				target[property] = new Folder()</div><div class="line">			&#125;</div><div class="line">			return target[property]</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">const rootFolder = new Folder()</div><div class="line">try &#123;</div><div class="line">	rootFolder.ninjasDir.firstNinjaDir.ninjaFile = &apos;yoshi.txt&apos;</div><div class="line">&#125;catch(e)&#123;</div><div class="line">	console.log(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用代理实现数组负引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function creatNegativeArrayProxy(array)&#123;</div><div class="line">	if(!Array.isArray(array))&#123;</div><div class="line">		throw new TypeError(&apos;expected an array&apos;)</div><div class="line">	&#125;</div><div class="line">	return new Proxy(array,&#123;</div><div class="line">		get:(target,index)=&gt;&#123;</div><div class="line">			index = +index</div><div class="line">			return target[index&lt;0?target.length+index:index]</div><div class="line">		&#125;,</div><div class="line">		set:(target,index,val)=&gt;&#123;</div><div class="line">			index = +index</div><div class="line">			return target[index&lt;0?target.length+index:index] = val</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">const ninja = [1,2,3]</div><div class="line">const proxi = creatNegativeArrayProxy(ninja)</div><div class="line">console.log(proxi[-1]) //==&gt; 3</div><div class="line">proxi[-2] = 22 // ninja ==&gt;1,22,3</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理是JS es6中引入，可用于控制对象&lt;br&gt;—代理可以定制对象交互时行动（例如，当读取属性或调用方法）&lt;br&gt;— 所有交互行为都必须通过代理，指定的行为发生时会调用代理方法&lt;br&gt;使用代理可以优雅实现以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志记录&lt;/li&gt;
&lt;li&gt;性能测
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>absolute应用</title>
    <link href="http://yoohannah.github.io/post/knowledge/cssPosition.html"/>
    <id>http://yoohannah.github.io/post/knowledge/cssPosition.html</id>
    <published>2019-09-22T23:54:58.000Z</published>
    <updated>2019-09-23T15:19:25.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-背景"><a href="#问题-背景" class="headerlink" title="问题/背景"></a>问题/背景</h1><p>table 的 td 内容在内容较多时会自动进行省略处理，然后鼠标滑过弹层显示具体内容</p>
<p>td内容还可以配置在线编辑，鼠标滑过，可以显示小笔图标，点击小笔图标或者td块都可以进行在线编辑然后回车或者鼠标点击输入框之外的地方都可以提交发送给后台</p>
<p>table被包裹在一个div1中,只允许出现水平方向滚动条，不出现垂直方向滚动条<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.div1&#123;</div><div class="line">  overflow-x: auto;</div><div class="line">  overflow-y: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出现的问题就是，如果最后几行的内容过多，弹层显示具体内容时弹层会被遮挡，不能正常飘出来<br><img src="/image/position1.png" alt="position1.png"></p>
<h1 id="原理知识"><a href="#原理知识" class="headerlink" title="原理知识"></a>原理知识</h1><p>父元素设置position:relative,子元素设置position:absolute,配套使用时，子元素才会会在z轴上相对父元素进行xy面的定位<br>如果最近父元素没有设置position:relative，那么会往父元素的父元素找，看是否设置，如果设置，则相对爷爷元素进行XY面定位，如果没有继续往上找，以此类推<br>即会相对父元素及以上元素中靠近自己最近的，设置了position:relative的长辈元素进行相对定位</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>弹层没有按照预期可以弹到div1以外的地方,被困在div1里面，加上div1不能垂直方向滚动，说明弹层没有相对div1定位,<br>解除div1垂直方向的滚动限制，弹层把div1在垂直方向上撑起来了，滚动滚动条，可以看完整的弹层内容，说明弹层相对div1的子元素定位了，<br>即从盛装省略内容的标签到div1的标签中，有标签设置了position:relative，</p>
<p>通过查找发现，在线编辑功能的小笔图标使用了position:absolute相对定位，在它最近的div2标签上设置了position:relative，<br>而div2标签包含了弹层所在标签，属于div1子元素，所以弹层就会相对div2定位，沿Z轴飘在div2这一层上面，就弹不到div1以外了</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>将div2上position:relative去掉，给在线编辑功能的小笔图标设置position:absolute的标签div3外加div4,设置position:relative</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">解决前：</div><div class="line">&lt;div1 style=&apos;position:relative&apos;&gt;</div><div class="line">  &lt;table&gt;</div><div class="line">    &lt;tbody&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">      &lt;td&gt;</div><div class="line">      &lt;div2 style=&apos;position:relative&apos;&gt;</div><div class="line">        &lt;div3 style=&quot;position:absolute&quot;&gt;&lt;i class=&quot;fa fa-pencil&quot; &gt;&lt;/i&gt;&lt;/div3&gt;</div><div class="line">        &lt;popwindow&gt;具体内容&lt;/popwindow&gt; /** 组件弹窗div设置有position:absolute**/</div><div class="line">      &lt;/div2&gt;</div><div class="line">      &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;/tbody&gt;</div><div class="line">  &lt;/table&gt;</div><div class="line">&lt;/div1&gt;</div><div class="line"></div><div class="line">解决后：</div><div class="line">&lt;div1 style=&apos;position:relative&apos;&gt;</div><div class="line">  &lt;table&gt;</div><div class="line">    &lt;tbody&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">      &lt;td&gt;</div><div class="line">      &lt;div2&gt;</div><div class="line">        &lt;div4 style=&apos;position:relative&apos;&gt;</div><div class="line">          &lt;div3 style=&quot;position:absolute&quot;&gt;&lt;i class=&quot;fa fa-pencil&quot; &gt;&lt;/i&gt;&lt;/div3&gt;</div><div class="line">        &lt;/div4&gt;</div><div class="line">        &lt;popwindow&gt;具体内容&lt;/popwindow&gt; /** 组件弹窗div设置有position:absolute**/</div><div class="line">      &lt;/div2&gt;</div><div class="line">      &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;/tbody&gt;</div><div class="line">  &lt;/table&gt;</div><div class="line">&lt;/div1&gt;</div></pre></td></tr></table></figure>
<p>普通省略内容鼠标滑过<br><img src="/image/position2.png" alt="position2.png"><br>在线编辑内容省略时，鼠标滑过<br><img src="/image/position3.png" alt="position3.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题-背景&quot;&gt;&lt;a href=&quot;#问题-背景&quot; class=&quot;headerlink&quot; title=&quot;问题/背景&quot;&gt;&lt;/a&gt;问题/背景&lt;/h1&gt;&lt;p&gt;table 的 td 内容在内容较多时会自动进行省略处理，然后鼠标滑过弹层显示具体内容&lt;/p&gt;
&lt;p&gt;td内容还可以
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>webpack原理</title>
    <link href="http://yoohannah.github.io/post/performance/webpackTheory.html"/>
    <id>http://yoohannah.github.io/post/performance/webpackTheory.html</id>
    <published>2019-07-14T09:17:02.000Z</published>
    <updated>2019-07-20T02:50:32.008Z</updated>
    
    <content type="html"><![CDATA[<p>bundle.js能直接运行在浏览器中的原因是：<br>在输出文件中通过<strong>webpack_require</strong>函数，定义了一个可以在浏览器中执行的加载函数，来模拟Nodejs中的require语句</p>
<p><strong>webpack_require</strong> 函数将所有模块挂载一个对象上，通过判断该对象是否存在该模块实现模块缓存，防止二次加载</p>
<p>原来一个个独立的模块文件被合并到了一个单独的bundle.js的原因是<br>浏览器不能像Nodejs那样快速的在本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件，<br>如果模块的数量很多，则加载时间会很长，因此将所有模块都存放在了数组中，执行一次网络加载<br><a href="https://github.com/YooHannah/algorithm/blob/master/webpack/outputFile.js" target="_blank" rel="external">输出文件分析</a></p>
<h1 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h1><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="获取loader配置的options"><a href="#获取loader配置的options" class="headerlink" title="获取loader配置的options"></a>获取loader配置的options</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const loaderUtils = require(&apos;loader-utils&apos;)</div><div class="line">module.exports = function(source)&#123;</div><div class="line">	//获取用户为当前loader传入的options</div><div class="line">	const options = loaderUtils.getOptions(this)</div><div class="line">	return source</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回除了内容之外的东西"><a href="#返回除了内容之外的东西" class="headerlink" title="返回除了内容之外的东西"></a>返回除了内容之外的东西</h3><p>this.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。 this.callback 的详细使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.callback( </div><div class="line">    // 当无法转换原内容时，给 Webpack 返回一个 Error </div><div class="line">    err: Error | null, </div><div class="line">    // 原内容转换后的内容 </div><div class="line">    content: string | Buffer, </div><div class="line">    // 用于把转换后的内容得出原内容的 Source Map，方便调试 </div><div class="line">    sourceMap?: SourceMap, </div><div class="line">    // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， </div><div class="line">    // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 </div><div class="line">    abstractSyntaxTree?: AST </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>实例：用 babel-loader 转换 ES6 代码为例，它还需要输出转换后的 ES5 代码对应的 Source Map，以方便调试源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">  // 通过 this.callback 告诉 Webpack 返回的结果 </div><div class="line">  this.callback(null, source, sourceMaps); </div><div class="line">  // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， </div><div class="line">  // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中  </div><div class="line">  return; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Source Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。 为此 Webpack 为 Loader 提供了 this.sourceMap API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。</p>
<h3 id="处理异步流程"><a href="#处理异步流程" class="headerlink" title="处理异步流程"></a>处理异步流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">    // 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果 </div><div class="line">    var callback = this.async(); </div><div class="line">    someAsyncOperation(source, function(err, result, sourceMaps, ast) &#123; </div><div class="line">        // 通过 callback 返回异步执行后的结果 </div><div class="line">        callback(err, result, sourceMaps, ast); </div><div class="line">    &#125;); </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="处理二进制数据"><a href="#处理二进制数据" class="headerlink" title="处理二进制数据"></a>处理二进制数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">    // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 </div><div class="line">    source instanceof Buffer === true; </div><div class="line">    // Loader 返回的类型也可以是 Buffer 类型的 </div><div class="line">    // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 </div><div class="line">    return source; </div><div class="line">&#125;; </div><div class="line">// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据  </div><div class="line">module.exports.raw = true; //没有该行 Loader 只能拿到字符串。</div></pre></td></tr></table></figure>
<h3 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h3><p>在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。 为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时， 是不会重新调用对应的 Loader 去执行转换操作的。<br>如果想让Webpack 不缓存该 Loader 的处理结果，可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">  // 关闭该 Loader 的缓存功能 </div><div class="line">  this.cacheable(false); </div><div class="line">  return source; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><p>this.context：当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src。</p>
<p>this.resource：当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。</p>
<p>this.resourcePath：当前处理文件的路径，例如 /src/main.js。</p>
<p>this.resourceQuery：当前处理文件的 querystring。</p>
<p>this.target：等于 Webpack 配置中的 Target。</p>
<p>this.loadModule：当 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果。</p>
<p>this.resolve：像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string))。</p>
<p>this.addDependency：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string)。</p>
<p>this.addContextDependency：和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string)。</p>
<p>this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为 clearDependencies()。</p>
<p>this.emitFile：输出一个文件，使用方法为 emitFile(name: string, content: Buffer|string, sourceMap: {…})。</p>
<h2 id="加载本地loader"><a href="#加载本地loader" class="headerlink" title="加载本地loader"></a>加载本地loader</h2><h3 id="方法一-Npm-link"><a href="#方法一-Npm-link" class="headerlink" title="方法一 Npm link"></a>方法一 Npm link</h3><p>Npm link 专门用于开发和调试本地 Npm 模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 Npm 模块。 由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。</p>
<p>完成 Npm link 的步骤如下：</p>
<p>1.确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 package.json 已经正确配置好；<br>2.在本地 Npm 模块根目录下执行 npm link，把本地模块注册到全局；<br>3.在项目根目录下执行 npm link loader-name，把第2步注册到全局的本地 Npm 模块链接到项目的 node_moduels 下，其中的 loader-name 是指在第1步中的 package.json 文件中配置的模块名称。</p>
<p>链接好 Loader 到项目后就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了。</p>
<h3 id="方法二-ResolveLoader"><a href="#方法二-ResolveLoader" class="headerlink" title="方法二 ResolveLoader"></a>方法二 ResolveLoader</h3><p>ResolveLoader用于配置 Webpack 如何寻找 Loader,默认情况下只会去 node_modules 目录下寻找，为了让 Webpack 加载放在本地项目中的 Loader 需要修改 resolveLoader.modules。<br>假如本地的 Loader 在项目目录中的 ./loaders/loader-name 中，则需要如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123; </div><div class="line">  resolveLoader:&#123; </div><div class="line">    // 去哪些目录下寻找 Loader，有先后顺序之分 </div><div class="line">    modules: [&apos;node_modules&apos;,&apos;./loaders/&apos;], </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>plugin内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class BasicPlugin&#123; </div><div class="line">  // 在构造函数中获取用户给该插件传入的配置 </div><div class="line">  constructor(options)&#123; </div><div class="line">  &#125; </div><div class="line"> </div><div class="line">  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象 </div><div class="line">  apply(compiler)&#123; </div><div class="line">    compiler.plugin(&apos;compilation&apos;,function(compilation) &#123; </div><div class="line">    &#125;) </div><div class="line">  &#125; </div><div class="line">&#125; </div><div class="line"> </div><div class="line">// 导出 Plugin </div><div class="line">module.exports = BasicPlugin;</div></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const BasicPlugin = require(&apos;./BasicPlugin.js&apos;); </div><div class="line">module.export = &#123; </div><div class="line">  plugins:[ </div><div class="line">    new BasicPlugin(options), </div><div class="line">  ] </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Webpack 启动后，在读取配置的过程中会先执行 new BasicPlugin(options) 初始化一个 BasicPlugin 获得其实例。 在初始化 compiler 对象后，再调用 basicPlugin.apply(compiler) 给插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。</p>
<h2 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a>Compiler 和 Compilation</h2><p>Compiler 和 Compilation 的含义如下：</p>
<p>1.Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</p>
<p>2.Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</p>
<p>Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。<br>Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p>
<p>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。 Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/ </div><div class="line"> 广播出事件 </div><div class="line"> event-name 为事件名称，注意不要和现有的事件重名 </div><div class="line"> params 为附带的参数 </div><div class="line">/ </div><div class="line">compiler.apply(&apos;event-name&apos;,params); </div><div class="line"> </div><div class="line">/ </div><div class="line"> 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。 </div><div class="line"> 同时函数中的 params 参数为广播事件时附带的参数。 </div><div class="line">*/ </div><div class="line">compiler.plugin(&apos;event-name&apos;,function(params) &#123; </div><div class="line"> </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>compilation.apply 和 compilation.plugin 使用方法和上面一致。</p>
<p>在开发插件时，还需要注意以下两点：</p>
<p>1.只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。<br>2.传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。<br>3.有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;emit&apos;,function(compilation, callback) &#123; </div><div class="line">    // 支持处理逻辑 </div><div class="line"> </div><div class="line">    // 处理完毕后执行 callback 以通知 Webpack  </div><div class="line">    // 如果不执行 callback，运行流程将会一直卡在这不往下执行  </div><div class="line">    callback(); </div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<h2 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h2><h3 id="监听文件变化"><a href="#监听文件变化" class="headerlink" title="监听文件变化"></a>监听文件变化</h3><p> Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时， 就会触发一次新的 Compilation。<br> 通过【watch-run】 事件可以知道是哪个文件发生变化导致了新的 Compilation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/ 当依赖的文件发生变化时会触发 watch-run 事件 </div><div class="line">compiler.plugin(&apos;watch-run&apos;, (watching, callback) =&gt; &#123; </div><div class="line">    // 获取发生变化的文件列表 </div><div class="line">    const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes; </div><div class="line">    // changedFiles 格式为键值对，键为发生变化的文件路径。 </div><div class="line">    if (changedFiles[filePath] !== undefined) &#123; </div><div class="line">      // filePath 对应的文件发生了变化 </div><div class="line">    &#125; </div><div class="line">    callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。 由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。 为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;after-compile&apos;, (compilation, callback) =&gt; &#123; </div><div class="line">  // 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译 </div><div class="line">    compilation.fileDependencies.push(filePath); </div><div class="line">    callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="读取输出资源、代码块、模块及其依赖"><a href="#读取输出资源、代码块、模块及其依赖" class="headerlink" title="读取输出资源、代码块、模块及其依赖"></a>读取输出资源、代码块、模块及其依赖</h3><p>在 【emit】 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。 插件代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Plugin &#123; </div><div class="line">  apply(compiler) &#123; </div><div class="line">    compiler.plugin(&apos;emit&apos;, function (compilation, callback) &#123; </div><div class="line">      // compilation.chunks 存放所有代码块，是一个数组 </div><div class="line">      compilation.chunks.forEach(function (chunk) &#123; </div><div class="line">        // chunk 代表一个代码块 </div><div class="line">        // 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块 </div><div class="line">        chunk.forEachModule(function (module) &#123; </div><div class="line">          // module 代表一个模块 </div><div class="line">          // module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组 </div><div class="line">          module.fileDependencies.forEach(function (filepath) &#123; </div><div class="line">          &#125;); </div><div class="line">        &#125;); </div><div class="line"> </div><div class="line">        // Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件 </div><div class="line">        // 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时， </div><div class="line">        // 该 Chunk 就会生成 .js 和 .css 两个文件 </div><div class="line">        chunk.files.forEach(function (filename) &#123; </div><div class="line">          // compilation.assets 存放当前所有即将输出的资源 </div><div class="line">          // 调用一个输出资源的 source() 方法能获取到输出资源的内容 </div><div class="line">          let source = compilation.assets[filename].source(); </div><div class="line">        &#125;); </div><div class="line">      &#125;); </div><div class="line"> </div><div class="line">      // 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。 </div><div class="line">      // 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。 </div><div class="line">      callback(); </div><div class="line">    &#125;) </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="修改输出资源"><a href="#修改输出资源" class="headerlink" title="修改输出资源"></a>修改输出资源</h3><p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 emit 事件，因为发生 emit 事件时所有模块的转换和代码块对应的文件已经生成好， 需要输出的资源即将输出，因此 emit 事件是修改 Webpack 输出资源的最后时机。</p>
<p>所有需要输出的资源会存放在 compilation.assets 中，compilation.assets 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。</p>
<p>设置 compilation.assets 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;emit&apos;, (compilation, callback) =&gt; &#123; </div><div class="line">  // 设置名称为 fileName 的输出资源 </div><div class="line">  compilation.assets[fileName] = &#123; </div><div class="line">    // 返回文件内容 </div><div class="line">    source: () =&gt; &#123; </div><div class="line">      // fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer </div><div class="line">      return fileContent; </div><div class="line">      &#125;, </div><div class="line">    // 返回文件大小 </div><div class="line">      size: () =&gt; &#123; </div><div class="line">      return Buffer.byteLength(fileContent, &apos;utf8&apos;); </div><div class="line">    &#125; </div><div class="line">  &#125;; </div><div class="line">  callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>读取 compilation.assets 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;emit&apos;, (compilation, callback) =&gt; &#123; </div><div class="line">  // 读取名称为 fileName 的输出资源 </div><div class="line">  const asset = compilation.assets[fileName]; </div><div class="line">  // 获取输出资源的内容 </div><div class="line">  asset.source(); </div><div class="line">  // 获取输出资源的文件大小 </div><div class="line">  asset.size(); </div><div class="line">  callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="判断-Webpack-使用了哪些插件"><a href="#判断-Webpack-使用了哪些插件" class="headerlink" title="判断 Webpack 使用了哪些插件"></a>判断 Webpack 使用了哪些插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 判断当前配置是否使用了 ExtractTextPlugin， </div><div class="line">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数 </div><div class="line">function hasExtractTextPlugin(compiler) &#123; </div><div class="line">  // 当前配置所有使用的插件列表 </div><div class="line">  const plugins = compiler.options.plugins; </div><div class="line">  // 去 plugins 中寻找有没有 ExtractTextPlugin 的实例 </div><div class="line">  return plugins.find(plugin=&gt;plugin.proto.constructor === ExtractTextPlugin) != null; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class EndWebpackPlugin &#123; </div><div class="line"> </div><div class="line">  constructor(doneCallback, failCallback) &#123; </div><div class="line">    // 存下在构造函数中传入的回调函数 </div><div class="line">    this.doneCallback = doneCallback; </div><div class="line">    this.failCallback = failCallback; </div><div class="line">  &#125; </div><div class="line"> </div><div class="line">  apply(compiler) &#123; </div><div class="line">    //done：在成功构建并且输出了文件后，Webpack 即将退出时发生；</div><div class="line">    compiler.plugin(&apos;done&apos;, (stats) =&gt; &#123; </div><div class="line">        // 在 done 事件中回调 doneCallback </div><div class="line">        this.doneCallback(stats); </div><div class="line">    &#125;); </div><div class="line">    //failed：在构建出现异常导致构建失败，Webpack 即将退出时发生；</div><div class="line">    compiler.plugin(&apos;failed&apos;, (err) =&gt; &#123; </div><div class="line">        // 在 failed 事件中回调 failCallback </div><div class="line">        this.failCallback(err); </div><div class="line">    &#125;); </div><div class="line">  &#125; </div><div class="line">&#125; </div><div class="line">// 导出插件  </div><div class="line">module.exports = EndWebpackPlugin; </div><div class="line"></div><div class="line">//使用</div><div class="line">module.exports = &#123; </div><div class="line">  plugins:[ </div><div class="line">    // 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数； </div><div class="line">    new EndWebpackPlugin(() =&gt; &#123; </div><div class="line">      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作 </div><div class="line">    &#125;, (err) =&gt; &#123; </div><div class="line">      // Webpack 构建失败，err 是导致错误的原因 </div><div class="line">      console.error(err);    &#125;) </div><div class="line">  ] </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<p>1.初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>（启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。）<br>2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>3.确定入口：根据配置中的 entry 找出所有的入口文件；<br>4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>
<h2 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h2><p>1.初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。<br>2.编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。<br>3.输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。</p>
<h2 id="初始化阶段事"><a href="#初始化阶段事" class="headerlink" title="初始化阶段事"></a>初始化阶段事</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>初始化参数</td><td>从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 <code>new Plugin()</code>。</td></tr><tr><td>实例化 Compiler</td><td>用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。</td></tr><tr><td>加载插件</td><td>依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。</td></tr><tr><td>environment</td><td>开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。</td></tr><tr><td>entry-option</td><td>读取配置的 Entrys，为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备。</td></tr><tr><td>after-plugins</td><td>调用完所有内置的和配置的插件的 apply 方法。</td></tr><tr><td>after-resolvers</td><td>根据配置初始化完 resolver，resolver 负责在文件系统中寻找指定路径的文件。</td></tr></tbody></table>

<h2 id="编译阶段事件"><a href="#编译阶段事件" class="headerlink" title="编译阶段事件"></a>编译阶段事件</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>build-module</td><td>使用对应的 Loader 去转换一个模块。</td></tr><tr><td>normal-module-loader</td><td>在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。</td></tr><tr><td>program</td><td>从配置的入口模块开始，分析其 AST，当遇到 <code>require</code> 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</td></tr><tr><td>seal</td><td>所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk</td></tr></tbody></table>

<h2 id="输出阶段事件"><a href="#输出阶段事件" class="headerlink" title="输出阶段事件"></a>输出阶段事件</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>should-emit</td><td>所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td></tr><tr><td>emit</td><td>确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td></tr><tr><td>after-emit</td><td>文件输出完毕。</td></tr><tr><td>done</td><td>成功完成一次完成的编译和输出流程。</td></tr><tr><td>failed</td><td>如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td></tr></tbody></table>

<p>在输出阶段已经得到了各个模块经过转换后的结果和其依赖关系，并且把相关模块组合在一起形成一个个 Chunk。 在输出阶段会根据 Chunk 的类型，使用对应的模版生成最终要要输出的文件内容</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bundle.js能直接运行在浏览器中的原因是：&lt;br&gt;在输出文件中通过&lt;strong&gt;webpack_require&lt;/strong&gt;函数，定义了一个可以在浏览器中执行的加载函数，来模拟Nodejs中的require语句&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;webpack_re
    
    </summary>
    
    
      <category term="performance" scheme="http://yoohannah.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化</title>
    <link href="http://yoohannah.github.io/post/performance/webpackOptimization.html"/>
    <id>http://yoohannah.github.io/post/performance/webpackOptimization.html</id>
    <published>2019-06-29T08:21:02.000Z</published>
    <updated>2019-07-20T02:07:21.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化开发体验"><a href="#优化开发体验" class="headerlink" title="优化开发体验"></a>优化开发体验</h1><p>目的是提升开发效率</p>
<h2 id="优化构建速度"><a href="#优化构建速度" class="headerlink" title="优化构建速度"></a>优化构建速度</h2><p>解决项目庞大时构建的耗时加长的问题</p>
<h3 id="缩小文件查找范围"><a href="#缩小文件查找范围" class="headerlink" title="缩小文件查找范围"></a>缩小文件查找范围</h3><p>1.由于Loader对文件转换很耗时，所以应该让尽可能少的文件被处理，适当调整项目目录结构，在配置loader时通过【include】属性缩小处理命中文件范围<br>2.当安装第三方模块都放在项目根目录的./node_module目录下时，通过指明【resolve.modules】为存放第三方模块的绝对路径，减少寻找第三方模块的递归查找<br>3.在项目中所有第三方模块都采用main字段去描述入口文件时，只给【resolve.mainFileds】配置main字段，不使用默认值，减少搜索步骤<br>4.使用【resolve.alias】进行路径映射时，将导入模块的语句，替换成直接使用模块中完整文件的语句，减少耗时的对于lib中文件的解析工作<br>5.优化【resolve.extension】配置，减少尝试次数<br>a.后缀列表尽可能小，不要将项目中不可能存在的情况写到后缀列表中<br>b.频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程<br>c.在源码中写导入语句时，尽可能带上后缀，从而避免寻找过程<br>6.合理使用【module.noparse】属性，排除不需要进行模块解析处理的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.</div><div class="line">rules:&#123;</div><div class="line">	//只对项目根目录下src目录中文件采用配置的loader</div><div class="line">	include:path.resolve(__dirname,&apos;src&apos;)</div><div class="line">&#125;</div><div class="line">2.</div><div class="line">resolve:&#123;</div><div class="line">	//使用绝对路径指明第三方模块存放的位置，减少搜索步骤</div><div class="line">	modules:[path.resolve(__dirname,&apos;node_module&apos;)]</div><div class="line">&#125;</div><div class="line">3.</div><div class="line">resolve:&#123;</div><div class="line">	//减少入口查找</div><div class="line">	mainFilds:[&apos;main&apos;]</div><div class="line">&#125;</div><div class="line">4.</div><div class="line">resolve:&#123;</div><div class="line">	//减少第三方模块递归解析</div><div class="line">	alias:&#123; </div><div class="line">		&apos;react&apos;:path.resolve(__dirname,&apos;./node_module/react/dist/react.min.js&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用DLLPlugin"><a href="#使用DLLPlugin" class="headerlink" title="使用DLLPlugin"></a>使用DLLPlugin</h3><p>一个动态链接库文件可以包含为其他模块调用的函数和数据<br>提升构建速度的原理：<br>包含大量复用模块的动态链接库只需被编译一次，在之后的构建过程中被动态链接库包含的模块将不会重新编译，而是直接使用动态链接库的代码，<br>由于动态链接库中大多数包含的是常用的第三方模块，例如react,react-dom,所以只要不升级这些模块的版本，动态连接库就不用重新编译</p>
<p>DllPlugin:打包出一个个单独的动态链接库文件<br>DllReferencePlugin:用于在主要的配置文件中引入DllPlugin打包好的动态连接库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">//webpack_dll.config.js</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const DllPlugin = require(&apos;webpack/lib/DllPlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &#123;</div><div class="line">    // 把 React 相关的放到一个单独的动态链接库</div><div class="line">    react: [&apos;react&apos;, &apos;react-dom&apos;],</div><div class="line">    // 把项目需要所有的 polyfill 放到一个单独的动态链接库</div><div class="line">    polyfill: [&apos;core-js/fn/object/assign&apos;, &apos;core-js/fn/promise&apos;, &apos;whatwg-fetch&apos;],</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，也就是 entry 中配置的 react 和 polyfill</div><div class="line">    filename: &apos;[name].dll.js&apos;,</div><div class="line">    // 输出的文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react</div><div class="line">    // 之所以在前面加上 _dll_ 是为了防止全局变量冲突</div><div class="line">    library: &apos;_dll_[name]&apos;,</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 接入 DllPlugin</div><div class="line">    new DllPlugin(&#123;</div><div class="line">      // 动态链接库的全局变量名称，需要和 output.library 中保持一致</div><div class="line">      // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</div><div class="line">      // 例如 react.manifest.json 中就有 &quot;name&quot;: &quot;_dll_react&quot;</div><div class="line">      name: &apos;_dll_[name]&apos;,</div><div class="line">      // 描述动态链接库的 manifest.json 文件输出时的文件名称</div><div class="line">      path: path.join(__dirname, &apos;dist&apos;, &apos;[name].manifest.json&apos;),</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">webpack_dll.config.js文件中，DllPlugin中的name参数必须和output</div><div class="line"></div><div class="line">//webpack.config.js</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const DllReferencePlugin = require(&apos;webpack/lib/DllReferencePlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    // 定义 入口 Chunk</div><div class="line">    main: &apos;./main.js&apos;</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 输出文件的名称</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    // 输出文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        // 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 告诉 Webpack 使用了哪些动态链接库</div><div class="line">    new DllReferencePlugin(&#123;</div><div class="line">      // 描述 react 动态链接库的文件内容</div><div class="line">      manifest: require(&apos;./dist/react.manifest.json&apos;),</div><div class="line">    &#125;),</div><div class="line">    new DllReferencePlugin(&#123;</div><div class="line">      // 描述 polyfill 动态链接库的文件内容</div><div class="line">      manifest: require(&apos;./dist/polyfill.manifest.json&apos;),</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">  devtool: &apos;source-map&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>执行构建流程：<br>先编译出动态链接库相关的文件，执行webpack –config webpack_dll.config.js<br>在确保动态链接库存在时才能正常编译入口文件，webpack.config.js中的DllReferencePlugin会依赖动态链接库相关文件，执行webpack命令</p>
<h3 id="使用HappyPack"><a href="#使用HappyPack" class="headerlink" title="使用HappyPack"></a>使用HappyPack</h3><p>提升构建速度原理：<br>将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程，从而让webpack在同一时刻处理多个任务<br>实际表现就是<br>所有通过Loader处理的文件都先交给happypack/loader去处理，在收集到这些文件的处理权后，HappyPack就可以统一分配了<br>每通过new HappyPack() 去实例化一个HappyPack,其实就是告诉HappyPack核心调度器如何通过一系列Loader去转换一类文件，<br>并且可以指定如何为这类转换操作分配子进程<br>核心调度器的逻辑代码在主进程中，也就是运行着webpack的进程中，核心调度器会将一个个任务分配给当前空闲的子进程，<br>子进程处理完毕后将结果发送给核心调度，他们之间的数据交换是通过进程间的通信API实现的<br>核心调度器收到来自子进程处理完毕的结果后，会通知WebPack该文件已处理完毕</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line">const HappyPack = require(&apos;happypack&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &#123;</div><div class="line">    main: &apos;./main.js&apos;,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 把所有依赖的模块合并输出到一个 bundle.js 文件</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    // 输出文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例</div><div class="line">        use: [&apos;happypack/loader?id=babel&apos;],</div><div class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</div><div class="line">        test: /\.css$/,</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          use: [&apos;happypack/loader?id=css&apos;],</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new HappyPack(&#123;</div><div class="line">      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</div><div class="line">      id: &apos;babel&apos;,</div><div class="line">      // 如何处理 .js 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;babel-loader?cacheDirectory&apos;],</div><div class="line">    &#125;),</div><div class="line">    new HappyPack(&#123;</div><div class="line">      id: &apos;css&apos;,</div><div class="line">      // 如何处理 .css 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;css-loader&apos;],</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name].css`,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">  devtool: &apos;source-map&apos; // 输出 source-map 方便直接调试 ES6 源码</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在实例化 HappyPack 插件的时候，除了可以传入 id 和 loaders 两个参数外，HappyPack 还支持如下参数：<br>threads: 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数。<br>verbose: 是否允许 HappyPack 输出日志，默认是 true。<br>threadPool :代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const HappyPack = require(&apos;happypack&apos;);</div><div class="line">// 构造出共享进程池，进程池中包含5个子进程</div><div class="line">const happyThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">    new HappyPack(&#123;</div><div class="line">      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</div><div class="line">      id: &apos;babel&apos;,</div><div class="line">      // 如何处理 .js 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;babel-loader?cacheDirectory&apos;],</div><div class="line">      // 使用共享进程池中的子进程去处理任务</div><div class="line">      threadPool: happyThreadPool,</div><div class="line">    &#125;),</div><div class="line">    new HappyPack(&#123;</div><div class="line">      id: &apos;css&apos;,</div><div class="line">      // 如何处理 .css 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;css-loader&apos;],</div><div class="line">      // 使用共享进程池中的子进程去处理任务</div><div class="line">      threadPool: happyThreadPool,</div><div class="line">     &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name].css`,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="使用ParallelUglifyPlugin"><a href="#使用ParallelUglifyPlugin" class="headerlink" title="使用ParallelUglifyPlugin"></a>使用ParallelUglifyPlugin</h3><p>提升构建速度原理：<br>当webpack有多个JS文件需要输出和压缩时，原本会使用UglifyJS去一个一个压缩再输出，但是ParallelUglifyPlugin会开启多个子进程，<br>将对多个文件的压缩工作分配给多个子进程完成，每个子进程其实还是通过UglifyJS去压缩代码，单变成了并行执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">const path = require(‘path’);</div><div class="line">const DefinePlugin = require(‘webpack/lib/DefinePlugin’);</div><div class="line">const ParallelUglifyPlugin = require(‘webpack-parallel-uglify-plugin’);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">    // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</div><div class="line">    new ParallelUglifyPlugin(&#123;</div><div class="line">      // 传递给 UglifyJS 的参数</div><div class="line">      uglifyJS: &#123;</div><div class="line">        output: &#123;</div><div class="line">          // 最紧凑的输出</div><div class="line">          beautify: false,</div><div class="line">          // 删除所有的注释</div><div class="line">          comments: false,</div><div class="line">        &#125;,</div><div class="line">        compress: &#123;</div><div class="line">          // 在UglifyJs删除没有用到的代码时不输出警告</div><div class="line">          warnings: false,</div><div class="line">          // 删除所有的 console 语句，可以兼容ie浏览器</div><div class="line">          drop_console: true,</div><div class="line">          // 内嵌定义了但是只用到一次的变量</div><div class="line">          collapse_vars: true,</div><div class="line">          // 提取出出现多次但是没有定义成变量去引用的静态值</div><div class="line">          reduce_vars: true,</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在通过 new ParallelUglifyPlugin() 实例化时，支持以下参数：<br>test：使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 /.js$/，也就是默认压缩所有的 .js 文件。<br>include：使用正则去命中需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。<br>exclude：使用正则去命中不需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。<br>cacheDir：缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。<br>workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。<br>sourceMap：是否输出 Source Map，这会导致压缩过程变慢。<br>uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。</p>
<p>其中的 test、include、exclude 与配置 Loader 时的思想和用法一样<br>UglifyES 是 UglifyJS 的变种，专门用于压缩 ES6 代码，它们两都出自于同一个项目，并且它们两不能同时使用。<br>UglifyES 一般用于给比较新的 JavaScript 运行环境压缩代码，例如用于 ReactNative 的代码运行在兼容性较好的 JavaScriptCore 引擎中，为了得到更好的性能和尺寸，采用 UglifyES 压缩效果会更好。<br>ParallelUglifyPlugin 同时内置了 UglifyJS 和 UglifyES，也就是说 ParallelUglifyPlugin 支持并行压缩 ES6 代码。<br>如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。</p>
<h2 id="优化使用体验"><a href="#优化使用体验" class="headerlink" title="优化使用体验"></a>优化使用体验</h2><p>通过自动化手段完成一些重复工作，让我们专注于解决问题本身</p>
<h3 id="优化文件监听"><a href="#优化文件监听" class="headerlink" title="优化文件监听"></a>优化文件监听</h3><p>通过配置watchOption进行优化<br>ignored:/node_module/ 不监听node_module下文件 监听更少文件<br>agregatetionTimeout:值越大，降低构建频率<br>poll:值越小，降低检查频率<br>后面两项的配置会使监听模式的反应和灵敏度降低</p>
<h3 id="优化自动刷新性能"><a href="#优化自动刷新性能" class="headerlink" title="优化自动刷新性能"></a>优化自动刷新性能</h3><p>1.使用devserver开启inline时，devserver因为不知道某个网页依赖哪几个Chunk,所以会向每个输出的chunk中注入代理客户端代码<br>当项目输出多个chunk时，就会导致构建缓慢，因此关闭inline进行优化<br>如果不想以iframe方式去访问，但同时想让网页保持自动刷新功能，则需要手动向网页中注入代理客户端的脚本，<br>向index.html中注入webpack-dev-server.js,但要注意发布到线上时要删掉这段用于开发的代码</p>
<p>2.开启热替换时，控制台打印信息不能标明模块信息，可以使用NameModulesPlugin插件解决，从而在控制台打印出被修改的模块名称<br>注意关闭默认inline模式并手动注入客户端的方法，不能用于模块热替换的情况，原因在于模块热替换的运行依赖每个chunk中都包含代理客户端的代码</p>
<h1 id="优化输出质量"><a href="#优化输出质量" class="headerlink" title="优化输出质量"></a>优化输出质量</h1><p>目的是为用户呈现体验更好的网页</p>
<h2 id="减少用户能够感知到的加载时间-首屏时间"><a href="#减少用户能够感知到的加载时间-首屏时间" class="headerlink" title="减少用户能够感知到的加载时间(首屏时间)"></a>减少用户能够感知到的加载时间(首屏时间)</h2><h3 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h3><p>问题：<br>开发过程会涉及到调试的代码,没必要发到线上给到用户<br>开发环境和线上接口地址不同，使用不同环境数据<br>线上代码会进行压缩，开发代码不需要、</p>
<p>解决：<br>当代码中使用了process模块的语句时，webpack会自动打包加入process模块代码来支持非nodejs运行环境<br>当代码中没有使用时，就不会打包加入<br>可以在源码中使用process.env.NODE_ENV环境变量去判断执行开发/线上环境的代码<br>环境变量的设置通过DefinePlugin设置<br>设置后，环境变量的值在webpack处理过程中会被代入源码中，替换掉process.env.NODE_ENV<br>访问proces的语句被替换，webpack也就不会在打包时加入process模块了</p>
<p>注意：DefinedPlugin定义的环境变量只对Webpack需要处理的代码有效，而不会影响Nodejs运行时的环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">    new DefinePlugin(&#123;</div><div class="line">      // 定义 NODE_ENV 环境变量为 production </div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)//环境变量的值需要一个由双引号包裹的字符串&apos;&quot;production&quot;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>提升网页加载速度，减少网络传输流量，混淆代码以防有人下载代码进行代码分析和改造<br>通过插件形式引入UglifyJs，利用UglifyJs分析JS代码语法树，理解代码含义，<br>从而去掉无效代码，去掉日志输出代码，缩短变量名等优化,仅用于es5<br>UglifyJsPlugin:封装UglifyJs实现压缩<br>ParallelUglifyPlugin：多进行并行处理压缩<br>uglifyjsWebpackPlugin:引入UglifyES，压缩es6，要去掉.babelrc文件中的babel-preset-env，否则会将es6转es5<br>css-loader?minimize:压缩CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">1.UglifyJsPlugin</div><div class="line">const UglifyJSPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);//使用内置插件</div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">     new UglifyJSPlugin(&#123;</div><div class="line">      compress: &#123;</div><div class="line">        // 在 UglifyES 删除没有用到的代码时不输出警告</div><div class="line">        warnings: false,</div><div class="line">        // 删除所有的 `console` 语句，可以兼容ie浏览器</div><div class="line">        drop_console: true,</div><div class="line">        // 内嵌定义了但是只用到一次的变量</div><div class="line">        collapse_vars: true,</div><div class="line">        // 提取出出现多次但是没有定义成变量去引用的静态值</div><div class="line">        reduce_vars: true,</div><div class="line">      &#125;,</div><div class="line">      output: &#123;</div><div class="line">        // 最紧凑的输出，默认会保留空格</div><div class="line">        beautify: false,</div><div class="line">        // 删除所有的注释</div><div class="line">        comments: false,</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">2.uglifyjs-webpack-plugin</div><div class="line">const UglifyESPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">     new UglifyESPlugin(&#123;</div><div class="line">      uglifyOptions: &#123;//相比UglifyJSPlugin 多了一层</div><div class="line">        compress: &#123;</div><div class="line">          // 在 UglifyES 删除没有用到的代码时不输出警告</div><div class="line">          warnings: false,</div><div class="line">          // 删除所有的 `console` 语句，可以兼容ie浏览器</div><div class="line">          drop_console: true,</div><div class="line">          // 内嵌定义了但是只用到一次的变量</div><div class="line">          collapse_vars: true,</div><div class="line">          // 提取出出现多次但是没有定义成变量去引用的静态值</div><div class="line">          reduce_vars: true,</div><div class="line">        &#125;,</div><div class="line">        output: &#123;</div><div class="line">          // 最紧凑的输出</div><div class="line">          beautify: false,</div><div class="line">          // 删除所有的注释</div><div class="line">          comments: false,</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">3.压缩CSS</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css/,// 增加对 CSS 文件的支持</div><div class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          use: [&apos;css-loader?minimize&apos;] // 压缩 CSS 代码</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 用 WebPlugin 生成对应的 HTML 文件</div><div class="line">    new WebPlugin(&#123;</div><div class="line">      template: &apos;./template.html&apos;, // HTML 模版文件所在的文件路径</div><div class="line">      filename: &apos;index.html&apos; // 输出的 HTML 的文件名称</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 hash 值</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="使用CDN加速"><a href="#使用CDN加速" class="headerlink" title="使用CDN加速"></a>使用CDN加速</h3><p>webpack接入CDN需要满足：<br>1.静态资源的导入URL需要变成指向CDN服务的绝对路径URL，而不是相对于HTML文件的URL<br>2.静态资源的文件名需要带上由文件内容算出来的Hash值，以防止被缓存<br>3.将不同类型资源放到不同域名CDN服务上，以防止资源的并行加载阻塞<br>实现主要依赖publicPath设置存放静态资源的CDN目录URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const UglifyJsPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</div><div class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    // Chunk app 的 JS 执行入口文件</div><div class="line">    app: &apos;./main.js&apos;</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 给输出的 JavaScript 文件名称加上 Hash 值</div><div class="line">    filename: &apos;[name]_[chunkhash:8].js&apos;,</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">    // 指定存放 JavaScript 文件的线上目录</div><div class="line">    publicPath: &apos;//js.cdn.com/id/&apos;,</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        // 增加对 CSS 文件的支持</div><div class="line">        test: /\.css/,</div><div class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          // 压缩 CSS 代码</div><div class="line">          use: [&apos;css-loader?minimize&apos;],</div><div class="line">          // 指定存放 CSS 中导入的资源（例如图片）的线上目录</div><div class="line">          publicPath: &apos;//img.cdn.com/id/&apos;</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        // 增加对 PNG 文件的支持</div><div class="line">        test: /\.png/,</div><div class="line">        // 给输出的 PNG 文件名称加上 Hash 值</div><div class="line">        use: [&apos;file-loader?name=[name]_[hash:8].[ext]&apos;],</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 使用 WebPlugin 自动生成 HTML，会根据publicPath用线上地址替换原来相对地址</div><div class="line">    new WebPlugin(&#123;</div><div class="line">      // HTML 模版文件所在的文件路径</div><div class="line">      template: &apos;./template.html&apos;,</div><div class="line">      // 输出的 HTML 的文件名称</div><div class="line">      filename: &apos;index.html&apos;,</div><div class="line">      // 指定存放 CSS 文件的线上目录</div><div class="line">      stylePublicPath: &apos;//css.cdn.com/id/&apos;,</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      // 给输出的 CSS 文件名称加上 Hash 值</div><div class="line">      filename: `[name]_[contenthash:8].css`,</div><div class="line">    &#125;),</div><div class="line">    new DefinePlugin(&#123;</div><div class="line">      // 定义 NODE_ENV 环境变量为 production 去除开发时才需要的部分</div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    // 压缩输出的 JS 代码</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="使用tree-Shaking剔除用不上的代码"><a href="#使用tree-Shaking剔除用不上的代码" class="headerlink" title="使用tree Shaking剔除用不上的代码"></a>使用tree Shaking剔除用不上的代码</h2><p>Tree Shaking可以分析出那些代码被用上了，哪些没有<br>Tree Shaking正常工作的前提是，提交给webpack的js代码必须采用了ES6的模块化语法，因为es6模块化语法是静态的<br>（在导入，导出语句中的路径必须是静态字符串，而且不能放入其他代码块中），这让webpack可以简单地分析出那些export被import了。<br>实现：<br>1.修改.babelrc文件，保留ES6语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;:[</div><div class="line">    [</div><div class="line">      &quot;env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;module&quot;:false//关闭模块转换功能，保留ES6语法</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以使用webpack –display-used-exports查看分析结果<br>2.使用uglifyJS剔除用不上的代码<br>可以在直接在配置文件中配置<br>也可以使用命令行执行<br>webpack –display-used-exports –optimize-minimize</p>
<p>处理但第三方库时，利用mainField告诉webpack采用那份入口文件，<br>当指定入口于文件采用es6模块化语法时，从而可以使用treeShaking进行代码优化</p>
<h3 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h3><p>问题：<br>相同资源被重复加载，浪费用户的流量和服务器成本<br>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验</p>
<p>解决：<br>将多个页面公共代码部分抽离成单独文件，用户在第一次访问后，公共文件代码被浏览器缓存<br>在用户切换其他页面时，则不会再重新加载存放公共代码的文件，而是直接从缓存中获取<br>从而<br>减少网络传输流量，降低服务器成本<br>虽然用户第一次打开网站的速度得不到优化，但之后访问其他页面的速度将提高</p>
<p>实现：<br>–根据网站所使用的技术栈，找出网站所有页面都需要用到的基础库(第三方库)，将他们提取到一个单独的文件base.js中<br>该文件包含了所有网页的基础运行环境，用于长期缓存，提高响应速度</p>
<p>–剔除了各个页面中被base.js包含的部分代码后，再找出所有页面都依赖的公共部分的代码，将他们提取到commom.js</p>
<p>–再为每个网页都生成一个单独的文件，不包含base.js和common.js中包含的部分，只包含各页面单独需要的部分代码</p>
<p>– 依赖CommonsChunkPlugin插件<br>CommonsChunkPlugin实例会生成一个新的Chunk，这个chunk中包含了被提取的代码<br>通过name属性告诉插件新生成的chunk的名称，chunks属性指明从哪些已有chunk中提取公共部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const UglifyJsPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</div><div class="line">const CommonsChunkPlugin = require(&apos;webpack/lib/optimize/CommonsChunkPlugin&apos;);</div><div class="line">const &#123;AutoWebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</div><div class="line"></div><div class="line">// 使用 AutoWebPlugin，自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用</div><div class="line">const autoWebPlugin = new AutoWebPlugin(&apos;pages&apos;, &#123;</div><div class="line">  template: &apos;./template.html&apos;, // HTML 模版文件所在的文件路径</div><div class="line">  // 提取出所有页面公共的代码</div><div class="line">  commonsChunk: &#123;</div><div class="line">    name: &apos;common&apos;,// 提取出公共代码 Chunk 的名称</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，</div><div class="line">  // autoWebPlugin.entry 方法可以获取到生成入口配置</div><div class="line">  entry: autoWebPlugin.entry(&#123;</div><div class="line">    // 这里可以加入你额外需要的 Chunk 入口</div><div class="line">    base: &apos;./base.js&apos;</div><div class="line">  &#125;),</div><div class="line">  output: &#123;</div><div class="line">    filename: &apos;[name]_[chunkhash:8].js&apos;,// 给输出的文件名称加上 hash 值</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.css/,// 增加对 CSS 文件的支持</div><div class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          use: [&apos;css-loader?minimize&apos;] // 压缩 CSS 代码</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    autoWebPlugin,</div><div class="line">    // 为了从 common 中提取出 base 也包含的部分,减小common体积</div><div class="line">    new CommonsChunkPlugin(&#123;</div><div class="line">      // 从 common 和 base 两个现成的 Chunk 中提取公共的部分</div><div class="line">      chunks: [&apos;common&apos;, &apos;base&apos;],</div><div class="line">      // 把公共的部分放到 base 中</div><div class="line">      name: &apos;base&apos;</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 hash 值</div><div class="line">    &#125;),</div><div class="line">    new DefinePlugin(&#123;</div><div class="line">      // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分</div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    // 压缩输出的 JS 代码</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>common.js没有内容的时候解决<br>1.CommonsChunkPlugin的minChunks属性表示文件要被提取出来时需要在指定的Chunks中出现的最小次数，值越小，被提到common中的文件越多<br>2.根据各个页面之间的相关性选取其中的部分页面时，可用CommonChunkPlugin提取这部分被选出的页面的公共部分，<br>而不是提取所有页面的公共部分，而且这样的操作可以叠加多次，缺点是配置复杂，需要根据页面之间关系去思考如何配置<br>但该方法不通用</p>
<h3 id="分割代码按需加载"><a href="#分割代码按需加载" class="headerlink" title="分割代码按需加载"></a>分割代码按需加载</h3><p>问题<br>单页面应用一次性加载所有功能代码，实际在每个阶段只可能使用其中一部分</p>
<p>解决<br>将整个网站划分成一个个小功能，再按照每个功能的相关程度将他们分成几类<br>将每一类合并成一个Chunk,按需加载对应的Chunk<br>不要按需加载用户首次打开网站时需要看到的画面所对应的功能，将其放到执行入口所在的chunk中，<br>以减少用户能感知的网页加载时间<br>对于不依赖大量代码的功能点，可对其进行按需加载</p>
<p>实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//oneName.js</div><div class="line">module.exports= function()&#123;&#125;</div><div class="line"></div><div class="line">//加载语句</div><div class="line">import(/* webpackChunkName:&quot;oneName&quot; */ &apos;./oneName&apos;).then((oneName)=&gt;&#123;</div><div class="line">  oneName()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>webpack内置了对import(*)语句的支持，当webpack遇到类似的语句时会这样处理<br>以oneName.js为入口重新生成一个Chunk<br>当代码执行到import所在的语句时才去加载由Chunk对应生成的文件<br>import返回一个Promise,当文件加载成功时可以在Promise的then方法中获取oneName.js导出的内容</p>
<p>/* webpackChunkName:”oneName” */ 含义是为动态生成的Chunk赋予一个名称，以方便我们追踪和调试代码<br>如果不指定，则其默认的名称将会是[id].js<br>同样需要在webpack中配置chunkFilename属性，来指定动态生成的Chunk在输出时文件名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &#123;</div><div class="line">    main: &apos;./main.js&apos;,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 为从 entry 中配置生成的 Chunk 配置输出文件的名称</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    // 为动态加载的 Chunk 配置输出文件的名称</div><div class="line">    chunkFilename: &apos;[name].js&apos;,</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  devtool: &apos;source-map&apos; // 输出 source-map 方便直接调试 ES6 源码</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//在.babellrc中需要引入组件来识别import(*)语法</div><div class="line">&#123;</div><div class="line">  &quot;presets&quot;:[</div><div class="line">    &quot;env&quot;,</div><div class="line">    &quot;react&quot;</div><div class="line">  ],</div><div class="line">  &quot;plugins&quot;:[</div><div class="line">    &quot;syntax-dynamic-import&quot;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">//实际应用</div><div class="line">import React, &#123;PureComponent, createElement&#125; from &apos;react&apos;;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos;;</div><div class="line">import &#123;HashRouter, Route, Link&#125; from &apos;react-router-dom&apos;;</div><div class="line">import PageHome from &apos;./pages/home&apos;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 异步加载组件</div><div class="line"> * @param load 组件加载函数，load 函数会返回一个 Promise，在文件加载完成时 resolve</div><div class="line"> * @returns &#123;AsyncComponent&#125; 返回一个高阶组件用于封装需要异步加载的组件</div><div class="line"> */</div><div class="line">function getAsyncComponent(load) &#123;</div><div class="line">  return class AsyncComponent extends PureComponent &#123;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">      // 在高阶组件 DidMount 时才去执行网络加载步骤</div><div class="line">      load().then((&#123;default: component&#125;) =&gt; &#123;</div><div class="line">        // 代码加载成功，获取到了代码导出的值，调用 setState 通知高阶组件重新渲染子组件</div><div class="line">        this.setState(&#123;</div><div class="line">          component,</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">      const &#123;component&#125; = this.state || &#123;&#125;;</div><div class="line">      // component 是 React.Component 类型，需要通过 React.createElement 生产一个组件实例</div><div class="line">      return component ? createElement(component) : null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 根组件</div><div class="line">function App() &#123;</div><div class="line">  return (</div><div class="line">    &lt;HashRouter&gt;</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;nav&gt;</div><div class="line">          &lt;Link to=&apos;/&apos;&gt;Home&lt;/Link&gt; | &lt;Link to=&apos;/about&apos;&gt;About&lt;/Link&gt; | &lt;Link to=&apos;/login&apos;&gt;Login&lt;/Link&gt;</div><div class="line">        &lt;/nav&gt;</div><div class="line">        &lt;hr/&gt;</div><div class="line">        &lt;Route exact path=&apos;/&apos; component=&#123;PageHome&#125;/&gt;</div><div class="line">        &lt;Route path=&apos;/about&apos; component=&#123;getAsyncComponent(</div><div class="line">          // 异步加载函数，异步地加载 PageAbout 组件</div><div class="line">          () =&gt; import(/* webpackChunkName: &apos;page-about&apos; */&apos;./pages/about&apos;)</div><div class="line">        )&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;Route path=&apos;/login&apos; component=&#123;getAsyncComponent(</div><div class="line">          // 异步加载函数，异步地加载 PageAbout 组件</div><div class="line">          () =&gt; import(/* webpackChunkName: &apos;page-login&apos; */&apos;./pages/login&apos;)</div><div class="line">        )&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/HashRouter&gt;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 渲染根组件</div><div class="line">render(&lt;App/&gt;, window.document.getElementById(&apos;app&apos;));</div></pre></td></tr></table></figure></p>
<h2 id="提升流畅度"><a href="#提升流畅度" class="headerlink" title="提升流畅度"></a>提升流畅度</h2><p>提升代码性能<br>1.使用prepack优化代码运行时效率<br>通过在编译阶段预先执行源码来得到执行结果，再直接将运行结果放到编译后的代码中，而不是在代码运行时才去求值</p>
<p>prepack工作原理和流程大致如下：<br>通过Babel将JS源码解析成抽象语法树(AST)，以更细粒度地分析源码<br>PrePack实现了一个JS解释器，用于执行源码，借助这个解释器，Prepack才能理解源码具体是如何执行的<br>并将执行过程中的结果返回到输出中</p>
<p>因为还处于开发阶段，不能识别DOM api和部分nodejs API 代码，优化后文件尺寸可能大大增加，性能可能更差所以目前还不适合用于处理线上代码</p>
<p>2.开启Scope Hoisting<br>分析模块之间的依赖关系，尽可能将被打散的模块合并到一个函数中，大前提是不能造成代码冗余，<br>因此只有那些被引用了一次的模块才能被合并<br>由于Scope Hosting需要分析模块之间的依赖关系，因此源码必须采用ES6语句，不然它将无法生效<br>对于非ES6模块化语法的代码，webpack会降级处理且不使用Scope Hoisting优化。<br>为了知道webpack对哪些代码做了降级处理，可以在启动webpack时带上–display-optimization-bailout参数<br>这样输出的日志就会告知是什么原因导致了降级处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const ModuleConcatenationPlugin = require(&apos;webpack/lib/optimize/ModuleConcatenationPlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &apos;./main.js&apos;,</div><div class="line">  output: &#123;</div><div class="line">    // 把所有依赖的模块合并输出到一个 bundle.js 文件</div><div class="line">    filename: &apos;bundle.js&apos;,</div><div class="line">    // 输出文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  resolve: &#123;</div><div class="line">    // 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件</div><div class="line">    mainFields: [&apos;jsnext:main&apos;, &apos;browser&apos;, &apos;main&apos;]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 开启 Scope Hoisting</div><div class="line">    new ModuleConcatenationPlugin(),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>好处：<br>代码体积更小，因为函数申明语句会产生大量代码<br>代码在运行时因为创建的函数作用域变少，所以内存开销也变小了</p>
<h1 id="输出分析"><a href="#输出分析" class="headerlink" title="输出分析"></a>输出分析</h1><p>执行命令<br>webpack –profile –json &gt;stats.json<br>可以将构建相关的信息输出到stats.json文件中<br>1.打开http:\//webpack.github.io/analyse/ 上传stats文件，使用官方Webpack Analyse分析输出结果<br>2.使用webpack-bundle-analyzer进行分析<br>安装webpack-bundle-analyzer到全局<br>在项目根目录中执行webpack-bundle-analyzer，浏览器会打开对应网页并展现打包结果</p>
<p><a href="https://github.com/YooHannah/algorithm/blob/master/webpack-dist.config.js" target="_blank" rel="external">侧重优化输出质量的配置</a><br><a href="https://github.com/YooHannah/algorithm/blob/master/webpack.config.js" target="_blank" rel="external">侧重优化开发体验的配置</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化开发体验&quot;&gt;&lt;a href=&quot;#优化开发体验&quot; class=&quot;headerlink&quot; title=&quot;优化开发体验&quot;&gt;&lt;/a&gt;优化开发体验&lt;/h1&gt;&lt;p&gt;目的是提升开发效率&lt;/p&gt;
&lt;h2 id=&quot;优化构建速度&quot;&gt;&lt;a href=&quot;#优化构建速度&quot; class=
    
    </summary>
    
    
      <category term="performance" scheme="http://yoohannah.github.io/tags/performance/"/>
    
  </entry>
  
</feed>
