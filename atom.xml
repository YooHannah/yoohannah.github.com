<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Little World</title>
  <subtitle>learn and share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoohannah.github.io/"/>
  <updated>2019-11-28T15:06:16.058Z</updated>
  <id>http://yoohannah.github.io/</id>
  
  <author>
    <name>YooHannah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些vueRouter官方文档看到的</title>
    <link href="http://yoohannah.github.io/post/vue/vueRouter.html"/>
    <id>http://yoohannah.github.io/post/vue/vueRouter.html</id>
    <published>2019-11-28T15:06:15.000Z</published>
    <updated>2019-11-28T15:06:16.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复用组件"><a href="#复用组件" class="headerlink" title="复用组件"></a>复用组件</h2><p>当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。<br>因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，可以简单地 watch (监测变化) $route 对象</p>
<p>参数或查询的改变并不会触发进入/离开的导航守卫。<br>可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。</p>
<h2 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h2><p>如果提供了 path，params 会被忽略，query 并不会被忽略。你需要提供路由的 name 或手写完整的带有参数的 path<br> path—–query   name—–params</p>
<h2 id="beforeRouteUpdate"><a href="#beforeRouteUpdate" class="headerlink" title="beforeRouteUpdate"></a>beforeRouteUpdate</h2><p>如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)</p>
<h2 id="router-view标签"><a href="#router-view标签" class="headerlink" title="router-view标签"></a>router-view标签</h2><p><router-view> 没有设置名字，那么默认为 default；如果设置了name，那么该视图显示路由中components中配置的name值对应的组件</router-view></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>重定向三种形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, redirect: &apos;/b&apos; &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">2.命名的路由</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, redirect: &#123; name: &apos;foo&apos; &#125;&#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line">3.方法，动态返回重定向目标：</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, redirect: to =&gt; &#123;</div><div class="line">      // 方法接收 目标路由 作为参数</div><div class="line">      // return 重定向的 字符串路径/路径对象</div><div class="line">    &#125;&#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上,为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果</p>
<p>“重定向”的意思是，当用户访问 /a时，URL 将会被替换成 /b，然后匹配路由为 /b，<br>/a 的别名是 /b，意味着，当用户访问 /b 时，URL 会保持为 /b，但是路由匹配则为 /a，就像用户访问 /a 一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>通过配置props属性实现多路由复用组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1.如果 props 被设置为 true，route.params 将会被设置为组件属性。</div><div class="line">const User = &#123;</div><div class="line">  props: [&apos;id&apos;],</div><div class="line">  template: &apos;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&apos;</div><div class="line">&#125;</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/user/:id&apos;, component: User, props: true &#125;,</div><div class="line"></div><div class="line">    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</div><div class="line">    &#123;</div><div class="line">      path: &apos;/user/:id&apos;,</div><div class="line">      components: &#123; default: User, sidebar: Sidebar &#125;,</div><div class="line">      props: &#123; default: true, sidebar: false &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">2.如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/promotion/from-newsletter&apos;, component: Promotion, props: &#123; newsletterPopup: false &#125; &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">3.创建一个函数返回 props</div><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123; path: &apos;/search&apos;, component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div><div class="line">URL /search?q=vue 会将 &#123;query: &apos;vue&apos;&#125; 作为属性传递给 SearchUser 组件</div></pre></td></tr></table></figure></p>
<p>请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应</p>
<h2 id="路由生命周期"><a href="#路由生命周期" class="headerlink" title="路由生命周期"></a>路由生命周期</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>router.beforeEach:当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">三个参数</div><div class="line">to: 即将要进入的目标 路由对象</div><div class="line">from: 当前导航正要离开的路由的路由对象</div><div class="line">next：一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数</div><div class="line">      next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</div><div class="line">      next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</div><div class="line">      next(&apos;/&apos;) 或者 next(&#123; path: &apos;/&apos; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</div><div class="line">      next(error): 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调</div></pre></td></tr></table></figure></p>
<p>router.beforeResolve:在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</p>
<p>router.afterEach:不会接受 next 函数也不会改变导航本身</p>
<h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [</div><div class="line">    &#123;</div><div class="line">      path: &apos;/foo&apos;,</div><div class="line">      component: Foo,</div><div class="line">      beforeEnter: (to, from, next) =&gt; &#123;</div><div class="line">        // ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="组件内"><a href="#组件内" class="headerlink" title="组件内"></a>组件内</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const Foo = &#123;</div><div class="line">  template: `...`,</div><div class="line">  beforeRouteEnter (to, from, next) &#123;</div><div class="line">    // 在渲染该组件的对应路由被 confirm 前调用</div><div class="line">    // 不！能！获取组件实例 `this` </div><div class="line">    // 因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</div><div class="line">    //可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</div><div class="line">    next(vm =&gt; &#123; //是支持给 next 传递回调的唯一钩子，beforeRouteUpdate，beforeRouteLeave都不支持，因为可以访问的到</div><div class="line">      // 通过 `vm` 访问组件实例</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  beforeRouteUpdate (to, from, next) &#123;</div><div class="line">    // 在当前路由改变，但是该组件被复用时调用</div><div class="line">    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</div><div class="line">    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</div><div class="line">    // 可以访问组件实例 `this`</div><div class="line">  &#125;,</div><div class="line">  beforeRouteLeave (to, from, next) &#123;</div><div class="line">    // 导航离开该组件的对应路由时调用</div><div class="line">    // 可以访问组件实例 `this`</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ol>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">created () &#123;</div><div class="line">  // 组件创建完后获取数据，</div><div class="line">  // 此时 data 已经被 observed 了</div><div class="line">  this.fetchData()</div><div class="line">&#125;,</div><div class="line">watch: &#123;</div><div class="line">  // 如果路由有变化，会再次执行该方法</div><div class="line">  &apos;$route&apos;: &apos;fetchData&apos;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h3 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">beforeRouteEnter (to, from, next) &#123;</div><div class="line">  getPost(to.params.id, (err, post) =&gt; &#123;</div><div class="line">    next(vm =&gt; vm.setData(err, post))</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line">// 路由改变前，组件就已经渲染完了</div><div class="line">// 逻辑稍稍不同</div><div class="line">beforeRouteUpdate (to, from, next) &#123;</div><div class="line">  this.post = null</div><div class="line">  getPost(to.params.id, (err, post) =&gt; &#123;</div><div class="line">    this.setData(err, post)</div><div class="line">    next()</div><div class="line">  &#125;)</div><div class="line">&#125;,</div><div class="line">methods: &#123;</div><div class="line">  setData (err, post) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">      this.error = err.toString()</div><div class="line">    &#125; else &#123;</div><div class="line">      this.post = post</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h2><p>scrollBehavior 这个功能只在支持 history.pushState 的浏览器中可用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">  routes: [...],</div><div class="line">  scrollBehavior (to, from, savedPosition) &#123;</div><div class="line"></div><div class="line">    // return 期望滚动到哪个的位置</div><div class="line">    if (to.hash) &#123;</div><div class="line">      return &#123;</div><div class="line">        selector: to.hash //模拟“滚动到锚点”的行为</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if (savedPosition) &#123;</div><div class="line">      return savedPosition //返回 savedPosition，在按下 后退/前进 按钮时，就会像浏览器的原生表现那样</div><div class="line">    &#125; else &#123;</div><div class="line">      return &#123; x: 0, y: 0 &#125; //让页面滚动到顶部</div><div class="line">    &#125;</div><div class="line">    return new Promise((resolve, reject) =&gt; &#123; //返回一个 Promise 来得出预期的位置描述</div><div class="line">      setTimeout(() =&gt; &#123;</div><div class="line">        resolve(&#123; x: 0, y: 0 &#125;)</div><div class="line">      &#125;, 500)</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;复用组件&quot;&gt;&lt;a href=&quot;#复用组件&quot; class=&quot;headerlink&quot; title=&quot;复用组件&quot;&gt;&lt;/a&gt;复用组件&lt;/h2&gt;&lt;p&gt;当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。&lt;br&gt;因为两个路由都渲染
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>两个css问题解决</title>
    <link href="http://yoohannah.github.io/post/knowledge/calcApprence.html"/>
    <id>http://yoohannah.github.io/post/knowledge/calcApprence.html</id>
    <published>2019-11-28T14:58:58.000Z</published>
    <updated>2019-11-28T15:00:13.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="子元素-position-fixed-，但宽度要和父元素一致"><a href="#子元素-position-fixed-，但宽度要和父元素一致" class="headerlink" title="子元素 position:fixed ，但宽度要和父元素一致"></a>子元素 position:fixed ，但宽度要和父元素一致</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>父元素宽度随屏幕大小变化，而且margin-left有一个固定值，假设为320px<br>子元素position:fixed<br>如果直接设置子元素宽度为100%<br>则会导致子元素有320px的宽度在可视区域外<br><img src="/image/calc.png" alt="calc.png"></p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>css3的函数calc() 可以用来计算属性值<br>特点：<br>1.浏览器解析calc()结果还是calc(),不会计算参数表达式的值，<br>  意味着浏览器中的值可以更加灵活，能够响应视口的改变，即实际渲染结果始终调用calc计算结果<br>2.可以使用加减乘除，可以套嵌使用，即calc参数表达式中可以包含calc函数调用<br>3.可以进行不同单位间的计算,可以混合绝对单位(如百分比与视口单元)与相对单元(比如像素)<br>应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.居中</div><div class="line">//居中设置原来</div><div class="line">.center &#123;</div><div class="line">  position: absolute</div><div class="line">  top: 50%;</div><div class="line">  left: 50%;</div><div class="line">  marging-top: -150px;</div><div class="line">  margin-left: -150px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用calc</div><div class="line">.center &#123;</div><div class="line">  position: absolute</div><div class="line">  top: calc(50% - 150px);</div><div class="line">  left: calc(50% - 150px);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2.设置字体，在页面上的任何文本，将会根据视口自动缩放，</div><div class="line">相同比例的视口总会显示相同的文本数量，不管视口的真实尺寸是多少。</div><div class="line">html &#123;  </div><div class="line">    font-size: calc(100vw / 30);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">width:calc(100%-320px)</div></pre></td></tr></table></figure>
<h1 id="input样式兼容"><a href="#input样式兼容" class="headerlink" title="input样式兼容"></a>input样式兼容</h1><p>在safari浏览器中给input设置样式不能直接被使用，会依旧使用浏览器默认样式，<br>此时需要给样式添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-webkit-appearance: none;/*去除系统默认appearance的样式*/</div><div class="line">line-height: normal;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;子元素-position-fixed-，但宽度要和父元素一致&quot;&gt;&lt;a href=&quot;#子元素-position-fixed-，但宽度要和父元素一致&quot; class=&quot;headerlink&quot; title=&quot;子元素 position:fixed ，但宽度要和父元素一致&quot;&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>关于代理proxy</title>
    <link href="http://yoohannah.github.io/post/js/proxy.html"/>
    <id>http://yoohannah.github.io/post/js/proxy.html</id>
    <published>2019-11-08T14:19:37.000Z</published>
    <updated>2019-11-28T14:42:54.947Z</updated>
    
    <content type="html"><![CDATA[<p>代理是JS es6中引入，可用于控制对象<br>—代理可以定制对象交互时行动（例如，当读取属性或调用方法）<br>— 所有交互行为都必须通过代理，指定的行为发生时会调用代理方法<br>使用代理可以优雅实现以下内容</p>
<ul>
<li>日志记录</li>
<li>性能测试</li>
<li>数据校验</li>
<li>自动填充对象属性</li>
<li>数组负索引</li>
</ul>
<p>使用代理对对象访问添加日志 — report 函数用于添加日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function makeLoggable(target)&#123;</div><div class="line">	return new Proxy(target,&#123;</div><div class="line">		get:(target,property)=&gt;&#123;</div><div class="line">			report(&apos;READING:&apos;+property)</div><div class="line">			return target[property]</div><div class="line">		&#125;,</div><div class="line">		set:(target,property,value)=&gt;&#123;</div><div class="line">			report(&apos;writing value&apos; +value +&apos;to&apos;+&apos;property&apos;)</div><div class="line">			target[property] = value</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用代理自动填充属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Folder()&#123;</div><div class="line">	return new Proxy(&#123;&#125;,&#123;</div><div class="line">		get:(target,property)=&gt;&#123;</div><div class="line">			if(!(property in target))&#123;</div><div class="line">				target[property] = new Folder()</div><div class="line">			&#125;</div><div class="line">			return target[property]</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">const rootFolder = new Folder()</div><div class="line">try &#123;</div><div class="line">	rootFolder.ninjasDir.firstNinjaDir.ninjaFile = &apos;yoshi.txt&apos;</div><div class="line">&#125;catch(e)&#123;</div><div class="line">	console.log(e)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用代理实现数组负引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function creatNegativeArrayProxy(array)&#123;</div><div class="line">	if(!Array.isArray(array))&#123;</div><div class="line">		throw new TypeError(&apos;expected an array&apos;)</div><div class="line">	&#125;</div><div class="line">	return new Proxy(array,&#123;</div><div class="line">		get:(target,index)=&gt;&#123;</div><div class="line">			index = +index</div><div class="line">			return target[index&lt;0?target.length+index:index]</div><div class="line">		&#125;,</div><div class="line">		set:(target,index,val)=&gt;&#123;</div><div class="line">			index = +index</div><div class="line">			return target[index&lt;0?target.length+index:index] = val</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">const ninja = [1,2,3]</div><div class="line">const proxi = creatNegativeArrayProxy(ninja)</div><div class="line">console.log(proxi[-1]) //==&gt; 3</div><div class="line">proxi[-2] = 22 // ninja ==&gt;1,22,3</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理是JS es6中引入，可用于控制对象&lt;br&gt;—代理可以定制对象交互时行动（例如，当读取属性或调用方法）&lt;br&gt;— 所有交互行为都必须通过代理，指定的行为发生时会调用代理方法&lt;br&gt;使用代理可以优雅实现以下内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志记录&lt;/li&gt;
&lt;li&gt;性能测
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>absolute应用</title>
    <link href="http://yoohannah.github.io/post/knowledge/cssPosition.html"/>
    <id>http://yoohannah.github.io/post/knowledge/cssPosition.html</id>
    <published>2019-09-22T23:54:58.000Z</published>
    <updated>2019-09-23T15:19:25.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题-背景"><a href="#问题-背景" class="headerlink" title="问题/背景"></a>问题/背景</h1><p>table 的 td 内容在内容较多时会自动进行省略处理，然后鼠标滑过弹层显示具体内容</p>
<p>td内容还可以配置在线编辑，鼠标滑过，可以显示小笔图标，点击小笔图标或者td块都可以进行在线编辑然后回车或者鼠标点击输入框之外的地方都可以提交发送给后台</p>
<p>table被包裹在一个div1中,只允许出现水平方向滚动条，不出现垂直方向滚动条<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.div1&#123;</div><div class="line">  overflow-x: auto;</div><div class="line">  overflow-y: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出现的问题就是，如果最后几行的内容过多，弹层显示具体内容时弹层会被遮挡，不能正常飘出来<br><img src="/image/position1.png" alt="position1.png"></p>
<h1 id="原理知识"><a href="#原理知识" class="headerlink" title="原理知识"></a>原理知识</h1><p>父元素设置position:relative,子元素设置position:absolute,配套使用时，子元素才会会在z轴上相对父元素进行xy面的定位<br>如果最近父元素没有设置position:relative，那么会往父元素的父元素找，看是否设置，如果设置，则相对爷爷元素进行XY面定位，如果没有继续往上找，以此类推<br>即会相对父元素及以上元素中靠近自己最近的，设置了position:relative的长辈元素进行相对定位</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>弹层没有按照预期可以弹到div1以外的地方,被困在div1里面，加上div1不能垂直方向滚动，说明弹层没有相对div1定位,<br>解除div1垂直方向的滚动限制，弹层把div1在垂直方向上撑起来了，滚动滚动条，可以看完整的弹层内容，说明弹层相对div1的子元素定位了，<br>即从盛装省略内容的标签到div1的标签中，有标签设置了position:relative，</p>
<p>通过查找发现，在线编辑功能的小笔图标使用了position:absolute相对定位，在它最近的div2标签上设置了position:relative，<br>而div2标签包含了弹层所在标签，属于div1子元素，所以弹层就会相对div2定位，沿Z轴飘在div2这一层上面，就弹不到div1以外了</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>将div2上position:relative去掉，给在线编辑功能的小笔图标设置position:absolute的标签div3外加div4,设置position:relative</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">解决前：</div><div class="line">&lt;div1 style=&apos;position:relative&apos;&gt;</div><div class="line">  &lt;table&gt;</div><div class="line">    &lt;tbody&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">      &lt;td&gt;</div><div class="line">      &lt;div2 style=&apos;position:relative&apos;&gt;</div><div class="line">        &lt;div3 style=&quot;position:absolute&quot;&gt;&lt;i class=&quot;fa fa-pencil&quot; &gt;&lt;/i&gt;&lt;/div3&gt;</div><div class="line">        &lt;popwindow&gt;具体内容&lt;/popwindow&gt; /** 组件弹窗div设置有position:absolute**/</div><div class="line">      &lt;/div2&gt;</div><div class="line">      &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;/tbody&gt;</div><div class="line">  &lt;/table&gt;</div><div class="line">&lt;/div1&gt;</div><div class="line"></div><div class="line">解决后：</div><div class="line">&lt;div1 style=&apos;position:relative&apos;&gt;</div><div class="line">  &lt;table&gt;</div><div class="line">    &lt;tbody&gt;</div><div class="line">    &lt;tr&gt;</div><div class="line">      &lt;td&gt;</div><div class="line">      &lt;div2&gt;</div><div class="line">        &lt;div4 style=&apos;position:relative&apos;&gt;</div><div class="line">          &lt;div3 style=&quot;position:absolute&quot;&gt;&lt;i class=&quot;fa fa-pencil&quot; &gt;&lt;/i&gt;&lt;/div3&gt;</div><div class="line">        &lt;/div4&gt;</div><div class="line">        &lt;popwindow&gt;具体内容&lt;/popwindow&gt; /** 组件弹窗div设置有position:absolute**/</div><div class="line">      &lt;/div2&gt;</div><div class="line">      &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    &lt;/tbody&gt;</div><div class="line">  &lt;/table&gt;</div><div class="line">&lt;/div1&gt;</div></pre></td></tr></table></figure>
<p>普通省略内容鼠标滑过<br><img src="/image/position2.png" alt="position2.png"><br>在线编辑内容省略时，鼠标滑过<br><img src="/image/position3.png" alt="position3.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题-背景&quot;&gt;&lt;a href=&quot;#问题-背景&quot; class=&quot;headerlink&quot; title=&quot;问题/背景&quot;&gt;&lt;/a&gt;问题/背景&lt;/h1&gt;&lt;p&gt;table 的 td 内容在内容较多时会自动进行省略处理，然后鼠标滑过弹层显示具体内容&lt;/p&gt;
&lt;p&gt;td内容还可以
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>webpack原理</title>
    <link href="http://yoohannah.github.io/post/performance/webpackTheory.html"/>
    <id>http://yoohannah.github.io/post/performance/webpackTheory.html</id>
    <published>2019-07-14T09:17:02.000Z</published>
    <updated>2019-07-20T02:50:32.008Z</updated>
    
    <content type="html"><![CDATA[<p>bundle.js能直接运行在浏览器中的原因是：<br>在输出文件中通过<strong>webpack_require</strong>函数，定义了一个可以在浏览器中执行的加载函数，来模拟Nodejs中的require语句</p>
<p><strong>webpack_require</strong> 函数将所有模块挂载一个对象上，通过判断该对象是否存在该模块实现模块缓存，防止二次加载</p>
<p>原来一个个独立的模块文件被合并到了一个单独的bundle.js的原因是<br>浏览器不能像Nodejs那样快速的在本地加载一个个模块文件，而必须通过网络请求去加载还未得到的文件，<br>如果模块的数量很多，则加载时间会很长，因此将所有模块都存放在了数组中，执行一次网络加载<br><a href="https://github.com/YooHannah/algorithm/blob/master/webpack/outputFile.js" target="_blank" rel="external">输出文件分析</a></p>
<h1 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h1><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="获取loader配置的options"><a href="#获取loader配置的options" class="headerlink" title="获取loader配置的options"></a>获取loader配置的options</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const loaderUtils = require(&apos;loader-utils&apos;)</div><div class="line">module.exports = function(source)&#123;</div><div class="line">	//获取用户为当前loader传入的options</div><div class="line">	const options = loaderUtils.getOptions(this)</div><div class="line">	return source</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回除了内容之外的东西"><a href="#返回除了内容之外的东西" class="headerlink" title="返回除了内容之外的东西"></a>返回除了内容之外的东西</h3><p>this.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。 this.callback 的详细使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">this.callback( </div><div class="line">    // 当无法转换原内容时，给 Webpack 返回一个 Error </div><div class="line">    err: Error | null, </div><div class="line">    // 原内容转换后的内容 </div><div class="line">    content: string | Buffer, </div><div class="line">    // 用于把转换后的内容得出原内容的 Source Map，方便调试 </div><div class="line">    sourceMap?: SourceMap, </div><div class="line">    // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， </div><div class="line">    // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 </div><div class="line">    abstractSyntaxTree?: AST </div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>实例：用 babel-loader 转换 ES6 代码为例，它还需要输出转换后的 ES5 代码对应的 Source Map，以方便调试源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">  // 通过 this.callback 告诉 Webpack 返回的结果 </div><div class="line">  this.callback(null, source, sourceMaps); </div><div class="line">  // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， </div><div class="line">  // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中  </div><div class="line">  return; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Source Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。 为此 Webpack 为 Loader 提供了 this.sourceMap API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。</p>
<h3 id="处理异步流程"><a href="#处理异步流程" class="headerlink" title="处理异步流程"></a>处理异步流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">    // 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果 </div><div class="line">    var callback = this.async(); </div><div class="line">    someAsyncOperation(source, function(err, result, sourceMaps, ast) &#123; </div><div class="line">        // 通过 callback 返回异步执行后的结果 </div><div class="line">        callback(err, result, sourceMaps, ast); </div><div class="line">    &#125;); </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="处理二进制数据"><a href="#处理二进制数据" class="headerlink" title="处理二进制数据"></a>处理二进制数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">    // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 </div><div class="line">    source instanceof Buffer === true; </div><div class="line">    // Loader 返回的类型也可以是 Buffer 类型的 </div><div class="line">    // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 </div><div class="line">    return source; </div><div class="line">&#125;; </div><div class="line">// 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据  </div><div class="line">module.exports.raw = true; //没有该行 Loader 只能拿到字符串。</div></pre></td></tr></table></figure>
<h3 id="缓存加速"><a href="#缓存加速" class="headerlink" title="缓存加速"></a>缓存加速</h3><p>在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。 为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时， 是不会重新调用对应的 Loader 去执行转换操作的。<br>如果想让Webpack 不缓存该 Loader 的处理结果，可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = function(source) &#123; </div><div class="line">  // 关闭该 Loader 的缓存功能 </div><div class="line">  this.cacheable(false); </div><div class="line">  return source; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><p>this.context：当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src。</p>
<p>this.resource：当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。</p>
<p>this.resourcePath：当前处理文件的路径，例如 /src/main.js。</p>
<p>this.resourceQuery：当前处理文件的 querystring。</p>
<p>this.target：等于 Webpack 配置中的 Target。</p>
<p>this.loadModule：当 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果。</p>
<p>this.resolve：像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string))。</p>
<p>this.addDependency：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string)。</p>
<p>this.addContextDependency：和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string)。</p>
<p>this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为 clearDependencies()。</p>
<p>this.emitFile：输出一个文件，使用方法为 emitFile(name: string, content: Buffer|string, sourceMap: {…})。</p>
<h2 id="加载本地loader"><a href="#加载本地loader" class="headerlink" title="加载本地loader"></a>加载本地loader</h2><h3 id="方法一-Npm-link"><a href="#方法一-Npm-link" class="headerlink" title="方法一 Npm link"></a>方法一 Npm link</h3><p>Npm link 专门用于开发和调试本地 Npm 模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 Npm 模块。 由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。</p>
<p>完成 Npm link 的步骤如下：</p>
<p>1.确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 package.json 已经正确配置好；<br>2.在本地 Npm 模块根目录下执行 npm link，把本地模块注册到全局；<br>3.在项目根目录下执行 npm link loader-name，把第2步注册到全局的本地 Npm 模块链接到项目的 node_moduels 下，其中的 loader-name 是指在第1步中的 package.json 文件中配置的模块名称。</p>
<p>链接好 Loader 到项目后就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了。</p>
<h3 id="方法二-ResolveLoader"><a href="#方法二-ResolveLoader" class="headerlink" title="方法二 ResolveLoader"></a>方法二 ResolveLoader</h3><p>ResolveLoader用于配置 Webpack 如何寻找 Loader,默认情况下只会去 node_modules 目录下寻找，为了让 Webpack 加载放在本地项目中的 Loader 需要修改 resolveLoader.modules。<br>假如本地的 Loader 在项目目录中的 ./loaders/loader-name 中，则需要如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123; </div><div class="line">  resolveLoader:&#123; </div><div class="line">    // 去哪些目录下寻找 Loader，有先后顺序之分 </div><div class="line">    modules: [&apos;node_modules&apos;,&apos;./loaders/&apos;], </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>plugin内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class BasicPlugin&#123; </div><div class="line">  // 在构造函数中获取用户给该插件传入的配置 </div><div class="line">  constructor(options)&#123; </div><div class="line">  &#125; </div><div class="line"> </div><div class="line">  // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象 </div><div class="line">  apply(compiler)&#123; </div><div class="line">    compiler.plugin(&apos;compilation&apos;,function(compilation) &#123; </div><div class="line">    &#125;) </div><div class="line">  &#125; </div><div class="line">&#125; </div><div class="line"> </div><div class="line">// 导出 Plugin </div><div class="line">module.exports = BasicPlugin;</div></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const BasicPlugin = require(&apos;./BasicPlugin.js&apos;); </div><div class="line">module.export = &#123; </div><div class="line">  plugins:[ </div><div class="line">    new BasicPlugin(options), </div><div class="line">  ] </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Webpack 启动后，在读取配置的过程中会先执行 new BasicPlugin(options) 初始化一个 BasicPlugin 获得其实例。 在初始化 compiler 对象后，再调用 basicPlugin.apply(compiler) 给插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。</p>
<h2 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a>Compiler 和 Compilation</h2><p>Compiler 和 Compilation 的含义如下：</p>
<p>1.Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</p>
<p>2.Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</p>
<p>Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。<br>Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p>
<p>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。 Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/ </div><div class="line"> 广播出事件 </div><div class="line"> event-name 为事件名称，注意不要和现有的事件重名 </div><div class="line"> params 为附带的参数 </div><div class="line">/ </div><div class="line">compiler.apply(&apos;event-name&apos;,params); </div><div class="line"> </div><div class="line">/ </div><div class="line"> 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。 </div><div class="line"> 同时函数中的 params 参数为广播事件时附带的参数。 </div><div class="line">*/ </div><div class="line">compiler.plugin(&apos;event-name&apos;,function(params) &#123; </div><div class="line"> </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>compilation.apply 和 compilation.plugin 使用方法和上面一致。</p>
<p>在开发插件时，还需要注意以下两点：</p>
<p>1.只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。<br>2.传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。<br>3.有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;emit&apos;,function(compilation, callback) &#123; </div><div class="line">    // 支持处理逻辑 </div><div class="line"> </div><div class="line">    // 处理完毕后执行 callback 以通知 Webpack  </div><div class="line">    // 如果不执行 callback，运行流程将会一直卡在这不往下执行  </div><div class="line">    callback(); </div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<h2 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h2><h3 id="监听文件变化"><a href="#监听文件变化" class="headerlink" title="监听文件变化"></a>监听文件变化</h3><p> Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时， 就会触发一次新的 Compilation。<br> 通过【watch-run】 事件可以知道是哪个文件发生变化导致了新的 Compilation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/ 当依赖的文件发生变化时会触发 watch-run 事件 </div><div class="line">compiler.plugin(&apos;watch-run&apos;, (watching, callback) =&gt; &#123; </div><div class="line">    // 获取发生变化的文件列表 </div><div class="line">    const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes; </div><div class="line">    // changedFiles 格式为键值对，键为发生变化的文件路径。 </div><div class="line">    if (changedFiles[filePath] !== undefined) &#123; </div><div class="line">      // filePath 对应的文件发生了变化 </div><div class="line">    &#125; </div><div class="line">    callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。 由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。 为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;after-compile&apos;, (compilation, callback) =&gt; &#123; </div><div class="line">  // 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译 </div><div class="line">    compilation.fileDependencies.push(filePath); </div><div class="line">    callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="读取输出资源、代码块、模块及其依赖"><a href="#读取输出资源、代码块、模块及其依赖" class="headerlink" title="读取输出资源、代码块、模块及其依赖"></a>读取输出资源、代码块、模块及其依赖</h3><p>在 【emit】 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。 插件代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Plugin &#123; </div><div class="line">  apply(compiler) &#123; </div><div class="line">    compiler.plugin(&apos;emit&apos;, function (compilation, callback) &#123; </div><div class="line">      // compilation.chunks 存放所有代码块，是一个数组 </div><div class="line">      compilation.chunks.forEach(function (chunk) &#123; </div><div class="line">        // chunk 代表一个代码块 </div><div class="line">        // 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块 </div><div class="line">        chunk.forEachModule(function (module) &#123; </div><div class="line">          // module 代表一个模块 </div><div class="line">          // module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组 </div><div class="line">          module.fileDependencies.forEach(function (filepath) &#123; </div><div class="line">          &#125;); </div><div class="line">        &#125;); </div><div class="line"> </div><div class="line">        // Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件 </div><div class="line">        // 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时， </div><div class="line">        // 该 Chunk 就会生成 .js 和 .css 两个文件 </div><div class="line">        chunk.files.forEach(function (filename) &#123; </div><div class="line">          // compilation.assets 存放当前所有即将输出的资源 </div><div class="line">          // 调用一个输出资源的 source() 方法能获取到输出资源的内容 </div><div class="line">          let source = compilation.assets[filename].source(); </div><div class="line">        &#125;); </div><div class="line">      &#125;); </div><div class="line"> </div><div class="line">      // 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。 </div><div class="line">      // 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。 </div><div class="line">      callback(); </div><div class="line">    &#125;) </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="修改输出资源"><a href="#修改输出资源" class="headerlink" title="修改输出资源"></a>修改输出资源</h3><p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 emit 事件，因为发生 emit 事件时所有模块的转换和代码块对应的文件已经生成好， 需要输出的资源即将输出，因此 emit 事件是修改 Webpack 输出资源的最后时机。</p>
<p>所有需要输出的资源会存放在 compilation.assets 中，compilation.assets 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。</p>
<p>设置 compilation.assets 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;emit&apos;, (compilation, callback) =&gt; &#123; </div><div class="line">  // 设置名称为 fileName 的输出资源 </div><div class="line">  compilation.assets[fileName] = &#123; </div><div class="line">    // 返回文件内容 </div><div class="line">    source: () =&gt; &#123; </div><div class="line">      // fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer </div><div class="line">      return fileContent; </div><div class="line">      &#125;, </div><div class="line">    // 返回文件大小 </div><div class="line">      size: () =&gt; &#123; </div><div class="line">      return Buffer.byteLength(fileContent, &apos;utf8&apos;); </div><div class="line">    &#125; </div><div class="line">  &#125;; </div><div class="line">  callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>读取 compilation.assets 的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">compiler.plugin(&apos;emit&apos;, (compilation, callback) =&gt; &#123; </div><div class="line">  // 读取名称为 fileName 的输出资源 </div><div class="line">  const asset = compilation.assets[fileName]; </div><div class="line">  // 获取输出资源的内容 </div><div class="line">  asset.source(); </div><div class="line">  // 获取输出资源的文件大小 </div><div class="line">  asset.size(); </div><div class="line">  callback(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="判断-Webpack-使用了哪些插件"><a href="#判断-Webpack-使用了哪些插件" class="headerlink" title="判断 Webpack 使用了哪些插件"></a>判断 Webpack 使用了哪些插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 判断当前配置是否使用了 ExtractTextPlugin， </div><div class="line">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数 </div><div class="line">function hasExtractTextPlugin(compiler) &#123; </div><div class="line">  // 当前配置所有使用的插件列表 </div><div class="line">  const plugins = compiler.options.plugins; </div><div class="line">  // 去 plugins 中寻找有没有 ExtractTextPlugin 的实例 </div><div class="line">  return plugins.find(plugin=&gt;plugin.proto.constructor === ExtractTextPlugin) != null; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class EndWebpackPlugin &#123; </div><div class="line"> </div><div class="line">  constructor(doneCallback, failCallback) &#123; </div><div class="line">    // 存下在构造函数中传入的回调函数 </div><div class="line">    this.doneCallback = doneCallback; </div><div class="line">    this.failCallback = failCallback; </div><div class="line">  &#125; </div><div class="line"> </div><div class="line">  apply(compiler) &#123; </div><div class="line">    //done：在成功构建并且输出了文件后，Webpack 即将退出时发生；</div><div class="line">    compiler.plugin(&apos;done&apos;, (stats) =&gt; &#123; </div><div class="line">        // 在 done 事件中回调 doneCallback </div><div class="line">        this.doneCallback(stats); </div><div class="line">    &#125;); </div><div class="line">    //failed：在构建出现异常导致构建失败，Webpack 即将退出时发生；</div><div class="line">    compiler.plugin(&apos;failed&apos;, (err) =&gt; &#123; </div><div class="line">        // 在 failed 事件中回调 failCallback </div><div class="line">        this.failCallback(err); </div><div class="line">    &#125;); </div><div class="line">  &#125; </div><div class="line">&#125; </div><div class="line">// 导出插件  </div><div class="line">module.exports = EndWebpackPlugin; </div><div class="line"></div><div class="line">//使用</div><div class="line">module.exports = &#123; </div><div class="line">  plugins:[ </div><div class="line">    // 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数； </div><div class="line">    new EndWebpackPlugin(() =&gt; &#123; </div><div class="line">      // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作 </div><div class="line">    &#125;, (err) =&gt; &#123; </div><div class="line">      // Webpack 构建失败，err 是导致错误的原因 </div><div class="line">      console.error(err);    &#125;) </div><div class="line">  ] </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="流程概括"><a href="#流程概括" class="headerlink" title="流程概括"></a>流程概括</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<p>1.初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>（启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。）<br>2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>3.确定入口：根据配置中的 entry 找出所有的入口文件；<br>4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
<p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>
<h2 id="流程细节"><a href="#流程细节" class="headerlink" title="流程细节"></a>流程细节</h2><p>1.初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。<br>2.编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。<br>3.输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。</p>
<h2 id="初始化阶段事"><a href="#初始化阶段事" class="headerlink" title="初始化阶段事"></a>初始化阶段事</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>初始化参数</td><td>从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 <code>new Plugin()</code>。</td></tr><tr><td>实例化 Compiler</td><td>用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。</td></tr><tr><td>加载插件</td><td>依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。</td></tr><tr><td>environment</td><td>开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。</td></tr><tr><td>entry-option</td><td>读取配置的 Entrys，为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备。</td></tr><tr><td>after-plugins</td><td>调用完所有内置的和配置的插件的 apply 方法。</td></tr><tr><td>after-resolvers</td><td>根据配置初始化完 resolver，resolver 负责在文件系统中寻找指定路径的文件。</td></tr></tbody></table>

<h2 id="编译阶段事件"><a href="#编译阶段事件" class="headerlink" title="编译阶段事件"></a>编译阶段事件</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>build-module</td><td>使用对应的 Loader 去转换一个模块。</td></tr><tr><td>normal-module-loader</td><td>在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。</td></tr><tr><td>program</td><td>从配置的入口模块开始，分析其 AST，当遇到 <code>require</code> 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系</td></tr><tr><td>seal</td><td>所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk</td></tr></tbody></table>

<h2 id="输出阶段事件"><a href="#输出阶段事件" class="headerlink" title="输出阶段事件"></a>输出阶段事件</h2><table><thead><tr><th>事件名</th><th>解释</th></tr></thead><tbody><tr><td>should-emit</td><td>所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。</td></tr><tr><td>emit</td><td>确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。</td></tr><tr><td>after-emit</td><td>文件输出完毕。</td></tr><tr><td>done</td><td>成功完成一次完成的编译和输出流程。</td></tr><tr><td>failed</td><td>如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。</td></tr></tbody></table>

<p>在输出阶段已经得到了各个模块经过转换后的结果和其依赖关系，并且把相关模块组合在一起形成一个个 Chunk。 在输出阶段会根据 Chunk 的类型，使用对应的模版生成最终要要输出的文件内容</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bundle.js能直接运行在浏览器中的原因是：&lt;br&gt;在输出文件中通过&lt;strong&gt;webpack_require&lt;/strong&gt;函数，定义了一个可以在浏览器中执行的加载函数，来模拟Nodejs中的require语句&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;webpack_re
    
    </summary>
    
    
      <category term="performance" scheme="http://yoohannah.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>webpack优化</title>
    <link href="http://yoohannah.github.io/post/performance/webpackOptimization.html"/>
    <id>http://yoohannah.github.io/post/performance/webpackOptimization.html</id>
    <published>2019-06-29T08:21:02.000Z</published>
    <updated>2019-07-20T02:07:21.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化开发体验"><a href="#优化开发体验" class="headerlink" title="优化开发体验"></a>优化开发体验</h1><p>目的是提升开发效率</p>
<h2 id="优化构建速度"><a href="#优化构建速度" class="headerlink" title="优化构建速度"></a>优化构建速度</h2><p>解决项目庞大时构建的耗时加长的问题</p>
<h3 id="缩小文件查找范围"><a href="#缩小文件查找范围" class="headerlink" title="缩小文件查找范围"></a>缩小文件查找范围</h3><p>1.由于Loader对文件转换很耗时，所以应该让尽可能少的文件被处理，适当调整项目目录结构，在配置loader时通过【include】属性缩小处理命中文件范围<br>2.当安装第三方模块都放在项目根目录的./node_module目录下时，通过指明【resolve.modules】为存放第三方模块的绝对路径，减少寻找第三方模块的递归查找<br>3.在项目中所有第三方模块都采用main字段去描述入口文件时，只给【resolve.mainFileds】配置main字段，不使用默认值，减少搜索步骤<br>4.使用【resolve.alias】进行路径映射时，将导入模块的语句，替换成直接使用模块中完整文件的语句，减少耗时的对于lib中文件的解析工作<br>5.优化【resolve.extension】配置，减少尝试次数<br>a.后缀列表尽可能小，不要将项目中不可能存在的情况写到后缀列表中<br>b.频率出现最高的文件后缀要优先放在最前面，以做到尽快退出寻找过程<br>c.在源码中写导入语句时，尽可能带上后缀，从而避免寻找过程<br>6.合理使用【module.noparse】属性，排除不需要进行模块解析处理的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">1.</div><div class="line">rules:&#123;</div><div class="line">	//只对项目根目录下src目录中文件采用配置的loader</div><div class="line">	include:path.resolve(__dirname,&apos;src&apos;)</div><div class="line">&#125;</div><div class="line">2.</div><div class="line">resolve:&#123;</div><div class="line">	//使用绝对路径指明第三方模块存放的位置，减少搜索步骤</div><div class="line">	modules:[path.resolve(__dirname,&apos;node_module&apos;)]</div><div class="line">&#125;</div><div class="line">3.</div><div class="line">resolve:&#123;</div><div class="line">	//减少入口查找</div><div class="line">	mainFilds:[&apos;main&apos;]</div><div class="line">&#125;</div><div class="line">4.</div><div class="line">resolve:&#123;</div><div class="line">	//减少第三方模块递归解析</div><div class="line">	alias:&#123; </div><div class="line">		&apos;react&apos;:path.resolve(__dirname,&apos;./node_module/react/dist/react.min.js&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用DLLPlugin"><a href="#使用DLLPlugin" class="headerlink" title="使用DLLPlugin"></a>使用DLLPlugin</h3><p>一个动态链接库文件可以包含为其他模块调用的函数和数据<br>提升构建速度的原理：<br>包含大量复用模块的动态链接库只需被编译一次，在之后的构建过程中被动态链接库包含的模块将不会重新编译，而是直接使用动态链接库的代码，<br>由于动态链接库中大多数包含的是常用的第三方模块，例如react,react-dom,所以只要不升级这些模块的版本，动态连接库就不用重新编译</p>
<p>DllPlugin:打包出一个个单独的动态链接库文件<br>DllReferencePlugin:用于在主要的配置文件中引入DllPlugin打包好的动态连接库文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">//webpack_dll.config.js</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const DllPlugin = require(&apos;webpack/lib/DllPlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &#123;</div><div class="line">    // 把 React 相关的放到一个单独的动态链接库</div><div class="line">    react: [&apos;react&apos;, &apos;react-dom&apos;],</div><div class="line">    // 把项目需要所有的 polyfill 放到一个单独的动态链接库</div><div class="line">    polyfill: [&apos;core-js/fn/object/assign&apos;, &apos;core-js/fn/promise&apos;, &apos;whatwg-fetch&apos;],</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，也就是 entry 中配置的 react 和 polyfill</div><div class="line">    filename: &apos;[name].dll.js&apos;,</div><div class="line">    // 输出的文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">    // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react</div><div class="line">    // 之所以在前面加上 _dll_ 是为了防止全局变量冲突</div><div class="line">    library: &apos;_dll_[name]&apos;,</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 接入 DllPlugin</div><div class="line">    new DllPlugin(&#123;</div><div class="line">      // 动态链接库的全局变量名称，需要和 output.library 中保持一致</div><div class="line">      // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</div><div class="line">      // 例如 react.manifest.json 中就有 &quot;name&quot;: &quot;_dll_react&quot;</div><div class="line">      name: &apos;_dll_[name]&apos;,</div><div class="line">      // 描述动态链接库的 manifest.json 文件输出时的文件名称</div><div class="line">      path: path.join(__dirname, &apos;dist&apos;, &apos;[name].manifest.json&apos;),</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">webpack_dll.config.js文件中，DllPlugin中的name参数必须和output</div><div class="line"></div><div class="line">//webpack.config.js</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const DllReferencePlugin = require(&apos;webpack/lib/DllReferencePlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    // 定义 入口 Chunk</div><div class="line">    main: &apos;./main.js&apos;</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 输出文件的名称</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    // 输出文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        // 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 告诉 Webpack 使用了哪些动态链接库</div><div class="line">    new DllReferencePlugin(&#123;</div><div class="line">      // 描述 react 动态链接库的文件内容</div><div class="line">      manifest: require(&apos;./dist/react.manifest.json&apos;),</div><div class="line">    &#125;),</div><div class="line">    new DllReferencePlugin(&#123;</div><div class="line">      // 描述 polyfill 动态链接库的文件内容</div><div class="line">      manifest: require(&apos;./dist/polyfill.manifest.json&apos;),</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">  devtool: &apos;source-map&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>执行构建流程：<br>先编译出动态链接库相关的文件，执行webpack –config webpack_dll.config.js<br>在确保动态链接库存在时才能正常编译入口文件，webpack.config.js中的DllReferencePlugin会依赖动态链接库相关文件，执行webpack命令</p>
<h3 id="使用HappyPack"><a href="#使用HappyPack" class="headerlink" title="使用HappyPack"></a>使用HappyPack</h3><p>提升构建速度原理：<br>将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程，从而让webpack在同一时刻处理多个任务<br>实际表现就是<br>所有通过Loader处理的文件都先交给happypack/loader去处理，在收集到这些文件的处理权后，HappyPack就可以统一分配了<br>每通过new HappyPack() 去实例化一个HappyPack,其实就是告诉HappyPack核心调度器如何通过一系列Loader去转换一类文件，<br>并且可以指定如何为这类转换操作分配子进程<br>核心调度器的逻辑代码在主进程中，也就是运行着webpack的进程中，核心调度器会将一个个任务分配给当前空闲的子进程，<br>子进程处理完毕后将结果发送给核心调度，他们之间的数据交换是通过进程间的通信API实现的<br>核心调度器收到来自子进程处理完毕的结果后，会通知WebPack该文件已处理完毕</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line">const HappyPack = require(&apos;happypack&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &#123;</div><div class="line">    main: &apos;./main.js&apos;,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 把所有依赖的模块合并输出到一个 bundle.js 文件</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    // 输出文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例</div><div class="line">        use: [&apos;happypack/loader?id=babel&apos;],</div><div class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        // 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例</div><div class="line">        test: /\.css$/,</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          use: [&apos;happypack/loader?id=css&apos;],</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new HappyPack(&#123;</div><div class="line">      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</div><div class="line">      id: &apos;babel&apos;,</div><div class="line">      // 如何处理 .js 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;babel-loader?cacheDirectory&apos;],</div><div class="line">    &#125;),</div><div class="line">    new HappyPack(&#123;</div><div class="line">      id: &apos;css&apos;,</div><div class="line">      // 如何处理 .css 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;css-loader&apos;],</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name].css`,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">  devtool: &apos;source-map&apos; // 输出 source-map 方便直接调试 ES6 源码</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在实例化 HappyPack 插件的时候，除了可以传入 id 和 loaders 两个参数外，HappyPack 还支持如下参数：<br>threads: 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数。<br>verbose: 是否允许 HappyPack 输出日志，默认是 true。<br>threadPool :代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const HappyPack = require(&apos;happypack&apos;);</div><div class="line">// 构造出共享进程池，进程池中包含5个子进程</div><div class="line">const happyThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">    new HappyPack(&#123;</div><div class="line">      // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件</div><div class="line">      id: &apos;babel&apos;,</div><div class="line">      // 如何处理 .js 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;babel-loader?cacheDirectory&apos;],</div><div class="line">      // 使用共享进程池中的子进程去处理任务</div><div class="line">      threadPool: happyThreadPool,</div><div class="line">    &#125;),</div><div class="line">    new HappyPack(&#123;</div><div class="line">      id: &apos;css&apos;,</div><div class="line">      // 如何处理 .css 文件，用法和 Loader 配置中一样</div><div class="line">      loaders: [&apos;css-loader&apos;],</div><div class="line">      // 使用共享进程池中的子进程去处理任务</div><div class="line">      threadPool: happyThreadPool,</div><div class="line">     &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name].css`,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="使用ParallelUglifyPlugin"><a href="#使用ParallelUglifyPlugin" class="headerlink" title="使用ParallelUglifyPlugin"></a>使用ParallelUglifyPlugin</h3><p>提升构建速度原理：<br>当webpack有多个JS文件需要输出和压缩时，原本会使用UglifyJS去一个一个压缩再输出，但是ParallelUglifyPlugin会开启多个子进程，<br>将对多个文件的压缩工作分配给多个子进程完成，每个子进程其实还是通过UglifyJS去压缩代码，单变成了并行执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">const path = require(‘path’);</div><div class="line">const DefinePlugin = require(‘webpack/lib/DefinePlugin’);</div><div class="line">const ParallelUglifyPlugin = require(‘webpack-parallel-uglify-plugin’);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">    // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码</div><div class="line">    new ParallelUglifyPlugin(&#123;</div><div class="line">      // 传递给 UglifyJS 的参数</div><div class="line">      uglifyJS: &#123;</div><div class="line">        output: &#123;</div><div class="line">          // 最紧凑的输出</div><div class="line">          beautify: false,</div><div class="line">          // 删除所有的注释</div><div class="line">          comments: false,</div><div class="line">        &#125;,</div><div class="line">        compress: &#123;</div><div class="line">          // 在UglifyJs删除没有用到的代码时不输出警告</div><div class="line">          warnings: false,</div><div class="line">          // 删除所有的 console 语句，可以兼容ie浏览器</div><div class="line">          drop_console: true,</div><div class="line">          // 内嵌定义了但是只用到一次的变量</div><div class="line">          collapse_vars: true,</div><div class="line">          // 提取出出现多次但是没有定义成变量去引用的静态值</div><div class="line">          reduce_vars: true,</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在通过 new ParallelUglifyPlugin() 实例化时，支持以下参数：<br>test：使用正则去匹配哪些文件需要被 ParallelUglifyPlugin 压缩，默认是 /.js$/，也就是默认压缩所有的 .js 文件。<br>include：使用正则去命中需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。<br>exclude：使用正则去命中不需要被 ParallelUglifyPlugin 压缩的文件。默认为 []。<br>cacheDir：缓存压缩后的结果，下次遇到一样的输入时直接从缓存中获取压缩后的结果并返回。cacheDir 用于配置缓存存放的目录路径。默认不会缓存，想开启缓存请设置一个目录路径。<br>workerCount：开启几个子进程去并发的执行压缩。默认是当前运行电脑的 CPU 核数减去1。<br>sourceMap：是否输出 Source Map，这会导致压缩过程变慢。<br>uglifyJS：用于压缩 ES5 代码时的配置，Object 类型，直接透传给 UglifyJS 的参数。</p>
<p>其中的 test、include、exclude 与配置 Loader 时的思想和用法一样<br>UglifyES 是 UglifyJS 的变种，专门用于压缩 ES6 代码，它们两都出自于同一个项目，并且它们两不能同时使用。<br>UglifyES 一般用于给比较新的 JavaScript 运行环境压缩代码，例如用于 ReactNative 的代码运行在兼容性较好的 JavaScriptCore 引擎中，为了得到更好的性能和尺寸，采用 UglifyES 压缩效果会更好。<br>ParallelUglifyPlugin 同时内置了 UglifyJS 和 UglifyES，也就是说 ParallelUglifyPlugin 支持并行压缩 ES6 代码。<br>如果设置 cacheDir 开启了缓存，在之后的构建中会变的更快。</p>
<h2 id="优化使用体验"><a href="#优化使用体验" class="headerlink" title="优化使用体验"></a>优化使用体验</h2><p>通过自动化手段完成一些重复工作，让我们专注于解决问题本身</p>
<h3 id="优化文件监听"><a href="#优化文件监听" class="headerlink" title="优化文件监听"></a>优化文件监听</h3><p>通过配置watchOption进行优化<br>ignored:/node_module/ 不监听node_module下文件 监听更少文件<br>agregatetionTimeout:值越大，降低构建频率<br>poll:值越小，降低检查频率<br>后面两项的配置会使监听模式的反应和灵敏度降低</p>
<h3 id="优化自动刷新性能"><a href="#优化自动刷新性能" class="headerlink" title="优化自动刷新性能"></a>优化自动刷新性能</h3><p>1.使用devserver开启inline时，devserver因为不知道某个网页依赖哪几个Chunk,所以会向每个输出的chunk中注入代理客户端代码<br>当项目输出多个chunk时，就会导致构建缓慢，因此关闭inline进行优化<br>如果不想以iframe方式去访问，但同时想让网页保持自动刷新功能，则需要手动向网页中注入代理客户端的脚本，<br>向index.html中注入webpack-dev-server.js,但要注意发布到线上时要删掉这段用于开发的代码</p>
<p>2.开启热替换时，控制台打印信息不能标明模块信息，可以使用NameModulesPlugin插件解决，从而在控制台打印出被修改的模块名称<br>注意关闭默认inline模式并手动注入客户端的方法，不能用于模块热替换的情况，原因在于模块热替换的运行依赖每个chunk中都包含代理客户端的代码</p>
<h1 id="优化输出质量"><a href="#优化输出质量" class="headerlink" title="优化输出质量"></a>优化输出质量</h1><p>目的是为用户呈现体验更好的网页</p>
<h2 id="减少用户能够感知到的加载时间-首屏时间"><a href="#减少用户能够感知到的加载时间-首屏时间" class="headerlink" title="减少用户能够感知到的加载时间(首屏时间)"></a>减少用户能够感知到的加载时间(首屏时间)</h2><h3 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h3><p>问题：<br>开发过程会涉及到调试的代码,没必要发到线上给到用户<br>开发环境和线上接口地址不同，使用不同环境数据<br>线上代码会进行压缩，开发代码不需要、</p>
<p>解决：<br>当代码中使用了process模块的语句时，webpack会自动打包加入process模块代码来支持非nodejs运行环境<br>当代码中没有使用时，就不会打包加入<br>可以在源码中使用process.env.NODE_ENV环境变量去判断执行开发/线上环境的代码<br>环境变量的设置通过DefinePlugin设置<br>设置后，环境变量的值在webpack处理过程中会被代入源码中，替换掉process.env.NODE_ENV<br>访问proces的语句被替换，webpack也就不会在打包时加入process模块了</p>
<p>注意：DefinedPlugin定义的环境变量只对Webpack需要处理的代码有效，而不会影响Nodejs运行时的环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">    new DefinePlugin(&#123;</div><div class="line">      // 定义 NODE_ENV 环境变量为 production </div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)//环境变量的值需要一个由双引号包裹的字符串&apos;&quot;production&quot;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h3><p>提升网页加载速度，减少网络传输流量，混淆代码以防有人下载代码进行代码分析和改造<br>通过插件形式引入UglifyJs，利用UglifyJs分析JS代码语法树，理解代码含义，<br>从而去掉无效代码，去掉日志输出代码，缩短变量名等优化,仅用于es5<br>UglifyJsPlugin:封装UglifyJs实现压缩<br>ParallelUglifyPlugin：多进行并行处理压缩<br>uglifyjsWebpackPlugin:引入UglifyES，压缩es6，要去掉.babelrc文件中的babel-preset-env，否则会将es6转es5<br>css-loader?minimize:压缩CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">1.UglifyJsPlugin</div><div class="line">const UglifyJSPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);//使用内置插件</div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">     new UglifyJSPlugin(&#123;</div><div class="line">      compress: &#123;</div><div class="line">        // 在 UglifyES 删除没有用到的代码时不输出警告</div><div class="line">        warnings: false,</div><div class="line">        // 删除所有的 `console` 语句，可以兼容ie浏览器</div><div class="line">        drop_console: true,</div><div class="line">        // 内嵌定义了但是只用到一次的变量</div><div class="line">        collapse_vars: true,</div><div class="line">        // 提取出出现多次但是没有定义成变量去引用的静态值</div><div class="line">        reduce_vars: true,</div><div class="line">      &#125;,</div><div class="line">      output: &#123;</div><div class="line">        // 最紧凑的输出，默认会保留空格</div><div class="line">        beautify: false,</div><div class="line">        // 删除所有的注释</div><div class="line">        comments: false,</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">2.uglifyjs-webpack-plugin</div><div class="line">const UglifyESPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">  plugins: [</div><div class="line">     new UglifyESPlugin(&#123;</div><div class="line">      uglifyOptions: &#123;//相比UglifyJSPlugin 多了一层</div><div class="line">        compress: &#123;</div><div class="line">          // 在 UglifyES 删除没有用到的代码时不输出警告</div><div class="line">          warnings: false,</div><div class="line">          // 删除所有的 `console` 语句，可以兼容ie浏览器</div><div class="line">          drop_console: true,</div><div class="line">          // 内嵌定义了但是只用到一次的变量</div><div class="line">          collapse_vars: true,</div><div class="line">          // 提取出出现多次但是没有定义成变量去引用的静态值</div><div class="line">          reduce_vars: true,</div><div class="line">        &#125;,</div><div class="line">        output: &#123;</div><div class="line">          // 最紧凑的输出</div><div class="line">          beautify: false,</div><div class="line">          // 删除所有的注释</div><div class="line">          comments: false,</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div><div class="line"></div><div class="line">3.压缩CSS</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.css/,// 增加对 CSS 文件的支持</div><div class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          use: [&apos;css-loader?minimize&apos;] // 压缩 CSS 代码</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 用 WebPlugin 生成对应的 HTML 文件</div><div class="line">    new WebPlugin(&#123;</div><div class="line">      template: &apos;./template.html&apos;, // HTML 模版文件所在的文件路径</div><div class="line">      filename: &apos;index.html&apos; // 输出的 HTML 的文件名称</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 hash 值</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="使用CDN加速"><a href="#使用CDN加速" class="headerlink" title="使用CDN加速"></a>使用CDN加速</h3><p>webpack接入CDN需要满足：<br>1.静态资源的导入URL需要变成指向CDN服务的绝对路径URL，而不是相对于HTML文件的URL<br>2.静态资源的文件名需要带上由文件内容算出来的Hash值，以防止被缓存<br>3.将不同类型资源放到不同域名CDN服务上，以防止资源的并行加载阻塞<br>实现主要依赖publicPath设置存放静态资源的CDN目录URL<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const UglifyJsPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</div><div class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    // Chunk app 的 JS 执行入口文件</div><div class="line">    app: &apos;./main.js&apos;</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 给输出的 JavaScript 文件名称加上 Hash 值</div><div class="line">    filename: &apos;[name]_[chunkhash:8].js&apos;,</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">    // 指定存放 JavaScript 文件的线上目录</div><div class="line">    publicPath: &apos;//js.cdn.com/id/&apos;,</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        // 增加对 CSS 文件的支持</div><div class="line">        test: /\.css/,</div><div class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          // 压缩 CSS 代码</div><div class="line">          use: [&apos;css-loader?minimize&apos;],</div><div class="line">          // 指定存放 CSS 中导入的资源（例如图片）的线上目录</div><div class="line">          publicPath: &apos;//img.cdn.com/id/&apos;</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        // 增加对 PNG 文件的支持</div><div class="line">        test: /\.png/,</div><div class="line">        // 给输出的 PNG 文件名称加上 Hash 值</div><div class="line">        use: [&apos;file-loader?name=[name]_[hash:8].[ext]&apos;],</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 使用 WebPlugin 自动生成 HTML，会根据publicPath用线上地址替换原来相对地址</div><div class="line">    new WebPlugin(&#123;</div><div class="line">      // HTML 模版文件所在的文件路径</div><div class="line">      template: &apos;./template.html&apos;,</div><div class="line">      // 输出的 HTML 的文件名称</div><div class="line">      filename: &apos;index.html&apos;,</div><div class="line">      // 指定存放 CSS 文件的线上目录</div><div class="line">      stylePublicPath: &apos;//css.cdn.com/id/&apos;,</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      // 给输出的 CSS 文件名称加上 Hash 值</div><div class="line">      filename: `[name]_[contenthash:8].css`,</div><div class="line">    &#125;),</div><div class="line">    new DefinePlugin(&#123;</div><div class="line">      // 定义 NODE_ENV 环境变量为 production 去除开发时才需要的部分</div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    // 压缩输出的 JS 代码</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="使用tree-Shaking剔除用不上的代码"><a href="#使用tree-Shaking剔除用不上的代码" class="headerlink" title="使用tree Shaking剔除用不上的代码"></a>使用tree Shaking剔除用不上的代码</h2><p>Tree Shaking可以分析出那些代码被用上了，哪些没有<br>Tree Shaking正常工作的前提是，提交给webpack的js代码必须采用了ES6的模块化语法，因为es6模块化语法是静态的<br>（在导入，导出语句中的路径必须是静态字符串，而且不能放入其他代码块中），这让webpack可以简单地分析出那些export被import了。<br>实现：<br>1.修改.babelrc文件，保留ES6语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;:[</div><div class="line">    [</div><div class="line">      &quot;env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;module&quot;:false//关闭模块转换功能，保留ES6语法</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以使用webpack –display-used-exports查看分析结果<br>2.使用uglifyJS剔除用不上的代码<br>可以在直接在配置文件中配置<br>也可以使用命令行执行<br>webpack –display-used-exports –optimize-minimize</p>
<p>处理但第三方库时，利用mainField告诉webpack采用那份入口文件，<br>当指定入口于文件采用es6模块化语法时，从而可以使用treeShaking进行代码优化</p>
<h3 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h3><p>问题：<br>相同资源被重复加载，浪费用户的流量和服务器成本<br>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验</p>
<p>解决：<br>将多个页面公共代码部分抽离成单独文件，用户在第一次访问后，公共文件代码被浏览器缓存<br>在用户切换其他页面时，则不会再重新加载存放公共代码的文件，而是直接从缓存中获取<br>从而<br>减少网络传输流量，降低服务器成本<br>虽然用户第一次打开网站的速度得不到优化，但之后访问其他页面的速度将提高</p>
<p>实现：<br>–根据网站所使用的技术栈，找出网站所有页面都需要用到的基础库(第三方库)，将他们提取到一个单独的文件base.js中<br>该文件包含了所有网页的基础运行环境，用于长期缓存，提高响应速度</p>
<p>–剔除了各个页面中被base.js包含的部分代码后，再找出所有页面都依赖的公共部分的代码，将他们提取到commom.js</p>
<p>–再为每个网页都生成一个单独的文件，不包含base.js和common.js中包含的部分，只包含各页面单独需要的部分代码</p>
<p>– 依赖CommonsChunkPlugin插件<br>CommonsChunkPlugin实例会生成一个新的Chunk，这个chunk中包含了被提取的代码<br>通过name属性告诉插件新生成的chunk的名称，chunks属性指明从哪些已有chunk中提取公共部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const UglifyJsPlugin = require(&apos;webpack/lib/optimize/UglifyJsPlugin&apos;);</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class="line">const DefinePlugin = require(&apos;webpack/lib/DefinePlugin&apos;);</div><div class="line">const CommonsChunkPlugin = require(&apos;webpack/lib/optimize/CommonsChunkPlugin&apos;);</div><div class="line">const &#123;AutoWebPlugin&#125; = require(&apos;web-webpack-plugin&apos;);</div><div class="line"></div><div class="line">// 使用 AutoWebPlugin，自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用</div><div class="line">const autoWebPlugin = new AutoWebPlugin(&apos;pages&apos;, &#123;</div><div class="line">  template: &apos;./template.html&apos;, // HTML 模版文件所在的文件路径</div><div class="line">  // 提取出所有页面公共的代码</div><div class="line">  commonsChunk: &#123;</div><div class="line">    name: &apos;common&apos;,// 提取出公共代码 Chunk 的名称</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置，</div><div class="line">  // autoWebPlugin.entry 方法可以获取到生成入口配置</div><div class="line">  entry: autoWebPlugin.entry(&#123;</div><div class="line">    // 这里可以加入你额外需要的 Chunk 入口</div><div class="line">    base: &apos;./base.js&apos;</div><div class="line">  &#125;),</div><div class="line">  output: &#123;</div><div class="line">    filename: &apos;[name]_[chunkhash:8].js&apos;,// 给输出的文件名称加上 hash 值</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        // 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.css/,// 增加对 CSS 文件的支持</div><div class="line">        // 提取出 Chunk 中的 CSS 代码到单独的文件中</div><div class="line">        use: ExtractTextPlugin.extract(&#123;</div><div class="line">          use: [&apos;css-loader?minimize&apos;] // 压缩 CSS 代码</div><div class="line">        &#125;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    autoWebPlugin,</div><div class="line">    // 为了从 common 中提取出 base 也包含的部分,减小common体积</div><div class="line">    new CommonsChunkPlugin(&#123;</div><div class="line">      // 从 common 和 base 两个现成的 Chunk 中提取公共的部分</div><div class="line">      chunks: [&apos;common&apos;, &apos;base&apos;],</div><div class="line">      // 把公共的部分放到 base 中</div><div class="line">      name: &apos;base&apos;</div><div class="line">    &#125;),</div><div class="line">    new ExtractTextPlugin(&#123;</div><div class="line">      filename: `[name]_[contenthash:8].css`,// 给输出的 CSS 文件名称加上 hash 值</div><div class="line">    &#125;),</div><div class="line">    new DefinePlugin(&#123;</div><div class="line">      // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分</div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: JSON.stringify(&apos;production&apos;)</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    // 压缩输出的 JS 代码</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>common.js没有内容的时候解决<br>1.CommonsChunkPlugin的minChunks属性表示文件要被提取出来时需要在指定的Chunks中出现的最小次数，值越小，被提到common中的文件越多<br>2.根据各个页面之间的相关性选取其中的部分页面时，可用CommonChunkPlugin提取这部分被选出的页面的公共部分，<br>而不是提取所有页面的公共部分，而且这样的操作可以叠加多次，缺点是配置复杂，需要根据页面之间关系去思考如何配置<br>但该方法不通用</p>
<h3 id="分割代码按需加载"><a href="#分割代码按需加载" class="headerlink" title="分割代码按需加载"></a>分割代码按需加载</h3><p>问题<br>单页面应用一次性加载所有功能代码，实际在每个阶段只可能使用其中一部分</p>
<p>解决<br>将整个网站划分成一个个小功能，再按照每个功能的相关程度将他们分成几类<br>将每一类合并成一个Chunk,按需加载对应的Chunk<br>不要按需加载用户首次打开网站时需要看到的画面所对应的功能，将其放到执行入口所在的chunk中，<br>以减少用户能感知的网页加载时间<br>对于不依赖大量代码的功能点，可对其进行按需加载</p>
<p>实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//oneName.js</div><div class="line">module.exports= function()&#123;&#125;</div><div class="line"></div><div class="line">//加载语句</div><div class="line">import(/* webpackChunkName:&quot;oneName&quot; */ &apos;./oneName&apos;).then((oneName)=&gt;&#123;</div><div class="line">  oneName()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>webpack内置了对import(*)语句的支持，当webpack遇到类似的语句时会这样处理<br>以oneName.js为入口重新生成一个Chunk<br>当代码执行到import所在的语句时才去加载由Chunk对应生成的文件<br>import返回一个Promise,当文件加载成功时可以在Promise的then方法中获取oneName.js导出的内容</p>
<p>/* webpackChunkName:”oneName” */ 含义是为动态生成的Chunk赋予一个名称，以方便我们追踪和调试代码<br>如果不指定，则其默认的名称将会是[id].js<br>同样需要在webpack中配置chunkFilename属性，来指定动态生成的Chunk在输出时文件名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &#123;</div><div class="line">    main: &apos;./main.js&apos;,</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    // 为从 entry 中配置生成的 Chunk 配置输出文件的名称</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    // 为动态加载的 Chunk 配置输出文件的名称</div><div class="line">    chunkFilename: &apos;[name].js&apos;,</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        use: [&apos;babel-loader&apos;],</div><div class="line">        exclude: path.resolve(__dirname, &apos;node_modules&apos;),</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  devtool: &apos;source-map&apos; // 输出 source-map 方便直接调试 ES6 源码</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//在.babellrc中需要引入组件来识别import(*)语法</div><div class="line">&#123;</div><div class="line">  &quot;presets&quot;:[</div><div class="line">    &quot;env&quot;,</div><div class="line">    &quot;react&quot;</div><div class="line">  ],</div><div class="line">  &quot;plugins&quot;:[</div><div class="line">    &quot;syntax-dynamic-import&quot;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">//实际应用</div><div class="line">import React, &#123;PureComponent, createElement&#125; from &apos;react&apos;;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos;;</div><div class="line">import &#123;HashRouter, Route, Link&#125; from &apos;react-router-dom&apos;;</div><div class="line">import PageHome from &apos;./pages/home&apos;;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 异步加载组件</div><div class="line"> * @param load 组件加载函数，load 函数会返回一个 Promise，在文件加载完成时 resolve</div><div class="line"> * @returns &#123;AsyncComponent&#125; 返回一个高阶组件用于封装需要异步加载的组件</div><div class="line"> */</div><div class="line">function getAsyncComponent(load) &#123;</div><div class="line">  return class AsyncComponent extends PureComponent &#123;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">      // 在高阶组件 DidMount 时才去执行网络加载步骤</div><div class="line">      load().then((&#123;default: component&#125;) =&gt; &#123;</div><div class="line">        // 代码加载成功，获取到了代码导出的值，调用 setState 通知高阶组件重新渲染子组件</div><div class="line">        this.setState(&#123;</div><div class="line">          component,</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">      const &#123;component&#125; = this.state || &#123;&#125;;</div><div class="line">      // component 是 React.Component 类型，需要通过 React.createElement 生产一个组件实例</div><div class="line">      return component ? createElement(component) : null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 根组件</div><div class="line">function App() &#123;</div><div class="line">  return (</div><div class="line">    &lt;HashRouter&gt;</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;nav&gt;</div><div class="line">          &lt;Link to=&apos;/&apos;&gt;Home&lt;/Link&gt; | &lt;Link to=&apos;/about&apos;&gt;About&lt;/Link&gt; | &lt;Link to=&apos;/login&apos;&gt;Login&lt;/Link&gt;</div><div class="line">        &lt;/nav&gt;</div><div class="line">        &lt;hr/&gt;</div><div class="line">        &lt;Route exact path=&apos;/&apos; component=&#123;PageHome&#125;/&gt;</div><div class="line">        &lt;Route path=&apos;/about&apos; component=&#123;getAsyncComponent(</div><div class="line">          // 异步加载函数，异步地加载 PageAbout 组件</div><div class="line">          () =&gt; import(/* webpackChunkName: &apos;page-about&apos; */&apos;./pages/about&apos;)</div><div class="line">        )&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;Route path=&apos;/login&apos; component=&#123;getAsyncComponent(</div><div class="line">          // 异步加载函数，异步地加载 PageAbout 组件</div><div class="line">          () =&gt; import(/* webpackChunkName: &apos;page-login&apos; */&apos;./pages/login&apos;)</div><div class="line">        )&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/HashRouter&gt;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 渲染根组件</div><div class="line">render(&lt;App/&gt;, window.document.getElementById(&apos;app&apos;));</div></pre></td></tr></table></figure></p>
<h2 id="提升流畅度"><a href="#提升流畅度" class="headerlink" title="提升流畅度"></a>提升流畅度</h2><p>提升代码性能<br>1.使用prepack优化代码运行时效率<br>通过在编译阶段预先执行源码来得到执行结果，再直接将运行结果放到编译后的代码中，而不是在代码运行时才去求值</p>
<p>prepack工作原理和流程大致如下：<br>通过Babel将JS源码解析成抽象语法树(AST)，以更细粒度地分析源码<br>PrePack实现了一个JS解释器，用于执行源码，借助这个解释器，Prepack才能理解源码具体是如何执行的<br>并将执行过程中的结果返回到输出中</p>
<p>因为还处于开发阶段，不能识别DOM api和部分nodejs API 代码，优化后文件尺寸可能大大增加，性能可能更差所以目前还不适合用于处理线上代码</p>
<p>2.开启Scope Hoisting<br>分析模块之间的依赖关系，尽可能将被打散的模块合并到一个函数中，大前提是不能造成代码冗余，<br>因此只有那些被引用了一次的模块才能被合并<br>由于Scope Hosting需要分析模块之间的依赖关系，因此源码必须采用ES6语句，不然它将无法生效<br>对于非ES6模块化语法的代码，webpack会降级处理且不使用Scope Hoisting优化。<br>为了知道webpack对哪些代码做了降级处理，可以在启动webpack时带上–display-optimization-bailout参数<br>这样输出的日志就会告知是什么原因导致了降级处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">const ModuleConcatenationPlugin = require(&apos;webpack/lib/optimize/ModuleConcatenationPlugin&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  // JS 执行入口文件</div><div class="line">  entry: &apos;./main.js&apos;,</div><div class="line">  output: &#123;</div><div class="line">    // 把所有依赖的模块合并输出到一个 bundle.js 文件</div><div class="line">    filename: &apos;bundle.js&apos;,</div><div class="line">    // 输出文件都放到 dist 目录下</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">  &#125;,</div><div class="line">  resolve: &#123;</div><div class="line">    // 针对 Npm 中的第三方模块优先采用 jsnext:main 中指向的 ES6 模块化语法的文件</div><div class="line">    mainFields: [&apos;jsnext:main&apos;, &apos;browser&apos;, &apos;main&apos;]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    // 开启 Scope Hoisting</div><div class="line">    new ModuleConcatenationPlugin(),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>好处：<br>代码体积更小，因为函数申明语句会产生大量代码<br>代码在运行时因为创建的函数作用域变少，所以内存开销也变小了</p>
<h1 id="输出分析"><a href="#输出分析" class="headerlink" title="输出分析"></a>输出分析</h1><p>执行命令<br>webpack –profile –json &gt;stats.json<br>可以将构建相关的信息输出到stats.json文件中<br>1.打开http:\//webpack.github.io/analyse/ 上传stats文件，使用官方Webpack Analyse分析输出结果<br>2.使用webpack-bundle-analyzer进行分析<br>安装webpack-bundle-analyzer到全局<br>在项目根目录中执行webpack-bundle-analyzer，浏览器会打开对应网页并展现打包结果</p>
<p><a href="https://github.com/YooHannah/algorithm/blob/master/webpack-dist.config.js" target="_blank" rel="external">侧重优化输出质量的配置</a><br><a href="https://github.com/YooHannah/algorithm/blob/master/webpack.config.js" target="_blank" rel="external">侧重优化开发体验的配置</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化开发体验&quot;&gt;&lt;a href=&quot;#优化开发体验&quot; class=&quot;headerlink&quot; title=&quot;优化开发体验&quot;&gt;&lt;/a&gt;优化开发体验&lt;/h1&gt;&lt;p&gt;目的是提升开发效率&lt;/p&gt;
&lt;h2 id=&quot;优化构建速度&quot;&gt;&lt;a href=&quot;#优化构建速度&quot; class=
    
    </summary>
    
    
      <category term="performance" scheme="http://yoohannah.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoohannah.github.io/post/performance/xx.html"/>
    <id>http://yoohannah.github.io/post/performance/xx.html</id>
    <published>2019-06-16T13:59:25.888Z</published>
    <updated>2019-07-14T11:08:13.576Z</updated>
    
    <content type="html"><![CDATA[const loaderUtils = require('loader-utils')
module.exports = function(source){
	//获取用户为当前loader传入的options
	const options = loaderUtils.getOptions(this)
}]]></content>
    
    <summary type="html">
    
      const loaderUtils = require(&#39;loader-utils&#39;)
module.exports = function(source){
	//获取用户为当前loader传入的options
	const options = loaderUtils.getOp
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue编译初探</title>
    <link href="http://yoohannah.github.io/post/vue/vueCompile.html"/>
    <id>http://yoohannah.github.io/post/vue/vueCompile.html</id>
    <published>2019-06-09T10:07:15.000Z</published>
    <updated>2019-06-09T10:25:21.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/lifecycle.png" alt="Vue声明周期"><br>初始化之后调用$mount会挂载组件编译template</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>compile编译可以分成parse,optimize与generate三个阶段，最终得到render function<br>parse<br>parse 会用正则等方式循环切割字符串，解析template模板中的指令，class，style等数据，形成AST<br>optimize<br>标记static静态结点，这是编译过程的一处优化<br>generate<br>将AST转化成render function字符串的过程，得到的结果是render的字符串以及staticRenderFns</p>
<p>当render function 被调用的时候，因为会读取所需对象的值，所以会触发getter函数进行【依赖收集】<br>【依赖收集】的目的是将观察者Watcher对象存放到当前闭包中的订阅者Dep的subs中<br>在修改对象的值的时候，会触发对应的setter，setter通知之前【依赖收集】得到的Dep中的每一个Watcher<br>告诉他们自己的值改变了，需要重新渲染视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$mount = function()&#123;</div><div class="line">	//挂在组件 已生成渲染函数,被调用</div><div class="line">	return mountComponent(this,el,hydrating) </div><div class="line">&#125;</div><div class="line"></div><div class="line">//缓存 mount</div><div class="line">var mount = Vue.prototype.$mount;</div><div class="line"></div><div class="line">//重新覆盖 编译的功能</div><div class="line">Vue,prototype.$mount = function()&#123;</div><div class="line">	//挂在组件 生成render function</div><div class="line">	return mount.call(this,el)</div><div class="line">&#125;</div><div class="line">编译过程：字符串模板转成渲染函数</div><div class="line">运行时：调用渲染函数</div><div class="line">独立构建 = 编译+运行时</div><div class="line">运行时构建 = 运行时</div><div class="line"></div><div class="line">//模板的编译 分成parse,optimize与generate三个阶段，最终得到render function</div><div class="line">compileToFunctions(template)</div><div class="line">//render function生成通过new Function，可以将函数功能通过字符串传递进去生成新函数</div><div class="line">var render = new Function(参数,函数主体内容字符串)</div><div class="line">其中函数主体字符串的功能就是返回parse生成的抽象语法树AST</div><div class="line"></div><div class="line">渲染函数在哪被调用</div><div class="line">mountComponen()&#123;</div><div class="line">	//模板编译完成，实例挂载之前调用生命周期函数</div><div class="line">	callHook(vm,&apos;beforeMount&apos;) </div><div class="line"></div><div class="line">	初始化 updateComponent函数</div><div class="line">		在非生产环境下config.performance为true,</div><div class="line">		初始化 updateComponent时有进行性能追踪的相关代码</div><div class="line">		(进行性能追踪4个场景：</div><div class="line">		组件【初始化】时</div><div class="line">		【编译】时模板转渲染函数时</div><div class="line">		通过【渲染】函数生成虚拟DOM时</div><div class="line">		【打补丁】，虚拟DOM转真实Dom时)</div><div class="line">		vm.update(vm._render(),hydrating)</div><div class="line">		vm._render() === vm.$options.render() //生成虚拟节点vnode</div><div class="line">		vm.update() 把vm._render()生成的虚拟节点渲染成真实的DOM</div><div class="line">	updateComponent 用作参数生成Watcher，即数据发生变化时，可以重新渲染DOM节点</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="vm-option-render-渲染函数生成"><a href="#vm-option-render-渲染函数生成" class="headerlink" title="vm.$option.render 渲染函数生成"></a>vm.$option.render 渲染函数生成</h1><p>1.生成<br>vm.$option.render = render 构造器函数调用parse,generate生成函数主体字符串，<br>再调用new Function返回函数<br>2.探究渲染函数this指向<br>initProxy<br>【渲染函数的作用域代理】<br>    Proxy在目标对象之前架设一层拦截，拦截啥？<br>    读取get;设置set;key in proxyObject 属性检测；with(){}<br>    对一个new Proxy生成的对象进行上述操作时就会引发has钩子函数<br>vnode = render.call(vm._renderProxy,vm.$creatElement)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">（function anonymous()&#123;//一个渲染函数</div><div class="line">//vm.renderProxy 访问变量A就会进行拦截 </div><div class="line">//调用proxy的has钩子函数 ，钩子函数中进行依赖收集，与生成的watcher进行绑定</div><div class="line">	with(this)&#123;return ...变量A...&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h1 id="vue-对象生成"><a href="#vue-对象生成" class="headerlink" title="vue 对象生成"></a>vue 对象生成</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">//vue 对象生成</div><div class="line">(function(global,factory)&#123;</div><div class="line">	typeof exports === &apos;object&apos; &amp;&amp; typeof module !==&apos;undefinded&apos; ?module.export = factory():</div><div class="line">	typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory):</div><div class="line">	(global.Vue = factory());//window.Vue cmd AMD Comonjs</div><div class="line">&#125;)(this,function()&#123;</div><div class="line">	var ASSET_TYPES = [</div><div class="line">		&apos;components&apos;,</div><div class="line">		&apos;directives&apos;,</div><div class="line">		&apos;filters&apos;</div><div class="line">	]</div><div class="line">	//全局配置对象 挂载在Vue对象上，用作接口，进行自定义策略</div><div class="line">	var config = &#123;</div><div class="line">		optionMergeStrategies:Object.create(null)</div><div class="line">	&#125;</div><div class="line">	//自定义策略</div><div class="line">	var strats = config.optionMergeStrategies</div><div class="line">	strats.data = function()&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	//默认策略</div><div class="line">	function defaultStrats(parentVal,childVal,vm)&#123;</div><div class="line">		return childVal === undefined? parentVal:childVal</div><div class="line">	&#125;</div><div class="line">	var has = function(obj,key)&#123;</div><div class="line">		return obj != null &amp;&amp; Object.hasOwnProperty.call(obj,key)</div><div class="line">	&#125;</div><div class="line">	function mergeOption(parent,child,vm)&#123;</div><div class="line">		var options = &#123;&#125;</div><div class="line">		var key</div><div class="line">		for(key in parent)&#123; //parent=&gt;component directive filters 本身具备的</div><div class="line">			mergeFild(key)</div><div class="line">		&#125;</div><div class="line">		for(key in child)&#123; //child =&gt;el data component 外部传参进来</div><div class="line">			if(!has(parent,key))&#123; //拦截重复操作</div><div class="line">				mergeFild(key)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//选项的处理celve</div><div class="line">		function mergeFild(key)&#123;</div><div class="line">			//生成最终需要数据</div><div class="line">			//合并策略 自定义策略 默认策略</div><div class="line">			console.log(key)</div><div class="line">			var strat = strats[key] || defaultStrats</div><div class="line">			options[key] = strat(parent[key],child[key],vm)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		return options</div><div class="line">	&#125;</div><div class="line">	function initMixin(vue)&#123;</div><div class="line"></div><div class="line">		Vue.prototype._init = function(options)&#123;</div><div class="line">			var vm = this</div><div class="line">			//合并选项 VUE.option option</div><div class="line">			vm.$options = mergeOption(Vue.options,options||&#123;&#125;,vm)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	function initGlobalAPI(Vue)&#123;</div><div class="line">		var configDef = &#123;&#125;;</div><div class="line">		configDef.get = function()&#123;</div><div class="line">			return config</div><div class="line">		&#125;</div><div class="line">		configDef.set = function(val)&#123;</div><div class="line">			console.error(&apos;不要修改config&apos;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	function Vue(options)&#123;</div><div class="line">		if(!(this instanceof Vue))&#123;</div><div class="line">			console.error(&apos;....&apos;)</div><div class="line">		&#125;</div><div class="line">		this._init(options)</div><div class="line">	&#125;</div><div class="line">	Vue.options = Object.create(null);</div><div class="line">	ASSET_TYPES.foreach(function(type)&#123;</div><div class="line">		Vue.options[type] = Object.create(null)</div><div class="line">	&#125;)</div><div class="line">	initMixin(Vue)</div><div class="line">	return Vue</div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/lifecycle.png&quot; alt=&quot;Vue声明周期&quot;&gt;&lt;br&gt;初始化之后调用$mount会挂载组件编译template&lt;/p&gt;
&lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react-navigation</title>
    <link href="http://yoohannah.github.io/post/knowledge/reactNativeNavigation.html"/>
    <id>http://yoohannah.github.io/post/knowledge/reactNativeNavigation.html</id>
    <published>2019-06-02T13:11:37.000Z</published>
    <updated>2019-06-02T13:11:46.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yarn add react-navigation</div><div class="line">yarn add react-native-gesture-handler</div><div class="line">react-native link react-native-gesture-handler //Link 所有的原生依赖</div></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">APP.js</div><div class="line">import React from &quot;react&quot;; </div><div class="line">import &#123; View, Text &#125; from &quot;react-native&quot;;</div><div class="line">import &#123; createStackNavigator, createAppContainer &#125; from &quot;react-navigation&quot;; </div><div class="line">class HomeScreen extends React.Component &#123;</div><div class="line">     render() &#123;</div><div class="line">          return (</div><div class="line">               &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125;&gt; </div><div class="line">                    &lt;Text&gt;Home Screen&lt;/Text&gt; </div><div class="line">               &lt;/View&gt; ); </div><div class="line">    &#125; &#125; </div><div class="line">const AppNavigator = createStackNavigator(</div><div class="line">    &#123;</div><div class="line">        HomeComponent: &#123; screen: HomeScreenComponent &#125; //screen属性设置组件路由,HomeScreen只是一个组件</div><div class="line">        Home: HomeScreen,//直接配置页面路由</div><div class="line">        Details: DetailsScreen</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        initialRouteName: &quot;Home&quot;//指定默认路由</div><div class="line">        defaultNavigationOptions: &#123; //指定全局默认标题样式</div><div class="line">            headerStyle: &#123;</div><div class="line">                backgroundColor: &apos;#f4511e&apos;,</div><div class="line">            &#125;,</div><div class="line">            headerTintColor: &apos;#fff&apos;,</div><div class="line">            headerTitleStyle: &#123;</div><div class="line">                fontWeight: &apos;bold&apos;,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">    &#125;);</div><div class="line">const AppContainer = createAppContainer(AppNavigator);</div><div class="line">export default class App extends React.Component &#123;</div><div class="line">  someEvent() &#123;</div><div class="line">    // call navigate for AppNavigator here:</div><div class="line">    this.navigator &amp;&amp;</div><div class="line">      this.navigator.dispatch( //在 App 容器中使用 dispatch，可以使用 ref 来调用 dispatch 方法</div><div class="line">        NavigationActions.navigate(&#123; routeName: someRouteName &#125;)</div><div class="line">      );</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;AppContainer</div><div class="line">        //每当导航器管理的 navigation state 发生变化时，都会调用该函数 </div><div class="line">        onNavigationStateChange=&#123;handleNavigationChange&#125; </div><div class="line">        uriPrefix=&quot;/app&quot;//应用可能会处理的 URI 前缀， 在处理一用于提取传递给 route 的一个 深度链接时将会用到</div><div class="line">        ref=&#123;nav =&gt; &#123;</div><div class="line">          this.navigator = nav;</div><div class="line">        &#125;&#125;</div><div class="line">    /&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>this.props.navigation.navigate(路由名,传参对象)//跳转其他页，如果跳转本页，没反应<br>this.props.navigation.push(路由名)//可以重新加载当前页<br>每次调用 ‘ push ‘ 时, 我们会向导航堆栈中添加新路由。<br>当你调用 ‘ navigate ‘ 时, 它首先尝试查找具有该名称的现有路由, 并且只有在堆栈上没有一个新路由时才会推送该路由。<br>读取页面组件中的参数的方法：<br>this.props.navigation.state.params<br>this.props.navigation.getParam(key值)</p>
<p>如果当前页面可以执行返回操作，则 stack navigator 会自动提供一个包含返回按钮的标题栏<br>如果导航堆栈中只有一个页面，则没有任何可返回的内容，因此也不存在返回键。<br>this.props.navigation.goBack() //手动返回上一页</p>
<p>如果处在堆栈深处，上面有多个页面，此时想要将上面所有的页面都销毁，并返回第一个页面。<br>在这种情况下，我们知道我们要回到’ Home ‘，所以我们可以使用’ navigate(‘Home’) ‘,而不是<code>push</code><br>另一个选择是’ navigation.popToTop() ‘，它可以返回到堆栈中的第一个页面。</p>
<p>如何发现用户离开和回来的某页面？<br>一个包含 页面 A 和 B 的 StackNavigator ，当跳转到 A 时，componentDidMount 方法会被调用； 当跳转到 B 时，componentDidMount 方法也会被调用，但是 A 依然在堆栈中保持 被加载状态，他的 componentWillUnMount 也不会被调用。<br>当从 B 跳转到 A，B的 componentWillUnmount 方法会被调用，但是 A 的 componentDidMount方法不会被调用，应为此时 A 依然是被加载状态。<br>React Navigation 将事件发送到订阅了它们的页面组件： 有4个不同的事件可供订阅：willFocus、willBlur、didFocus 和 didBlur。</p>
<h2 id="标题栏"><a href="#标题栏" class="headerlink" title="标题栏"></a>标题栏</h2><p>使用 组件静态属性navigationOptions</p>
<h3 id="内容配置"><a href="#内容配置" class="headerlink" title="内容配置"></a>内容配置</h3><p>title属性<br>方式一:对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static navigationOptions = &#123;</div><div class="line">    title: &apos;Home&apos;,</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>方式二：返回对象的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static navigationOptions = (&#123; navigation &#125;) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">      title: navigation.getParam(&apos;otherParam&apos;, &apos;A Nested Details Screen&apos;),</div><div class="line">    &#125;;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>尝试在navigationOptions中使用this.props可能很诱人，但因为它是组件的静态属性，所以this不会指向一个组件的实例，因此没有 props 可用。 相反，如果我们将navigationOptions作为一个函数，那么React Navigation将会用包含{navigation，navigationOptions，screenProps}的对象调用它 – 在这种情况下，我们只用关心navigation，它是与传递给页面的this.props.navigation相同的对象</p>
<p>从已加载的页面组件本身更新当前页面的navigationOptions配置<br>this.props.navigation.setParams({otherParam: ‘Updated!’})</p>
<h3 id="标题样式"><a href="#标题样式" class="headerlink" title="标题样式"></a>标题样式</h3><p>headerStyle：一个应用于 header 的最外层 View 的 样式对象， 如果设置 backgroundColor ，他就是header 的颜色。对象<br>headerTintColor：返回按钮和标题都使用这个属性作为它们的颜色。字符串<br>headerTitleStyle：如果想为标题定制fontFamily，fontWeight和其他Text样式属性，我们可以用它来完成。对象</p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>配置路由时利用defaultNavigationOptions配置<br>当全局设置了默认样式，具体页面也设置了static navigationOptions，则优先使用具体页面</p>
<h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><p>headerTitle：配置一个组件，自定义标题的样式<br>headerRight：自定义右侧按钮<br>headerLeft：自定义左侧/返回按钮<br>headerBackImage：自定义返回按钮图片<br>注意在navigationOptions中this绑定的不是 HomeScreen 实例，所以你不能调用setState方法和其上的任何实例方法。 这一点非常重要，因为标题栏中的按钮与标题栏所属的页面进行交互是非常常见的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react-navigation&quot;&gt;&lt;a href=&quot;#react-navigation&quot; class=&quot;headerlink&quot; title=&quot;react-navigation&quot;&gt;&lt;/a&gt;react-navigation&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a hr
    
    </summary>
    
    
      <category term="reactNative" scheme="http://yoohannah.github.io/tags/reactNative/"/>
    
  </entry>
  
  <entry>
    <title>二级菜单实现</title>
    <link href="http://yoohannah.github.io/post/vue/vuesubmenu.html"/>
    <id>http://yoohannah.github.io/post/vue/vuesubmenu.html</id>
    <published>2019-04-12T08:38:15.000Z</published>
    <updated>2019-04-12T00:02:36.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>page A是一个管理页面，数据通过table 展示<br>page B是一个详情页面，通过page A 中的一条数据跳转链接进来<br>page B数据获取时的参数需要在page A跳转时带进来<br>page B 本来只是一个简单页面,现在要在page B中添加一列菜单，可以导航多个不同内容详情<br>即现在page A要跳转的是一个带菜单的页面，点击每个菜单跳转不同的页面</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>1.vue-router配置时，children属性配置的子页面，在访问时，会在父页面的router-view标签部分进行填充<br>如果父页面没有router-view标签子页面内容就没地方展示<br>菜单就放在父页面，点击跳转子页面路由<br>2.因为页面跳转完成后，当前路由对象不会携带自己的children属性，给子路由配置title，父页面拿不到<br>所以父页面的菜单映射关系需要在其他地方配置，传递进来</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>子菜单名和对应路由的映射，放在page A跳转配置中，page A 配置的点击跳转的页面是其中一个子路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;title: &apos;名称&apos;, value: &apos;name&apos;, display: true,</div><div class="line">      shadow: &#123;path: &apos;Adetail_C&apos;, key: &apos;&apos;,title:&apos;AAAA&apos;,submenu:[&#123;</div><div class="line">        path:&apos;Adetail_C&apos;,name:&apos;C&apos;</div><div class="line">      &#125;,&#123;</div><div class="line">        path:&apos;Adetail_D&apos;,name:&apos;D&apos;</div><div class="line">      &#125;]&#125;, </div><div class="line">    &#125;,</div></pre></td></tr></table></figure></p>
<p>新增子菜单路由页面page A-detail-router,子菜单映射页面page C和page D</p>
<p>页面page A-detail-router中，可以通过this.$route对象拿到page A配置的菜单映射关系，从而渲染菜单<br>切换子页面时,需要增加把参数传递到子页面中的逻辑</p>
<p>page C和page D根据路由中传递过来的page A点击数据的信息进行数据请求和页面渲染</p>
<p>在项目路由配置文件中配置路由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; path: &apos;A&apos;,  name: &apos;A&apos;, title: &apos;XX管理&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/pageA&apos;) &#125;,</div><div class="line">&#123; path: &apos;AdetailRouter&apos;,  name: &apos;AdetailRouter&apos;, title: &apos;XX详情&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/A-detail-router&apos;), </div><div class="line">    children:[&#123;</div><div class="line">    path:&apos;/Adetail_C&apos;,name: &apos;Adetail_C&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;, component: () =&gt; import(&apos;@/Adetail_C&apos;)</div><div class="line">    &#125;,&#123;</div><div class="line">    path:&apos;/Adetail_D&apos;,name: &apos;Adetail_D&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;,component: () =&gt; import(&apos;@/Adetail_D&apos;)</div><div class="line">    &#125;]</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>children配置path时，以‘/’开头和不以‘/’开头区别：<br>以’/‘开头最终访问路径就是配置路径‘#/子path’，相当于子路由当一级路由<br>但不以‘/’开头最终的访问路径是‘#/父path/子path’,<br>这里使用‘/’开头是因为更外层菜单，在跳转page A同级路由时使用的是push({path:xxx})<br>如果使用不以‘/’开头的配置，跳转page A同级路由，路径就会变成‘#/父path/xxx’，即父路径下跳转<br>会因为没有相应配置路由找不到页面，所以使用‘/’开头，当作父路由跳转<br>其实在跳转page A同级路由时使用的是push({name:xxx}),就可以直接解决‘#/父path/xxx’问题，<br>跳转正确页面</p>
<p>缺点：<br>直接通过浏览器刷新子页面时，路由对象的params属性数据清空，<br>路由页面菜单映射没有数据支持，菜单没有内容<br>子页面路由因此也拿不到参数，无法请求数据<br>动作流向只有利用路由对象的meta属性的previousMenu跳转回page A</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>子菜单名和对应路由的映射放在单独json文件中，利用子菜单名字获取映射关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//submenu.json</div><div class="line">&#123;</div><div class="line">    Adetail:&#123;</div><div class="line">        title:&apos;AAAA&apos;</div><div class="line">        submenu:[&#123;</div><div class="line">            name:&apos;Adetail_C&apos;,//路由里配置的name</div><div class="line">            label:&apos;C&apos;,</div><div class="line">            show:true //之后根据路由参数query决定是否显示该菜单</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            name:&apos;Adetail_  D&apos;,</div><div class="line">            label:&apos;D&apos;,</div><div class="line">            show:true</div><div class="line">        &#125;]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在路由页面page A-detail-router中根据访问的子菜单路由名获取二级菜单,这样解决刷新页面菜单数据无处获取的问题</p>
<p>使用动态路由传递参数id保证页面刷新时子页面params至少有一个属性可以依赖来获取数据<br>更改路由配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123; path: &apos;A&apos;,  name: &apos;A&apos;, title: &apos;XX管理&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/pageA&apos;) &#125;,</div><div class="line">&#123; path: &apos;Adetail&apos;,  name: &apos;Adetail&apos;, title: &apos;XX详情&apos;, meta: &#123;keepAlive: true&#125;, component: () =&gt; import(&apos;@/A-detail-router&apos;), </div><div class="line">    children:[&#123;</div><div class="line">    path:&apos;C/:id&apos;,name: &apos;Adetail_C&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;, component: () =&gt; import(&apos;@/Adetail_C&apos;)</div><div class="line">    &#125;,&#123;</div><div class="line">    path:&apos;D/:id&apos;,name: &apos;Adetail_D&apos;,meta: &#123;previousMenu: &apos;A&apos;&#125;,component: () =&gt; import(&apos;@/Adetail_D&apos;)</div><div class="line">    &#125;]</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>‘：id’对应路由对象中params属性的id属性，所以访问时，一定要在跳转的路由中配置{params:{id:xxxxxx}}<br>更改路由页面page A-detail-router中跳转其他路由页面时,参数配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gotoPage (val,index) &#123;</div><div class="line">    this.active = index</div><div class="line">    this.$router.push(&#123;</div><div class="line">        name: val.name,</div><div class="line">        params:&#123;id:this.$route.params.id&#125;, //给其他子页面传递id</div><div class="line">        query:this.$route.query//其他自定义参数</div><div class="line">    &#125;)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>这样访问子页面时路径就变成’#/Adetail/C/xxxxxxxxxxxxxxxx’<br>以上处理基本解决掉方案一问题</p>
<p>后续需要根据page A 数据的其他属性值决定菜单显示,所以在配置跳转时配置要传递的属性key<br>在跳转时，根据KEY获取值，组装成都对象，放在query中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//配置：</div><div class="line">&#123;title: &apos;名称&apos;, value: &apos;dbname&apos;, display: true,link: &#123;path: &apos;databaseDetail_outline&apos;, key: &apos;dbinstance_id&apos;,query:[&apos;dbtype.dbtype&apos;]&#125;&#125;</div><div class="line">link属性即与跳转相关的配置，</div><div class="line">path:跳转路由名</div><div class="line">key:以数据哪个属性当id，字符串</div><div class="line">query:需要传递的其他参数，字符串数组</div><div class="line">//列表点击跳转</div><div class="line">jump (item, val) &#123;</div><div class="line">     //根据key获取值，key对应的可能不是子属性，而是孙属性，或者更深层次属性，valueFromExpression函数用于获取深层属性值</div><div class="line">    let id = valueFromExpression(item, val.link.key) </div><div class="line">    let router = &#123;</div><div class="line">        name: val.link.path,</div><div class="line">        params: &#123;id: id&#125;</div><div class="line">    &#125;</div><div class="line">    if(val.link.query)&#123;//根据key值组装传参对象</div><div class="line">        router.query = val.link.query.map(key=&gt;&#123;return &#123;[key]:valueFromExpression(item, key)&#125;&#125;).reduce((result,item)=&gt;&#123;return Object.assign(result,item)&#125;,&#123;&#125;)</div><div class="line">    &#125;</div><div class="line">    this.$router.push(router)</div><div class="line">    &#125;,</div></pre></td></tr></table></figure></p>
<p>因为打算将路由页面page A-detail-router作为公共页面，page A同级页面的其他页面也可以使用<br>所以将判断子菜单是否显示的逻辑放在跳转的那个子页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div></pre></td><td class="code"><pre><div class="line">//page A-detail-router</div><div class="line">&lt;template&gt;</div><div class="line">    &lt;div class=&quot;subcontainer&quot; v-if=&quot;submenuConfig&quot;&gt;</div><div class="line">      &lt;div class=&quot;submenu&quot;&gt;</div><div class="line">        &lt;!-- &lt;div  class=&quot;subTitle&quot; @click=&quot;goBack()&quot;&gt;&#123;&#123;submenuConfig.title&#125;&#125;&lt;/div&gt; --&gt;</div><div class="line">        &lt;div  class=&quot;subTitle&quot; @click=&quot;goBack()&quot;&gt;&lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt;&lt;/div&gt;</div><div class="line">        &lt;template v-for=&quot;(item,index) in submenuConfig.submenu&quot;&gt;</div><div class="line">          &lt;div v-if=&apos;item.show&apos; @click=&quot;gotoPage(item,index)&quot; :key=&quot;index&quot; class=&quot;subbtn&quot; :class=&quot;active===index?&apos;subactive&apos;:&apos;&apos;&quot;&gt;</div><div class="line">            &lt;a&gt;&#123;&#123;item.label&#125;&#125;&lt;/a&gt;</div><div class="line">          &lt;/div&gt;</div><div class="line">        &lt;/template&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">      &lt;div class=&quot;content&quot;&gt;</div><div class="line">        &lt;router-view&gt;&lt;/router-view&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  import submenuText from &apos;../../../common/submenu&apos;</div><div class="line">  export default &#123; </div><div class="line">    name: &apos;submenu_detail&apos;,</div><div class="line">    data() &#123;</div><div class="line">      return &#123;</div><div class="line">        submenuConfig:null,</div><div class="line">        active:0</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    mounted() &#123;</div><div class="line">      let routeName = this.$route.name</div><div class="line">      this.submenuConfig = submenuText[routeName.split(&apos;_&apos;)[0]] //获取菜单配置</div><div class="line">      this.active = this.submenuConfig.submenu.findIndex((item)=&gt;&#123;return item.name === routeName&#125;)</div><div class="line">    &#125;,</div><div class="line">    methods: &#123;</div><div class="line">      gotoPage (val,index) &#123;</div><div class="line">        this.active = index</div><div class="line">        this.$router.push(&#123;</div><div class="line">          name: val.name,</div><div class="line">          params:&#123;id:this.$route.params.id&#125;,</div><div class="line">          query:this.$route.query</div><div class="line">        &#125;)</div><div class="line">      &#125;,</div><div class="line">      goBack()&#123;</div><div class="line">        this.$router.push(&#123;</div><div class="line">          name:this.$route.meta.previousMenu</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    components: &#123;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;style lang=&quot;less&quot; scoped&gt;</div><div class="line">  .subcontainer&#123;</div><div class="line">    display: flex;</div><div class="line">    flex-grow: row  nowrap;</div><div class="line">    justify-content: space-between;</div><div class="line">    align-content:stretch;</div><div class="line">    margin: -20px;</div><div class="line">    .submenu&#123;</div><div class="line">      display: flex;</div><div class="line">      flex-flow: column;</div><div class="line">      align-content: center;</div><div class="line">      width: 200px;</div><div class="line">      flex:none;</div><div class="line">      background-color: #EAEDF1;</div><div class="line">      height: 100%;</div><div class="line">      position: absolute;</div><div class="line">      .subTitle&#123;</div><div class="line">        //内容为标题时样式</div><div class="line">        // font-weight: bold;</div><div class="line">        // text-indent: 20px;</div><div class="line">        // height: 70px;</div><div class="line">        // line-height: 70px;</div><div class="line">        // background: #D9DEE4;</div><div class="line">        // overflow: hidden;</div><div class="line">        // text-overflow: ellipsis;</div><div class="line">        // white-space: nowrap;</div><div class="line">        font-weight: bold;</div><div class="line">        height: 70px;</div><div class="line">        line-height: 70px;</div><div class="line">        background: #D9DEE4;</div><div class="line">        font-size: 20px;</div><div class="line">        color: #546478;</div><div class="line">        text-align: center</div><div class="line">      &#125;</div><div class="line">      .subTitle:hover&#123;</div><div class="line">        color: #0080FF;</div><div class="line">      &#125;</div><div class="line">      .subbtn&#123;</div><div class="line">        width: 100%;</div><div class="line">        font-size: 15px;</div><div class="line">        text-align: center;</div><div class="line">        padding: 10px 0px;</div><div class="line">        a&#123;</div><div class="line">          color:#000;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      .subbtn:hover&#123;</div><div class="line">        background-color: #f8f8f8;</div><div class="line">        background: #f8f8f8;</div><div class="line">      &#125;</div><div class="line">      .subactive&#123;</div><div class="line">          background-color: #fff;</div><div class="line">        background: #fff;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    .content&#123;</div><div class="line">      flex:1;</div><div class="line">      padding: 20px;</div><div class="line">      margin-left: 200px;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">//子菜单页面</div><div class="line">mounted() &#123;</div><div class="line">      if(this.$route.query[&apos;dbtype.dbtype&apos;] != &apos;mysql&apos;)&#123;</div><div class="line">        this.$parent.submenuConfig.submenu[1].show = false</div><div class="line">      &#125;else&#123;</div><div class="line">        this.$parent.submenuConfig.submenu[1].show = true</div><div class="line">      &#125;</div><div class="line">      this.getDetail(this.$route.params.id)</div><div class="line">    &#125;,</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;page A是一个管理页面，数据通过table 展示&lt;br&gt;page B是一个详情页面，通过page A 中的一条数据跳转链接进来&lt;br&gt;p
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack应用</title>
    <link href="http://yoohannah.github.io/post/performance/webpackconfig.html"/>
    <id>http://yoohannah.github.io/post/performance/webpackconfig.html</id>
    <published>2019-03-10T09:08:02.000Z</published>
    <updated>2019-06-22T09:14:11.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line">module.export = &#123;</div><div class="line">	entry:&apos;./main.js&apos;,</div><div class="line">	output:&#123;</div><div class="line">		filename:&apos;bundle.js&apos;,</div><div class="line">		path:path.resolve(__dirname,&apos;./dist&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="接入babel"><a href="#接入babel" class="headerlink" title="接入babel"></a>接入babel</h1><h2 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置.babelrc</h2><p>需要额外配置.babelrc文件，该文件是一个JSON格式文件<br>plugins属性，告诉Babel要使用哪些插件，这些插件可以控制如何转换代码<br>babel-plugin-transform-runtime：减少冗余代码<br>babel-runtime:可以导入babel-plugin-transform-runtime依赖的辅助函数<br>以上二者需要配套使用<br>presents属性，告诉Babel要转换的源码使用了那些新的语法特性，其值是一组plugins数组，<br>每一项，<br>如果不需要配置参数则使用字符串，表示插件名；<br>如果需要配置参数则使用数组，数组第一项为插件名，第二项为配置项组成的对象；<br>可以分为三大类：<br>1.已经被写入ES标准的特性：ES2015,ES2016,ES2017,Env (包含当前所有ES标准里的新特性)<br>2.社区提出但还未写入ES标准的特性：stage0,stage1,stage2,stage3,stage4,分别表示被纳入es标准的进度<br>3.特定场景下的语法特性，和es标准没有关系，例如要支持JSX，则使用babel-preset-react</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;plugins&quot;:[[&quot;transform-runtime&quot;,&#123;&quot;polyfill&quot;:false&#125;]]</div><div class="line">	&quot;presents&quot;:[[&quot;es2015&quot;,&#123;&quot;modules&quot;:false&#125;],&quot;stage-4&quot;,&quot;react&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>Babel是转换代码功能，所以要配置相应loader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">modules:&#123;</div><div class="line">  rules:[&#123;</div><div class="line">    test:/\.js$/,</div><div class="line">    use:[&apos;babel-loader&apos;]</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="安装依赖模块"><a href="#安装依赖模块" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm i -D babel-core babel-loader //webpack配置相关依赖</div><div class="line">npm i -D babel-preset-env</div><div class="line">npm i -D babel-preset-* //配置文件中的相关依赖</div></pre></td></tr></table></figure>
<h1 id="使用TypeScript"><a href="#使用TypeScript" class="headerlink" title="使用TypeScript"></a>使用TypeScript</h1><h2 id="配置-tsconfig-json文件"><a href="#配置-tsconfig-json文件" class="headerlink" title="配置 tsconfig.json文件"></a>配置 tsconfig.json文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;compilerOptions&quot;:&#123;</div><div class="line">	&quot;module&quot;:&quot;commonjs&quot;,//编译的代码采用的模块规范</div><div class="line">	&quot;target&quot;:&quot;es5&quot;,//编译出的代码采用es哪个版本</div><div class="line">	&quot;sourceMap&quot;:true,//输出Source Map 以方便调试</div><div class="line">	&quot;importHelpers&quot;:true//禁止辅助函数重复出现在多个文件</div><div class="line">&#125;,</div><div class="line">&quot;exclude&quot;:[</div><div class="line">	&quot;node_modules&quot;</div><div class="line">]</div></pre></td></tr></table></figure>
<h2 id="webpack配置-1"><a href="#webpack配置-1" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>使用loader做转换；修改文件查找规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">resolve:&#123;</div><div class="line">	extension:[&apos;.ts&apos;,&apos;.js&apos;]</div><div class="line">&#125;</div><div class="line">modules:&#123;</div><div class="line">  rules:[&#123;</div><div class="line">    test:/\.ts$/,</div><div class="line">    loader:&apos;awesome-typescript-loader&apos;</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="安装依赖模块-1"><a href="#安装依赖模块-1" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -D typescript awesome-typescript-loader</div></pre></td></tr></table></figure>
<h1 id="使用Flow检查器"><a href="#使用Flow检查器" class="headerlink" title="使用Flow检查器"></a>使用Flow检查器</h1><h2 id="使用语法"><a href="#使用语法" class="headerlink" title="使用语法"></a>使用语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//@flow /*告诉检查器这个文件需要被检查*/</div><div class="line">function squarel(n:number):number&#123;</div><div class="line">	return n*n</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h2><p>1.全局使用<br>npm i -g flow-bin 将可执行文件安装在全局，直接在项目根目录下使用flow命令执行代码检查<br>2.局部使用<br>npm i -D flow-bin 在项目中生成可执行文件，仅在某个项目中使用，<br>在package.json中配置使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;script&quot;:&#123;</div><div class="line">	&quot;flow&quot;:&quot;flow&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 npm run flow 执行代码检查</p>
<h2 id="去除静态语法"><a href="#去除静态语法" class="headerlink" title="去除静态语法"></a>去除静态语法</h2><p>采用flow静态语法的js无法在引擎中运行，所要去掉<br>1.使用flow-remove-types<br>2.一般使用flow的项目会使用es6,所以集成到babel配置中，<br>安装依赖模块：npm i -D babel-preset-flow<br>修改.babelrc,在preset中加入’flow’：”presets”:[…[],”flow”]</p>
<h1 id="使用SCSS"><a href="#使用SCSS" class="headerlink" title="使用SCSS"></a>使用SCSS</h1><p>SCSS又叫做SASS，可以使用一定语法编写css样式<br>转换方式<br>1.全局单文件转换<br>全局安装node-sass:npm i -g node-sass<br>执行命令：node-sass main.scss main.css  //main.css即main.scss编译后的css文件</p>
<p>2.使用sass-loader</p>
<h2 id="webpack配置-2"><a href="#webpack配置-2" class="headerlink" title="webpack配置"></a>webpack配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">modules:&#123;</div><div class="line">  rules:[&#123;</div><div class="line">    test:/\.scss$/,</div><div class="line">    use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;]</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="安装依赖模块-2"><a href="#安装依赖模块-2" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><p>npm i -D style-loader css-loader sass-loader //webpack loader<br>npm i -D node-sass //sass-loader 依赖node-sass</p>
<h2 id="具体处理流程"><a href="#具体处理流程" class="headerlink" title="具体处理流程"></a>具体处理流程</h2><p>sass-loader将scss源码转换为css,再将css代码交给css-loader<br>css-loader会找出css代码中@import 和 url()这样的导入语句，告诉webpack依赖这些资源，同时支持CSS modules,压缩CSS等功能<br>处理完后将结果给到style-loader<br>style-loader 会将CSS代码转换成字符串后，注入到js代码中，通过js向DOM增加样式，<br>如果想将css提取到单独文件中，可再使用ExtractTextPlugin插件提取</p>
<h1 id="使用PostCSS"><a href="#使用PostCSS" class="headerlink" title="使用PostCSS"></a>使用PostCSS</h1><p>使用相应的loader 可以为css样式增加兼容浏览器的前缀，可以配置相应的配置文件，兼容下一代CSS语法</p>
<h2 id="配置postcss-config-js文件"><a href="#配置postcss-config-js文件" class="headerlink" title="配置postcss.config.js文件"></a>配置postcss.config.js文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">	plugins:[</div><div class="line">		require(&apos;postcss-cssnext&apos;) //postcss-cssnext支持下一代css语法编写</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="webpack配置-3"><a href="#webpack配置-3" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>需要先将下一代语法转换成可识别css,同时添加前缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">modules:&#123;</div><div class="line">  rules:[&#123;</div><div class="line">    test:/\.scss$/,</div><div class="line">    use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;postcss-loader&apos;]</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="安装依赖模块-3"><a href="#安装依赖模块-3" class="headerlink" title="安装依赖模块"></a>安装依赖模块</h2><p>npm i -D style-loader css-loader postcss-loader //webpack loader 依赖<br>npm i -D postcss-cssnext // postcss-loader 依赖 </p>
<h1 id="使用react"><a href="#使用react" class="headerlink" title="使用react"></a>使用react</h1><h2 id="借助Bable"><a href="#借助Bable" class="headerlink" title="借助Bable"></a>借助Bable</h2><p>1.修改配置文件.babelrc，在preset中加入’react’：”presets”:[…[],”react”]<br>2.安装依赖模块<br>npm i -D react react-dom//react 基础依赖<br>npm i -D bable-preset-react //bable转换依赖</p>
<h2 id="借助typescript"><a href="#借助typescript" class="headerlink" title="借助typescript"></a>借助typescript</h2><p>1.修改配置文件tsconfig.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;compilerOptions&quot;:&#123;</div><div class="line">	...,</div><div class="line">	&quot;jsx&quot;:&quot;react&quot;//typescript本身支持jsx,开启JSX，支持react</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>2.修改webapck配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">resolve:&#123;</div><div class="line">	extension:[&apos;.ts&apos;,&apos;.tsx&apos;,.js&apos;] //typescript 原生支持jsx语法，只不过jsx语法文件后缀必须是tsx</div><div class="line">&#125;</div><div class="line">modules:&#123;</div><div class="line">  rules:[&#123;</div><div class="line">    test:/\.tsx?$/,//同时匹配ts,tsx后缀文件</div><div class="line">    loader:&apos;awesome-typescript-loader&apos;</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.安装依赖模块<br>npm i -D react react-dom//react 基础依赖<br>npm i -D @types/react @types/react-dom //react react-dom对应的ts接口描述模块，用于编译react，react-dom</p>
<h1 id="使用VUE"><a href="#使用VUE" class="headerlink" title="使用VUE"></a>使用VUE</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>1.修改webapck配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">modules:&#123;</div><div class="line">  rules:[&#123;</div><div class="line">    test:/\.vue$/,</div><div class="line">    use:[&apos;vue-loader&apos;]</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.安装依赖模块<br>npm i -S vue //vue框架依赖<br>npm i -D vue-loader css-loader vue-template-compiler //构建所需依赖<br>歌loader作用<br>vue-loader:解析转换.vue文件，提取其中的逻辑代码script样式代码style以及html模板template,然后交给对应的loader去处理<br>css-loader:加载vue-loader提取的CSS代码<br>vue-template-compiler：将vue-loader提取的HTML模板编译成对应可执行的js代码。</p>
<h2 id="构建使用ts编写的vue"><a href="#构建使用ts编写的vue" class="headerlink" title="构建使用ts编写的vue"></a>构建使用ts编写的vue</h2><p>1.配置 tsconfig.json文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;compilerOptions&quot;:&#123;</div><div class="line">	&quot;target&quot;:&quot;es5&quot;,//构建es5版本的js,与VUE浏览器支持保持一致</div><div class="line">	&quot;module&quot;:&apos;es015&apos;,//使用es2015模块化格式</div><div class="line">	&quot;strict&quot;:true,//开启严格模式，对this上数据属性进行严格推断</div><div class="line">	&quot;moduleResolution&quot;:&apos;node&apos;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>2.webpack配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">resolve:&#123;</div><div class="line">	extension:[&apos;.ts&apos;,&apos;.js&apos;,&apos;.vue&apos;,&apos;json&apos;] //增加对.ts，.vue文件支持</div><div class="line">modules:&#123;</div><div class="line">  rules:[&#123;</div><div class="line">    test:/\.ts$/,//匹配ts后缀文件</div><div class="line">    loader:&apos;ts-loader&apos;,</div><div class="line">    exclude:/node_modules/,</div><div class="line">    options:&#123;</div><div class="line">    	appendTsSuffixTo:[/\.vue$/] //让tsc将vue文件当成一个ts模块去处理，以解决module not found的问题，tsc本身不会处理.vue结尾文件</div><div class="line">    &#125;</div><div class="line">  &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.新增文件vue-shims.d.ts<br>用以ts支持.vue结尾文件，可识别import 语句导入的.vue文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">declare module &quot;*.vue&quot;&#123;</div><div class="line">	import Vue from &quot;vue&quot;;</div><div class="line">	export default Vue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.vue文件编写<br>script 部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script lang=&apos;ts&apos;&gt;//lang指明代码语法为ts</div><div class="line">improt Vue from &quot;vue&quot;</div><div class="line">export default Vue.extend(&#123; //Vue.extend启用ts类型推断</div><div class="line">	data()&#123;</div><div class="line">		return&#123;</div><div class="line">			msg:&apos;hello world&apos;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">&lt;/script</div></pre></td></tr></table></figure></p>
<p>5.安装依赖<br>npm i -D ts-loader typescript</p>
<h1 id="单页自动生成html"><a href="#单页自动生成html" class="headerlink" title="单页自动生成html"></a>单页自动生成html</h1><p>利用模板文件和插件生成</p>
<h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><p>模板文件用于描述哪些资源需要被以某种方式加入到输出的HTML文件中<br>资源链接URL字符串里问号前面的部分表示资源内容来自哪里，后面的参数表示这些资源注入的方式,可用&amp;链接<br>_inline:资源是要引入动态资源<br>_dist:只在生产环境下才引入该资源<br>_dev:只在开发环境才引入该资源<br>_ie:只在IE浏览器中引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">     &lt;!--导入chunck app 中的css代码，可知要将css单独打包一个文件--&gt;</div><div class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;app?_inline&quot;&gt;</div><div class="line">    &lt;!--在这里引入/google_analytics的js代码--&gt;</div><div class="line">    &lt;script src=&quot;./google_analytics.js?_inline&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div id=&apos;app&apos;&gt;&lt;/div&gt;</div><div class="line">    &lt;!--导入chunck app 中的js代码--&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;app&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="webpack配置-4"><a href="#webpack配置-4" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>使用web-webpack-plugin的webplugin自动生成index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;)</div><div class="line">plugins:[</div><div class="line">	new WebPlugin(&#123;//自动生成index.html文件</div><div class="line">		template:&apos;./template.html&apos;,//模板文件</div><div class="line">		filename:&apos;index.html&apos;//输出文件名</div><div class="line">	&#125;)，</div><div class="line">	new ExtractTextPlugin(&#123;</div><div class="line">		filename:`[name]_[contenthas:8].css` // 为输出的css文件名称加上Hash值</div><div class="line">	&#125;)，</div><div class="line">	new DefinePlugin(&#123;</div><div class="line">		&apos;process.env&apos;:&#123;//定义NODE_ENV环境变量为production，去除源码中只有开发时才需要的部分</div><div class="line">			NODE_ENV:JSON.stringify(&apos;production&apos;)</div><div class="line">		&#125;</div><div class="line">	&#125;)，</div><div class="line">	new UglifyJsPlugin(&#123;//压缩输出的js代码</div><div class="line">		beautify:false,//最紧凑的输出</div><div class="line">		comments:false,//删除所有注释</div><div class="line">		compress:&#123;</div><div class="line">			warnings:false,//删除没有用到的代码时，不发出警告</div><div class="line">			drop_console:true,//删除所有console语句，兼容IE</div><div class="line">			collapse_vars:true,//内嵌已定义但只用到了一次的变量</div><div class="line">			reduce_vars:true//提取出出现多次但没有定义成变量去引用的静态值</div><div class="line">		&#125;</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">]</div></pre></td></tr></table></figure></p>
<h1 id="自动生成多个单页"><a href="#自动生成多个单页" class="headerlink" title="自动生成多个单页"></a>自动生成多个单页</h1><p>需要解决的问题<br>1.要能够将公共代码提取出来，并能够注入到每个单页应用中<br>2.模板文件要支持注入公共文件和各个单页独自依赖的资源</p>
<h2 id="模板文件-1"><a href="#模板文件-1" class="headerlink" title="模板文件"></a>模板文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;!--在这里注入该页面所依赖但没有手动导入的CSS--&gt;</div><div class="line">    &lt;!--STYLE--&gt;</div><div class="line">    &lt;!--在这里引入/google_analytics的js代码--&gt;</div><div class="line">    &lt;script src=&quot;./google_analytics.js?_inline&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div id=&apos;app&apos;&gt;&lt;/div&gt;</div><div class="line">    &lt;!-- 在这里注入该页面所依赖但没有手动导入的JS--&gt;</div><div class="line">    &lt;!--SCRIPT--&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>此时模板文件被当作项目中所有单页的模板，因此不能直接写Chunck名称去引入资源，<br>因为需要被注入当前页面的Chunck名称不固定，每个单页都会有自己的名称<br><!--STYLE--><!--SCRIPT-->的作用在于保证该页面所依赖的资源都会被注入生成的HTML模板中<br>如果<!--STYLE-->不存在，就注入到head标签最后<br>如果<!--SCRIPT-->不存在，就注入到body标签最后</p>
<h2 id="webpack配置-5"><a href="#webpack配置-5" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>使用web-webpack-plugin的autoWebPlugin自动生成多个单页的index.html文件<br>但是对目录结构有要求，即所有单页各自的入口文件和依赖资源组成各自的一个文件夹，<br>多个文件夹放在同一目录A下，其他公共资源以及模板文件，webpack配置文件放在与A目录同级目录下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const &#123;AutoWebPlugin&#125; = require(&apos;web-webpack-plugin&apos;)</div><div class="line">const autoWebPlugin = new AutoWebPlugin(&apos;pages&apos;,&#123; //pages 为各个单页的父目录A</div><div class="line">	template:&apos;./template.html&apos;,//模板文件</div><div class="line">	postEntry:[&apos;./common.css&apos;],//所有页面都依赖这份通用的CSS样式文件</div><div class="line">	commonChunk：&#123;</div><div class="line">		name:&apos;common&apos;,//提取公共代码chunk的名称</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">module.exports=&#123;</div><div class="line">	//AutoWebPlugin会为寻找到的所有单页生成对应的入口配置，</div><div class="line">	//autoWebPlugin.entry可以获取所有由autoWebPlugin生成的入口配置</div><div class="line">	entry:autoWebPlugin.entry(&#123;//可加入额外需要的Chunk入口&#125;)，</div><div class="line">	plugins:[autoWebPlugin]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="构建基于react的同构应用"><a href="#构建基于react的同构应用" class="headerlink" title="构建基于react的同构应用"></a>构建基于react的同构应用</h1><p>同构应用：写一份代码可同时在浏览器和服务器中运行的应用<br>能在服务器运行的原理核心是虚拟DOM<br>虚拟DOM好处：<br>1.操作DOM树是高耗时操作，可通过DOM diff算法找到两个不同Object的最小差异，得出最小的DOM操作<br>2.虚拟DOM在渲染时不仅可以通过操作DOM树表示结果，也可以有其他表示方式，例如将虚拟DOM渲染成字符串(服务器渲染)<br>或者渲染成手机APP原生UI组件（react Native）</p>
<h2 id="服务器端构建配置"><a href="#服务器端构建配置" class="headerlink" title="服务器端构建配置"></a>服务器端构建配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line">const nodeExternals = require(&apos;webpack-node-externals&apos;)</div><div class="line">module.exports = &#123;</div><div class="line">	entry:&apos;./main_server.js&apos;</div><div class="line">	target:&apos;node&apos;,//目标运行环境是node.js,源码依赖的nodejs原生模块没必要打包进去</div><div class="line">	externals:[nodeExternals()],//不打包node_modules中的第三方组件</div><div class="line">	output:&#123;</div><div class="line">		libraryTarget:&apos;commonjs2&apos;,//输出CommonJS2规范，供nodejs的http服务器代码调用</div><div class="line">		fillname:&apos;bundle.server.js&apos;,</div><div class="line">		path:path(resolve(__dirname,&apos;./dist&apos;))</div><div class="line">	&#125;,</div><div class="line">	module:&#123;</div><div class="line">		rules:[</div><div class="line">			&#123;</div><div class="line">				test:/\.js$/,</div><div class="line">				use:[&apos;babel-loader&apos;],</div><div class="line">				exclude:path.resolve(__dirname,&apos;node_modules&apos;),</div><div class="line">			&#125;,</div><div class="line">			&#123;</div><div class="line">				test:/\.css/,</div><div class="line">				use:[&apos;ignore-loader&apos;],//css文件不能打包到服务端代码，影响服务端渲染性能</div><div class="line">			&#125;</div><div class="line">		]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件准备"><a href="#文件准备" class="headerlink" title="文件准备"></a>文件准备</h2><p>一个仅包含根组件代码，不能包含渲染入口代码，而且需要导出根组件以供渲染入口调用的文件 rootComponent.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import react,&#123;Component&#125; from &apos;react&apos;;</div><div class="line">import &apos;main.css&apos;</div><div class="line">export class RootComponent extends Component&#123;</div><div class="line">	render()&#123;</div><div class="line">		return &lt;h1&gt;hello world &lt;/h1&gt;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不同环境渲染入口文件，一个环境一个<br>main_server.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import react from &apos;react&apos;;</div><div class="line">import RootComponent from &apos;./rootComponent&apos;</div><div class="line">import &#123;renderToString&#125; from &apos;react-dom/server&apos; //计算表示虚拟DOM的HTML形式字符串</div><div class="line">export function render()&#123;</div><div class="line">	return renderToString(&lt;RootComponent&gt;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>main_browser.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import react from &apos;react&apos;;</div><div class="line">import RootComponent from &apos;./rootComponent&apos;</div><div class="line">import &#123;render&#125; from &apos;react-dom&apos; //操作浏览器DOM树展示出结果</div><div class="line">render(&lt;RootComponent&gt;,window.document.getElementById(&apos;app&apos;))</div></pre></td></tr></table></figure></p>
<p>http.server.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">const express = require(&apos;express&apos;)</div><div class="line">const &#123;render &#125; = require(&apos;./dist/bundle_server&apos;)</div><div class="line">const app = express();</div><div class="line">app.get(&apos;/&apos;,function(req.res)&#123;</div><div class="line">	res.send(`</div><div class="line">		&lt;html lang=&quot;en&quot;&gt;</div><div class="line">		  &lt;head&gt;</div><div class="line">		    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">		  &lt;/head&gt;</div><div class="line">		  &lt;body&gt;</div><div class="line">		    &lt;div id=&apos;app&apos;&gt;$&#123;render()&#125;&lt;/div&gt;</div><div class="line">		    &lt;!--导入WEBPACK输出的用于浏览器端渲染的js文件--&gt;</div><div class="line">		    &lt;script src=&apos;./dist/bundle_browser.js&apos;&gt;&lt;/script&gt;</div><div class="line">		  &lt;/body&gt;</div><div class="line">		&lt;/html&gt; </div><div class="line">	`)</div><div class="line">&#125;)</div><div class="line">app.use(express.static(&apos;.&apos;));</div><div class="line">app.listen(3000,function()&#123;</div><div class="line">	console.log(&apos;app is listening 3000&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>webpack –config webpac_server.config.js 得到./dist/bundle_server.js<br>webpack –config webpac.config.js 得到./dist/bundle_browser.js<br>node ./http_server.js 启动 http 服务器，访问’localhost:3000’看到服务器返回了html</p>
<h1 id="基于react-的Electron应用"><a href="#基于react-的Electron应用" class="headerlink" title="基于react 的Electron应用"></a>基于react 的Electron应用</h1><p> Electron 可以使用开发web应用的技术去开发跨平台的桌面应用，例如Atom，VSCode<br> 是nodejs和Chromium浏览器的结合体，用Chromium浏览器显示出的WEB页面作为应用的GUI，通过Nodejs和操作系统交互<br> 当操作一个Electron应用的一个窗口时，实际是在操作一个网页，当操作需要操作系统完成时，网页会通过Nodejs和操作系统交互<br> 优点<br> 1.降低了开发门槛，只需掌握网页开发技术和Nodejs,大量Web开发技术和现成库可以复用于Electron<br>   而且由于Electron环境内置了浏览器和Nodejs的API，在开发网页时除了可以使用浏览器提供的API，还可以会用Nodejs的API<br> 2.由于Chromium浏览器和Nodejs都是跨平台的，所有Electron能做到在不同操作系统运行一份代码</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>Electron 应用每个窗口对应一个网页，所以相当于需要构建多单页面应用<br>在网页JS代码中可能会调用Nodejs原生模块或者Electron模块，输出的代码依赖这些模块但由于这些模块都是内置支持的，<br>所有构建出的代码不能将这些模块打包进去<br>由于webpack内置了对Electron的支持，只需要告诉webpack我要在electron环境里运行就可以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">target:&apos;electron-renderer&apos;</div></pre></td></tr></table></figure></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>安装electron执行环境到项目中<br>npm i -D electron</p>
<p>在项目目录下执行electron ./就可以启动桌面应用</p>
<h1 id="构建Npm模块"><a href="#构建Npm模块" class="headerlink" title="构建Npm模块"></a>构建Npm模块</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>1.源码若采用es6编写需要转换成es5,并且要遵守commonjs规范，同时提供Source Map方便调式</p>
<p>解决:<br>使用Babel将es6转换成es5<br>通过开启devtool:’source-map’输出Source Map以发布调试<br>设置output.libraryTarget = ‘commonjs2’ 实现输出代码符合CommomJS2规范<br>2.若为UI组件，则依赖的其他资源文件如css文件也需要包含的发布的模块中</p>
<p>解决：通过css-loader,extract-text-webpack-plugin实现，将css打包到单独文件</p>
<p>3.尽量减少代码冗余，（例如，Babel将es6转换成es5时，会注入一些辅助函数，例如实现class,extend语法的辅助函数，Babel会在每个输出文件中中内嵌依赖的辅助函数，多文件依赖的话，就会造成辅助函数重复出现，造成代码冗余）减少发布出去的组件的代码文件大小</p>
<p>解决：通过引入相同函数解决重复代码<br>使用babel-plugin-transform-runtime 将嵌入辅助函数代码转成引入辅助函数<br>引入bable-runtime模块用于提供辅助函数</p>
<p>4.发布出去的组件代码中不能含有其依赖的模块代码，例如react,babel-runtime,而是让用户可选择性的安装，否则可能在其他模块也依赖相同模块时，造成重复打包</p>
<p>解决：配置externals将外部环境提供的模块屏蔽掉，不进行打包</p>
<h2 id="webpack配置-6"><a href="#webpack配置-6" class="headerlink" title="webpack配置"></a>webpack配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">	entry:&apos;./src/index.js&apos;</div><div class="line">	output:&#123;</div><div class="line">		fillname:&apos;index.js&apos;,</div><div class="line">		path:path.resolve(__dirname,&apos;lib&apos;),</div><div class="line">		libraryTarget:&apos;commonjs2&apos;,</div><div class="line">	&#125;,</div><div class="line">	externals:/^(react|babel-runtime)/,</div><div class="line">	module:&#123;</div><div class="line">		rules:[</div><div class="line">		&#123;</div><div class="line">			test:/\.js$/,</div><div class="line">			use:[&apos;babel-loader&apos;],</div><div class="line">			exclude:path.resolve(__dirname,&apos;node_module&apos;),</div><div class="line">		&#125;,</div><div class="line">		&#123;</div><div class="line">			test:/\.css/,</div><div class="line">			use:ExtractTextPlugin.extract(&#123;</div><div class="line">				use:[&apos;css-loader&apos;]</div><div class="line">			&#125;)</div><div class="line">		&#125;]</div><div class="line">	&#125;,</div><div class="line">	plugins:[</div><div class="line">		new ExtractTextPlugin(&#123;</div><div class="line">			fillname:&apos;index.css&apos;</div><div class="line">		&#125;)</div><div class="line">	],</div><div class="line">	devtool:&apos;source-map&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>.babellrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&apos;plugins&apos;:[</div><div class="line">		[</div><div class="line">			&apos;transform-runtime&apos;,//默认自动注入ES6 API的polyfill</div><div class="line">			&#123;</div><div class="line">				&apos;polyfill&apos;:false//防止使用者在其他地方注入其他polyfill库，所以关闭注入polyfill功能</div><div class="line">			&#125;</div><div class="line">		]</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="发布到Npm"><a href="#发布到Npm" class="headerlink" title="发布到Npm"></a>发布到Npm</h2><p>修改package.json入口文件为打包后的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">main:&apos;lib/index.js&apos;,//webpack使用于构建不可分割的NPM模块，不能保持同源码结构一致例如如果打包lodash，会将所有工具函数打包进去，不适合仅用几个工具函数的场景</div><div class="line">&apos;jsnext:main&apos;:&apos;src/index.js&apos;//指出采用ES6编写的模块入口文件位置，便于实现Tree Sharking</div></pre></td></tr></table></figure></p>
<h1 id="离线应用-service-workers打包"><a href="#离线应用-service-workers打包" class="headerlink" title="离线应用 service workers打包"></a>离线应用 service workers打包</h1><p><a href="/post/performance/cache/serviceworker.html">service workers了解</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1.如何生成sw.js文件<br>2.sw.js文件中的cacheFileList变量(代表被缓存文件的URL)，需要根据输出文件列表所对应的URL来决定，不能写成静态值</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用serviceworker-webpack-plugin,根据自定义sw.js生成含有输出文件列表的sw.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)</div><div class="line">const &#123;WebPlugin&#125; = require(&apos;web-webpack-plugin&apos;)</div><div class="line">const ServiceWorkerWebpackPlugin = require(&apos;serviceworker-webpack-plugin&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">	entry:&#123;</div><div class="line">		app:&apos;./main.js&apos; //Chunk app 的js执行入口文件</div><div class="line">	&#125;,</div><div class="line">	output:&#123;</div><div class="line">		fillname:&apos;[name].js&apos;,</div><div class="line">		publicPath:&apos;&apos;,</div><div class="line">	&#125;,</div><div class="line">	module:&#123;</div><div class="line">		rules:[</div><div class="line">		&#123;</div><div class="line">			test:/\.css/,//增加对CSS文件支持，</div><div class="line">			use:ExtractTextPlugin.extract(&#123;//提取到单独文件</div><div class="line">				use:[&apos;css-loader&apos;]//压缩CSS代码</div><div class="line">			&#125;)</div><div class="line">		&#125;]</div><div class="line">	&#125;,</div><div class="line">	plugins:[</div><div class="line">		//一个WebPlugin对应一个HTML</div><div class="line">	    new WebPlugin(&#123;</div><div class="line">	    	template:&apos;./template/html&apos;,//HTML模板文件所在的文件路径</div><div class="line">	    	fillname:&apos;index.html&apos;//输出的HTML文件名称</div><div class="line">	    &#125;),</div><div class="line">		new ExtractTextPlugin(&#123;</div><div class="line">			fillname:&apos;[name].css&apos;</div><div class="line">		&#125;),</div><div class="line">		new ServiceWorkerWebpackPlugin(&#123;</div><div class="line">			//自定义的sw.js文件所在路径</div><div class="line">			//ServiceWorkerWebpackPlugin会将文件列表注入生成的sw.js</div><div class="line">			entry:path.join(__dirname,&apos;sw.js&apos;)</div><div class="line">		&#125;)</div><div class="line">	],</div><div class="line">	devServer:&#123;</div><div class="line">		//Service workers依赖HTTPs,使用devServer提供https功能</div><div class="line">		https:true</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构建出的sw.js文件会在头部注入一个变量serviceWorkerOption.assets到全局，里面存放着所有需要被缓存的文件的URL列表<br>因此需要将sw.js文件中写成静态值的cacheFileList替换成serviceWorkerOption.assets<br>var cacheFileList = global.serviceWorkerOption.assets</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm -i -D web-webpack-plugin serviceworker-webpack-plugin</p>
<h1 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">	module:&#123;</div><div class="line">		rules:[</div><div class="line">		&#123;</div><div class="line">			test:/\.js$/,</div><div class="line">			exclude:/node_module/,//不检查node_module下文件</div><div class="line">			loader:&apos;tslint-loader&apos;,//整合typeScript代码检查</div><div class="line">			enforce:&apos;pre&apos;//将执行顺序放到最前面，防止其他Loader将处理后的代码交给tslint-loader检查</div><div class="line">		&#125;，&#123;</div><div class="line">			test:/\.js$/,</div><div class="line">			exclude:/node_module/,//不检查node_module下文件</div><div class="line">			loader:&apos;eslint-loader&apos;,//整合eslint检查代码</div><div class="line">			enforce:&apos;pre&apos;//将执行顺序放到最前面，防止其他Loader将处理后的代码交给tslint-loader检查</div><div class="line">		&#125;]</div><div class="line">	&#125;，</div><div class="line">	plugin:[</div><div class="line">		new StyleLintPlugin() //整合stylelint，检查css代码，可以解析SCSS,Less</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="导致问题"><a href="#导致问题" class="headerlink" title="导致问题"></a>导致问题</h2><p>1.执行检查步骤计算量大，或导致webpack构建变慢<br>2.整合代码检查到webpack后，输出的错误信息是通过行号来定位错误的，没有编辑器集成显示错误直观</p>
<h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>1.将代码检查步骤当道代码提交时，即在代码提交前调用以上检查工具去检查代码，只有检查都通过时才提交代码，这样保证仓库内代码都经过检查<br>2.使用集成了代码检查功能的编辑器，让编辑器实时，直观的显示错误<br>安装 npm i -D husky 接入git hook,通过git 的hook功能做到在提交代码前触发执行，husky会通过Npm Script Hook自动配置好HOOK<br>但需要在package.json定义脚本，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;script&quot;:&#123;</div><div class="line">		&quot;precommit&quot;:&quot;npm run lint&quot;,//git commit 前执行的脚本</div><div class="line">		&quot;prepush&quot;:&apos;lint&apos;,//git push前会执行的脚本</div><div class="line">		&quot;lint&quot;:&apos;eslint &amp;&amp; stylelint&apos;//调用eslint,stylelint检查工具</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="在nodejs中使用"><a href="#在nodejs中使用" class="headerlink" title="在nodejs中使用"></a>在nodejs中使用</h1><p>通过调用Webpack的API，执行构建</p>
<h2 id="一次构建"><a href="#一次构建" class="headerlink" title="一次构建"></a>一次构建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&apos;webpack&apos;)</div><div class="line">//import webpack from &apos;webpack&apos;</div><div class="line"></div><div class="line">1.使用模块方式一</div><div class="line">webpack(&#123;</div><div class="line">	//webpack配置，和webpack.config.js一样</div><div class="line">&#125;,(err,stats)=&gt;&#123;</div><div class="line">	if(err || stats.hasErrors())&#123;</div><div class="line">		//构建过程出错</div><div class="line">	&#125;</div><div class="line">	//成功执行完构建</div><div class="line">&#125;)</div><div class="line">2.使用模块方式二</div><div class="line">const config = require(&apos;./webpack.config.js&apos;)</div><div class="line">webpack(config,callback)</div></pre></td></tr></table></figure>
<h2 id="启动监听模式"><a href="#启动监听模式" class="headerlink" title="启动监听模式"></a>启动监听模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//不给webpack传递callback就会返回compiler实例，用于控制启动，而不是像上面那样立即启动</div><div class="line">const compiler = webpack(config)</div><div class="line">//调用compiler.watch并以监听模式启动，返回watching用于关闭监听</div><div class="line">const watching = compiler.watch(&#123;</div><div class="line">	//watchOptions</div><div class="line">	aggregateTimeout:300</div><div class="line">&#125;,(err,stats)=&gt;&#123;</div><div class="line">	//每次因文件发生变化而重新执行完/构建后</div><div class="line">&#125;)</div><div class="line">//调用watching.close关闭监听</div><div class="line">watching.close(()=&gt;&#123;</div><div class="line">	//在监听关闭后</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="加载图片相关的loader"><a href="#加载图片相关的loader" class="headerlink" title="加载图片相关的loader"></a>加载图片相关的loader</h2><p>1.file-loader<br>将js和CSS中导入图片的地址替换成 webpack输出文件的地址，输出文件名是根据内容计算出的HASH值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rules:[&#123;</div><div class="line">	test:/\.png$/,</div><div class="line">	use:[&apos;fill-loader&apos;]</div><div class="line">	&#125;]</div></pre></td></tr></table></figure></p>
<p>2.url-loder<br>将图片转base64直接注入到引入的地方，<br>一般利用url-loder将网页需要用到的小图片资源注入代码中，以减少加载次数，为一个很小图片而2新建一次HTTP连接不划算<br>如果图片体积太大会导致js,CSS文件过大而带来网页加载缓慢的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">rules:[&#123;</div><div class="line">	test:&apos;/\./png$/&apos;,</div><div class="line">	use:[&#123;</div><div class="line">		loader:&apos;url-loader&apos;,</div><div class="line">		options:&#123;</div><div class="line">			//30KB以下文件采用url-loader,控制文件大小</div><div class="line">			limit:1024*30,</div><div class="line">			//否则采用file-loader,默认值是file-loader</div><div class="line">			fallback:&apos;file-loader&apos;</div><div class="line">		&#125;</div><div class="line">		&#125;]</div><div class="line">	&#125;]</div></pre></td></tr></table></figure></p>
<p>还可以以下方式优化，同样适用于其他二进制类型的资源，如PDF,SWF<br>A.通过imagin-webpack-plugin压缩图片<br>B.通过webpack-spritesmith插件制作雪碧图</p>
<p>以上两个loader都可用于处理svg图片，但svg文件是文本格式文件，还有其他方法</p>
<p>3.raw-loader<br>可以将文本文件内容读取出来，注入js/CSS中<br>由于会直接返回svg的文本内容，并且无法通过CSS展示SVG的文本内容，因此采用该loader后无法在CSS中导入SVG<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rules:[&#123;</div><div class="line">	test:/\./svg$/,</div><div class="line">	use:&apos;raw-loader&apos;</div><div class="line">	&#125;]</div></pre></td></tr></table></figure></p>
<p>4.svg-inline-loader<br>类似raw-loader，但会分析SVG内容，去除其中不必要的部分代码，以减少SVG文件大小，相当于增加了对SVG的压缩能力<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rules:[&#123;</div><div class="line">	test:/\.svg$/,</div><div class="line">	use:[&apos;svg-inline-loader&apos;]</div><div class="line">	&#125;]</div></pre></td></tr></table></figure></p>
<h2 id="DevServer-实现"><a href="#DevServer-实现" class="headerlink" title="DevServer 实现"></a>DevServer 实现</h2><p>webpack-dev-server本身基于webpack-dev-middleware和expressjs,而webpack-dev-middleware是一个express.js的中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">const express = require(&apos;express&apos;)</div><div class="line">const wepack = require(&apos;webpack&apos;)</div><div class="line">const webpackMiddleware = require(&apos;webpack-dev-middleware&apos;)</div><div class="line"></div><div class="line">const config = require(&apos;./webpack.config.js&apos;)</div><div class="line">const app = expree()</div><div class="line">const compiler = webpack(config)</div><div class="line">app.use(webpackMiddleware(compiler,&#123;</div><div class="line">	//在webpack-dev-middleware支持的所有配置项中</div><div class="line">	//只有publicPath属性为必填项，其他都是选填项</div><div class="line"></div><div class="line">	//webpack输出资源绑定HTTP服务器上的根目录</div><div class="line">	//同WEBPACK配置中的publicPath</div><div class="line">	publicPath:&apos;/assets/&apos;,</div><div class="line"></div><div class="line">	//不输出info类型的日志到控制台，只输出warn和error类型的日志</div><div class="line">	noInfo:false,</div><div class="line">	//不输出任何类型的日志到控制台</div><div class="line">	quiet:false,</div><div class="line">	//切换到懒惰模式，意味着不监听文件的变化，只会在有请求时再编译对应的文件，适合页面很多的项目</div><div class="line">	lazy:true,</div><div class="line">	//watchOptions,只在非懒惰模式下才有效</div><div class="line">	watchOptions:&#123;</div><div class="line">		aggregationTimeout:300,</div><div class="line">		poll:true</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	//默认的URL路径，默认是&apos;index.html&apos;</div><div class="line">	index:&apos;index.html&apos;,</div><div class="line">	//自定义HTTP头</div><div class="line">	headers:&#123;&apos;X-Custom-Header&apos;:&apos;yes&apos;&#125;,</div><div class="line">	//为特定后缀的文件添加HTTP mimeTypes,作为文件类型映射表</div><div class="line">	mimeTypes:&#123;&apos;text/html&apos;:[&apos;phtml&apos;]&#125;,</div><div class="line"></div><div class="line">	//统计信息输出样式</div><div class="line">	stats:&#123;</div><div class="line">		colors:true</div><div class="line">	&#125;,</div><div class="line">	//自定义输出日志的展示方法</div><div class="line">	reporter:null,</div><div class="line">	//开启或关闭服务端渲染</div><div class="line">	serverSideRender:false</div><div class="line"></div><div class="line">&#125;))</div><div class="line">//webpackMiddleware函数返回一个Expressjs中间件，该中间件有俩个功能</div><div class="line">//1.接收来自webpack compiler实例输出的文件，但不会将文件输出到硬盘中，而会保存在内存中</div><div class="line">//2.在express.js上注册路由，拦截HTTP收到的请求，根据请求路径响应对应文件内容</div><div class="line"></div><div class="line">//webpack-dev-middleware没有模块热替换功能，但Devserver有，</div><div class="line">//可通过webpack-hot-middleware中间件来支持模块热替换，响应用于替换老模块的资源</div><div class="line">app.use(require(&apos;webpack-hot-middleware&apos;)(compiler))</div><div class="line">//将项目根目录作为静态资源目录，用于服务器HTML文件</div><div class="line">app.use(express.static(&apos;.&apos;))</div><div class="line"></div><div class="line">app.listen(3000)</div></pre></td></tr></table></figure></p>
<p>响应模块热替换功能还需要作如下配置<br>1.修改webpack.config.js文件，加入HotModuleReplacementPlugin插件<br>  相当于执行 webpack-dev-server –hot工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const HotModuleReplacementPlugin= require(&apos;webpack/lib/HotModuleReplacementPlugin&apos;)</div><div class="line">module.exports=&#123;</div><div class="line">	entry:[</div><div class="line">		&apos;webpack-hot-middleware/client&apos;,//为了支持模块热替换注入代理客户端</div><div class="line">		&apos;./src/main.js&apos;</div><div class="line">	],</div><div class="line">	output:&#123;</div><div class="line">		filename:&apos;bundle.js&apos;</div><div class="line">	&#125;,</div><div class="line">	plugin:[</div><div class="line">		//为了支持模块热替换，生成.hot-update.json文件</div><div class="line">		new HotModuleReplacementPlugin(),</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.修改入口文件main.js,加入替换逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//在文件末尾加入</div><div class="line">if(module.hot)&#123;</div><div class="line">	moudule.hot.accept()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.安装以上配置中用到的依赖<br>npm i -D webpack-dev-middleware webpack-hot-middleware express</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot; class=&quot;headerlink&quot; title=&quot;基本配置&quot;&gt;&lt;/a&gt;基本配置&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
    
      <category term="performance" scheme="http://yoohannah.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>react Native 基础知识</title>
    <link href="http://yoohannah.github.io/post/knowledge/reactNativeKnowledge.html"/>
    <id>http://yoohannah.github.io/post/knowledge/reactNativeKnowledge.html</id>
    <published>2019-03-05T14:50:37.000Z</published>
    <updated>2019-04-12T00:11:05.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h1><p>Text:用来显示文本<br>View:相当于div或者span这样的容器，常用作其他组件的容器，来帮助控制布局和样式<br>Image:显示图片，属性source指定图片地址，也可以使用style属性控制尺寸</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>props:子组件通过this.props拿到父组件使用子组件时传递进来的属性值<br>state:自定义组件控制内部逻辑的变量，同react的state,在constructor里面初始化<br>StyleSheet:使用StyleSheet.create()创建样式，相当于style标签,不过使用时在style中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123; AppRegistry, StyleSheet, Text, View &#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">export default class LotsOfStyles extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;View&gt;</div><div class="line">        &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt;</div><div class="line">        &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line">  bigBlue: &#123;</div><div class="line">    color: &apos;blue&apos;,</div><div class="line">    fontWeight: &apos;bold&apos;,</div><div class="line">    fontSize: 30,</div><div class="line">  &#125;,</div><div class="line">  red: &#123;</div><div class="line">    color: &apos;red&apos;,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在style属性中可以直接写驼峰式CSS属性进行样式调整<br>但设置width和height是不带单位的，React Native 中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。</p>
<h1 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h1><p>相当于span,但可以被’\n’换行<br>用作子元素时，<br>如果父元素为Text时，多个Text子元素尽可能放一行，一行装不下时，自动换行，子元素Text标签会继承父元素Text一部分样式<br>如果父元素为View时，每个Text子元素成为flex布局的一个块，当容器不够宽时，每个块自动换行，块与块之间不影响<br>必须把文本放在Text组件中，不能直接放在View中</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>selectable:是否可以长按选择文本，以便复制和粘贴<br>selectionColor[Andorid]：选中时高亮颜色<br>suppressHighlighting[IOS]：设为true时，当文本被按下会没有任何视觉效果。默认情况下，文本被按下时会有一个灰色的、椭圆形的高光<br>ellipsizeMode:表示当 Text 组件无法全部显示需要显示的字符串时如何用省略号进行修饰<br>————head ： 从文本内容头部截取显示省略号。例如： “…efg”<br>————middle ： 在文本内容中间截取显示省略号。例如： “ab…yz”<br>————tail ： 从文本内容尾部截取显示省略号。例如： “abcd…”<br>————clip ： 不显示省略号，直接从尾部截断。<br>numberOfLines:文本过长时，最多折叠多少行，执行ellipsizeMode设置的效果<br>onLayout：加载时或者布局变化以后调用，参数为：{nativeEvent: {layout: {x, y, width, height}}}<br>onLongPress：当文本被长按以后调用此回调函数<br>onPress：当文本被点击以后调用此回调函数。<br>llowFontScaling：制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。</p>
<h1 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h1><p>有些属性仅在multiline为true或者为false的时候有效，例如当multiline=false时，为元素的某一个边添加边框样式（例如：borderBottomColor，borderLeftWidth等）将不会生效<br>在安卓上长按选择文本会导致windowSoftInputMode设置变为adjustResize，这样可能导致绝对定位的元素被键盘给顶起来。要解决这一问题你需要在AndroidManifest.xml中明确指定合适的windowSoftInputMode( <a href="https://developer.android.com/guide/topics/manifest/activity-element.html" target="_blank" rel="external">https://developer.android.com/guide/topics/manifest/activity-element.html</a> )值，或是自己监听事件来处理布局变化。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><p>placeholder：同input<br>maxLength:限制文本框中最多的字符数。使用这个属性而不用JS逻辑去实现，可以避免闪烁的现象。<br>multiline:如果为true，文本框中可以输入多行文字。默认值为false。注意安卓上如果设置multiline = {true}，文本默认会垂直居中，可设置textAlignVertical: ‘top’样式来使其居顶显示<br>numberOfLines:设置输入框的行数<br>allowFontScaling:控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。<br>autoCapitalize:控制TextInput是否要自动将特定字符切换为大写<br>————characters: 所有的字符。<br>————words: 每个单词的第一个字符。<br>————sentences: 每句话的第一个字符（默认）。<br>————none: 不切换。<br>autoCorrect：如果为false，会关闭拼写自动修正。默认值是true<br>autoFocus：如果为true，在componentDidMount后会获得焦点。默认值为false。<br>blurOnSubmit：如果为true，文本框会在提交的时候失焦。对于单行输入框默认值为true，多行则为false。注意：对于多行输入框来说，如果将blurOnSubmit设为true，则在按下回车键时就会失去焦点同时触发onSubmitEditing事件，而不会换行。<br>caretHidden：如果为true，则隐藏光标。默认值为false。<br>clearButtonMode：是否要在文本框右侧显示“清除”按钮。仅在单行模式下可用。默认值为never。<br>clearTextOnFocus：如果为true，每次开始输入的时候都会清除文本框的内容。<br>defaultValue：<br>提供一个文本框中的初始值。当用户开始输入的时候，值就可以改变。在一些简单的使用情形下，如果你不想用监听消息然后更新value属性的方法来保持属性和状态同步的时候，就可以用defaultValue来代替。<br>editable：如果为false，文本框是不可编辑的。默认值为true<br>enablesReturnKeyAutomatically：如果为true，键盘会在文本框内没有文字的时候禁用确认按钮。默认值为false。<br>inlineImageLeft：指定一个图片放置在左侧。图片必须放置在/android/app/src/main/res/drawable目录下，经过编译后按如下形式引用（无路径无后缀）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;TextInput</div><div class="line"> inlineImageLeft=&apos;search_icon&apos;</div><div class="line">/&gt;</div></pre></td></tr></table></figure></p>
<p>inlineImagePadding:给放置在左侧的图片设置padding样式。<br>keyboardAppearance:指定键盘的颜色。<br>keyboardType:决定弹出何种软键盘类型</p>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p>onBlur：当文本框失去焦点的时候调用此回调函数。<br>onChange：当文本框内容变化时调用此回调函数。回调参数为{ nativeEvent: { eventCount, target, text} }<br>onChangeText：当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。<br>onEndEditing：当文本输入结束后调用此回调函数。<br>onKeyPress：当一个键被按下的时候调用此回调。传递给回调函数的参数为{ nativeEvent: { key: keyValue } }，其中keyValue即为被按下的键。会在onChange之前调用。注意：在Android上只有软键盘会触发此事件，物理键盘不会触发。<br>onSubmitEditing：此回调函数当软键盘的确定/提交按钮被按下的时候调用此函数。如果multiline={true}，此属性不可用。</p>
<h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><p>样式单一，可能不适合统一UI样式</p>
<h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><p>title:按钮名<br>color：文本的颜色(iOS)，或是按钮的背景色(Android)<br>disabled：禁用</p>
<h2 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h2><p>onPress:点击触发</p>
<h2 id="TouchableHighlight"><a href="#TouchableHighlight" class="headerlink" title="TouchableHighlight"></a>TouchableHighlight</h2><p>用来封装可以点击的元素，来制作按钮或者链接。注意此组件的背景会在用户手指按下时变暗。<br>使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低，同时会有一个底层的颜色透过而被用户看到，使得视图变暗或变亮<br>只支持一个子节点（不能没有子节点也不能多于一个）。如果你希望包含多个子组件，可以用一个View来包装它们</p>
<h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><p>activeOpacity：指定封装的视图在被触摸操作激活时以多少不透明度显示（0到1之间，默认值为0.85）。需要设置underlayColor。<br>underlayColor：有触摸操作时显示出来的底层的颜色。</p>
<h3 id="响应-2"><a href="#响应-2" class="headerlink" title="响应"></a>响应</h3><p>onHideUnderlay：底层的颜色被隐藏的时候调用。<br>onShowUnderlay：当底层的颜色被显示的时候调用。</p>
<h2 id="TouchableNativeFeedback"><a href="#TouchableNativeFeedback" class="headerlink" title="TouchableNativeFeedback"></a>TouchableNativeFeedback</h2><p>用来封装可以点击的元素，在用户手指按下时形成类似墨水涟漪的视觉效果<br>它只支持一个单独的View实例作为子节点</p>
<h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><p>background：决定在触摸反馈的时候显示什么类型的背景,它接受一个有着type属性和一些基于type属性的额外数据的对象。<br>一般用本组件的几个静态方法来创建这个对象<br>——————SelectableBackground()：创建一个对象，表示安卓主题默认的对于被选中对象的背景<br>——————SelectableBackgroundBorderless()：创建一个对象，表示安卓主题默认的对于被选中的无边框对象的背景<br>——————Ripple(color: string, borderless: boolean)：创建一个对象，当按钮被按下时产生一个涟漪状的背景，你可以通过color参数来指定颜色，如果参数borderless是true，那么涟漪还会渲染到视图的范围之外</p>
<h1 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h1><p>一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的,适合用来显示数量不多的滚动元素</p>
<h2 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h2><p>horizontal：为true时，元素水平排列，默认false，垂直排列<br>scrollsToTop：当此值为true时，点击状态栏的时候视图会滚动到顶部。默认值为true<br>indicatorStyle：设置滚动条的样式。默认default 同black,’white’白色滚动条<br>overScrollMode：覆盖默认的overScroll模式<br>——————‘auto’ ： 默认值，允许用户在内容超出视图高度之后可以滚动视图。<br>——————‘always’ ： 无论内容尺寸，用户始终可以滚动视图。<br>——————‘never’ ： 始终不允许用户滚动视图。<br>stickyHeaderIndices：一个子视图下标的数组，用于决定哪些成员会在滚动之后固定在屏幕顶端。举个例子，传递stickyHeaderIndices={[0]}会让第一个成员固定在滚动视图顶端。这个属性不能和horizontal={true}一起使用。<br>scrollEnabled：当值为false的时候，内容不能滚动，默认值为true。注意即便禁止用户滚动，你也仍然可以调用scrollTo来滚动。<br>showsHorizontalScrollIndicator：为true的时候，显示一个水平方向的滚动条。<br>showsVerticalScrollIndicator：为true的时候，显示一个垂直方向的滚动条<br>refreshControl：用于为ScrollView提供下拉刷新功能。只能用于垂直视图，即horizontal不能为true。<br>pagingEnabled：当值为true时，滚动条会停在滚动视图的尺寸的整数倍位置。这个可以用在水平分页上。默认值为false。注意：垂直分页在Android上不支持。</p>
<h2 id="响应-3"><a href="#响应-3" class="headerlink" title="响应"></a>响应</h2><p>onScrollBeginDrag：当用户开始拖动此视图时调用此函数<br>onScrollEndDrag：当用户停止拖动此视图时调用此函数。<br>onScroll：在滚动的过程中，每帧最多调用一次此回调函数。调用的频率可以用scrollEventThrottle属性来控制。<br>onMomentumScrollBegin:滚动动画开始时调用此函数。<br>onMomentumScrollEnd：滚动动画结束时调用此函数<br>scrollTo(([y]: number),([x]: number),([animated]: boolean),([duration]: number))：滚到指定位置时<br>scrollToEnd(([options]: {animated: boolean, duration: number}));滚到视图底部</p>
<h2 id="FlatList"><a href="#FlatList" class="headerlink" title="FlatList"></a>FlatList</h2><p>用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同<br>更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。</p>
<h3 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h3><p>data：数据源<br>renderItem：返回重复的子组件<br>ItemSeparatorComponent：行与行之间的分隔线组件。不会出现在第一行之前和最后一行之后。值是一个组件<br>ListEmptyComponent：列表为空时渲染该组件。<br>ListHeaderComponent：头部组件<br>ListFooterComponent：尾部组件。<br>horizontal：设置为 true 则变为水平布局模式</p>
<p>extraData：如果有除data以外的数据用在列表中（不论是用在renderItem还是头部或者尾部组件中），请在此属性中指定。同时此数据在修改时也需要先修改其引用地址（比如先复制到一个新的 Object 或者数组中），然后再修改其值，否则界面很可能不会刷新。</p>
<p>initialNumToRender：指定一开始渲染的元素数量，最好刚刚够填满一个屏幕，这样保证了用最短的时间给用户呈现可见的内容。注意这第一批次渲染的元素不会在滑动过程中被卸载，这样是为了保证用户执行返回顶部的操作时，不需要重新渲染首批元素</p>
<p>initialScrollIndex:开始时屏幕顶端的元素是列表中的第 initialScrollIndex个元素, 而不是第一个元素。如果设置了这个属性，则第一批initialNumToRender范围内的元素不会再保留在内存里，而是直接立刻渲染位于 initialScrollIndex 位置的元素。需要先设置 getItemLayout 属性。</p>
<p>keyExtractor:此函数用于为给定的 item 生成一个不重复的 key。Key 的作用是使 React 能够区分同类元素的不同个体，以便在刷新时能够确定其变化的位置，减少重新渲染的开销。若不指定此函数，则默认抽取item.key作为 key 值。若item.key也不存在，则使用数组下标。</p>
<p>onEndReachedThreshold：决定当距离内容最底部还有多远时触发onEndReached回调。注意此参数是一个比值而非像素单位<br>refreshing：在等待加载新数据时将此属性设为 true，列表就会显示出一个正在加载的符号</p>
<h2 id="响应-4"><a href="#响应-4" class="headerlink" title="响应"></a>响应</h2><p>onEndReached：当列表被滚动到距离内容最底部不足onEndReachedThreshold的距离时调用<br>onRefresh：如果设置了此选项，则会在列表头部添加一个标准的RefreshControl控件，以便实现“下拉刷新”的功能。同时你需要正确设置refreshing属性<br>onViewableItemsChanged：在可见行元素变化时调用。可见范围和变化频率等参数的配置请设置viewabilityConfig属性<br>scrollToOffset()：滚动列表到指定的偏移（以像素为单位），等同于ScrollView的scrollTo方法。</p>
<h2 id="SectionList"><a href="#SectionList" class="headerlink" title="SectionList"></a>SectionList</h2><p>要渲染的是一组需要分组的数据，也许还带有分组标签的数据<br><a href="https://reactnative.cn/docs/sectionlist/" target="_blank" rel="external">文档</a></p>
<h1 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h1><p>Platform是一个模块，不是组件，用来进行平台检测<br>Platform.OS，在 iOS 上会返回ios，而在 Android 设备或模拟器上则会返回android。<br>Platform.select({ios:{},android:{}}) 可以以 Platform.OS 为 key，从传入的对象中返回对应平台的值<br>Platform.Version, Android 的 api level，值为数字，ios上为一个表示当前系统版本的字符串<br>当不同平台的代码逻辑较为复杂时，最好是放到不同的文件里，这时候我们可以使用特定平台扩展名。React Native 会检测某个文件是否具有.ios.或是.android.的扩展名，然后根据当前运行的平台自动加载正确对应的文件。<br>比如你可以在项目中创建下面这样的组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BigButton.ios.js</div><div class="line">BigButton.android.js</div></pre></td></tr></table></figure></p>
<p>然后去掉平台扩展名直接引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import BigButton from &apos;./BigButton&apos;;</div></pre></td></tr></table></figure></p>
<h1 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h1><p>用于管理 iOS 和 Android 应用中的图片<br>图片文件的查找会和 JS 模块的查找方式一样,如果有my-icon.ios.png和my-icon.android.png，Packager 就会根据平台而选择不同的文件<br>可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片，Packager 会打包所有的图片并且依据屏幕精度提供对应的资源，如果没有图片恰好满足屏幕分辨率，则会自动选中最接近的一个图片。<br>为了使新的图片资源机制正常工作，require 中的图片名字必须是一个静态字符串（不能使用变量！因为 require 是在编译时期执行，而非运行时期执行！）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 正确</div><div class="line">&lt;Image source=&#123;require(&apos;./my-icon.png&apos;)&#125; /&gt;;</div><div class="line"></div><div class="line">// 错误</div><div class="line">var icon = this.props.active ? &apos;my-icon-active&apos; : &apos;my-icon-inactive&apos;;</div><div class="line">&lt;Image source=&#123;require(&apos;./&apos; + icon + &apos;.png&apos;)&#125; /&gt;;</div><div class="line"></div><div class="line">// 正确</div><div class="line">var icon = this.props.active</div><div class="line">  ? require(&apos;./my-icon-active.png&apos;)</div><div class="line">  : require(&apos;./my-icon-inactive.png&apos;);</div><div class="line">&lt;Image source=&#123;icon&#125; /&gt;;</div><div class="line">//通过这种方式引用的图片资源包含图片的尺寸（宽度，高度）信息，如果需要动态缩放图片（例如，通过 flex），可能必须手动在 style 属性设置&#123; width: null, height: null &#125;。</div></pre></td></tr></table></figure></p>
<p>require语法也可以用来静态地加载你项目中的声音、视频或者文档文件,包括.mp3, .wav, .mp4, .mov, .htm 和 .pdf等<br>注意的是视频必须指定尺寸而不能使用flex样式</p>
<p>要在 App 中显示的图片并不能在编译的时候获得，又或者有时候需要动态载入来减少打包后的二进制文件的大小。这些时候，与静态资源不同的是,需要手动指定图片的尺寸<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 正确</div><div class="line">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/logo-og.png&apos;&#125;&#125;</div><div class="line">       style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;</div><div class="line">//或者 指定请求参数</div><div class="line">&lt;Image</div><div class="line">  source=&#123;&#123;</div><div class="line">    uri: &apos;https://facebook.github.io/react/logo-og.png&apos;,</div><div class="line">    method: &apos;POST&apos;,</div><div class="line">    headers: &#123;</div><div class="line">      Pragma: &apos;no-cache&apos;,</div><div class="line">    &#125;,</div><div class="line">    body: &apos;Your Body goes here&apos;,</div><div class="line">  &#125;&#125;</div><div class="line">  style=&#123;&#123;width: 400, height: 400&#125;&#125;</div><div class="line">/&gt;</div><div class="line">//或者 引用base64</div><div class="line">&lt;Image</div><div class="line">  style=&#123;&#123;</div><div class="line">    width: 51,</div><div class="line">    height: 51,</div><div class="line">    resizeMode: &apos;contain&apos;,</div><div class="line">  &#125;&#125;</div><div class="line">  source=&#123;&#123;</div><div class="line">    uri:</div><div class="line">      &apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==&apos;,</div><div class="line">  &#125;&#125;</div><div class="line">/&gt;</div><div class="line">// 错误</div><div class="line">&lt;Image source=&#123;&#123;uri: &apos;https://facebook.github.io/react/logo-og.png&apos;&#125;&#125; /&gt;</div></pre></td></tr></table></figure></p>
<p>读取本地静态图片（使用require(‘./my-icon.png’)语法）则无需指定尺寸，因为它们的尺寸在加载时就可以立刻知道。</p>
<h2 id="ImageBackground"><a href="#ImageBackground" class="headerlink" title="ImageBackground"></a>ImageBackground</h2><p>用于设置背景图，把需要背景图的子组件嵌入其中即可，需要设置大小</p>
<h1 id="react-navigation"><a href="#react-navigation" class="headerlink" title="react-navigation"></a>react-navigation</h1><p>导航器，控制跳转<br><a href="https://www.jianshu.com/p/a0ae81e1942a" target="_blank" rel="external">资料</a></p>
<h1 id="InteractionManager"><a href="#InteractionManager" class="headerlink" title="InteractionManager"></a>InteractionManager</h1><p>确保在执行繁重工作之前所有的交互和动画都已经处理完毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">InteractionManager.runAfterInteractions(() =&gt; &#123;</div><div class="line">  // ...需要长时间同步执行的任务...</div><div class="line">&#125;);</div><div class="line">//允许应用注册动画，在动画开始时创建一个交互“句柄”，然后在结束的时候清除它</div><div class="line">var handle = InteractionManager.createInteractionHandle();</div><div class="line">// 执行动画... (`runAfterInteractions`中的任务现在开始排队等候)</div><div class="line">// 在动画完成之后</div><div class="line">InteractionManager.clearInteractionHandle(handle);</div><div class="line">// 在所有句柄都清除之后，现在开始依序执行队列中的任务</div></pre></td></tr></table></figure></p>
<p>requestAnimationFrame(): 用来执行在一段时间内控制视图动画的代码<br>setImmediate/setTimeout/setInterval(): 在稍后执行代码。注意这有可能会延迟当前正在进行的动画。<br>runAfterInteractions(): 在稍后执行代码，不会延迟当前进行的动画。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用标签&quot;&gt;&lt;a href=&quot;#常用标签&quot; class=&quot;headerlink&quot; title=&quot;常用标签&quot;&gt;&lt;/a&gt;常用标签&lt;/h1&gt;&lt;p&gt;Text:用来显示文本&lt;br&gt;View:相当于div或者span这样的容器，常用作其他组件的容器，来帮助控制布局和样式&lt;br
    
    </summary>
    
    
      <category term="reactNative" scheme="http://yoohannah.github.io/tags/reactNative/"/>
    
  </entry>
  
  <entry>
    <title>react Native 环境配置</title>
    <link href="http://yoohannah.github.io/post/knowledge/reactNativeCreat.html"/>
    <id>http://yoohannah.github.io/post/knowledge/reactNativeCreat.html</id>
    <published>2019-03-04T14:50:37.000Z</published>
    <updated>2019-03-23T02:36:32.422Z</updated>
    
    <content type="html"><![CDATA[<p>其实按照官网一步一步来就好了，也不用翻墙，基本上，就是耗时间<br>我配置的是window android环境<br><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="external">中文文档</a><br>1.安装node<br>可以直接使用nvm安装，但版本必须是8.<em>或者10.</em><br>带来的问题是，nvm切换版本后，npm可能找不到，可以直接用全局安装的yarn代替<br><a href="http://yuanhehe.cn/2017/06/11/npm-%E4%B8%8E-Yarn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/" target="_blank" rel="external">npm 与 Yarn 常用命令对比</a><br>或者直接将npm文件夹从能用的版本移到不能用的版本</p>
<p>2.python2<br>官网说不支持Python3.X,因为很早之前安装的python没管，今天一看是3.*，能跑起来</p>
<p>3.JDK<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">下载地址</a><br>我下载的这个<br><img src="/image/native1.png" alt="native1"><br>安装过程注意，jdk和jre使用不同文件夹<br><a href="https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html" target="_blank" rel="external">安装与环境配置</a><br>4.Android Studio<br>按文档步骤安装好后，需要先创建项目再创建虚拟机<br>构建虚拟机过程文档应该需要翻墙，但其实可以直接百度<br><a href="https://jingyan.baidu.com/article/3aed632edf252e701080911f.html" target="_blank" rel="external">构建虚拟机</a><br>相当于在PC上调试<br>5.链接真机测试<br>数据线链接手机和电脑，在git里跑’react-native run-android’<br>遇到的问题<br>1.第一次跑时，出现：unable to load script from assets<br> 解决如下：<br> 第一步：在Android/app/src/main目录下创建一个空的assets文件夹。<br> 第二步：执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/res/</div></pre></td></tr></table></figure></p>
<p>再重新跑react-native run-android<br>2.摇晃手机reload 后：could not connect to development sever<br>华为手机andorid版本较低,4.*<br>点击dev setting，选择Debug server host&amp;port for device,填入PC电脑的IP地址和端口号<br>3.引入使用native-nivigation和react-native-gesture-handler后运行报错<br>settings file ‘E:\git\mobileApp\android\settings.gradle’: 3: unexpected char: ‘\’ @ line 3, column 1<br>解决： android下setiing.gradle,’\’换成‘/’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">project(&apos;:react-native-gesture-handler&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-gesture-handler/android&apos;)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实按照官网一步一步来就好了，也不用翻墙，基本上，就是耗时间&lt;br&gt;我配置的是window android环境&lt;br&gt;&lt;a href=&quot;https://reactnative.cn/docs/getting-started.html&quot; target=&quot;_blank&quot; rel
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>webpack配置项</title>
    <link href="http://yoohannah.github.io/post/performance/webpackdetail.html"/>
    <id>http://yoohannah.github.io/post/performance/webpackdetail.html</id>
    <published>2019-03-03T08:21:02.000Z</published>
    <updated>2019-06-29T08:27:25.816Z</updated>
    
    <content type="html"><![CDATA[<p>webpack在启动后会从Entry里配置的Moudule开始，递归解析Entry依赖的所有Module，每找到一个module,就会根据配置的loader去找对应的转换规则，<br>对Module进行转换后，在解析当前Module依赖的Module。这些模块会以Entry为单位进行分组，一个Entry及其所有依赖Module被分到一个组，也就是一个Chunk<br>最后，webpack会将所有Chunk转换成文件输出。webpack会在恰当的时机执行Plugin里定义的逻辑</p>
<h1 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h1><p>入口，webpack执行构建的第一步将从Entry开始，可抽象成输入<br>配置：<br>方式1： 直接一个文件路径字符串：’./app/entry1’<br>方式2： 文件路径字符串数组：[‘./app/entry1’,’./app/entry2’]<br>方式3： 文件路径字符串对象：{A：’./app/entryA’,B:’./app/entryB’}<br>方式4： 函数，动态导出以上三种形式<br>方式1,2最后只会有一个文件会被导出，即导出一个Chunk,名为main<br>方式3导出多个Chunk,名称分别对应对象KEY值</p>
<h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><p>输出结果，在webpack经过一系列处理并得到最终想要的代码后输出结果<br>配置：</p>
<h2 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h2><p>输出文件名<br>方式1：静态，名字写死，如bundle.js，适用于只有一个导出Chunk，一个输出文件<br>方式2：利用Chunk内置变量，动态拼接生成文件名，例如’[name].js’<br>Chunk内置变量有：id,name,hash(name的hash,可指定长度，例如[hash:8]),chunkhash(chunk内容的hash)<br>相关：ExtractTextWebpackPlugin使用contenthash表示文件内容hash,但提取的内容为代码本身，不是一组模块组成的chunck内容</p>
<h2 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h2><p>无具体入口的chunk输出的文件名<br>例如通过commonChunkPlugin生成的文件，或者使用import动态加载生成的文件等<br>因为都是chunk输出文件，所以内置变量同filename的chunk</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>输出文件的存放目录<br>配置：绝对路径的字符串<br>内置变量：仅有一个，hash,代表一次编译操作的hash值</p>
<h2 id="publishPath"><a href="#publishPath" class="headerlink" title="publishPath"></a>publishPath</h2><p>配置发布到线上资源的URL前缀<br>配置：字符串<br>内置变量：仅有一个，hash,代表一次编译操作的hash值</p>
<h2 id="crossOriginloading"><a href="#crossOriginloading" class="headerlink" title="crossOriginloading"></a>crossOriginloading</h2><p>配置异步插入的script标签的crossorign值<br>配置：<br>anonymous，默认，不带cookie<br>use-credentials,加载时，带cookie</p>
<h2 id="library"><a href="#library" class="headerlink" title="library"></a>library</h2><p>导出库的名称,与libraryTarget配合使用<br>配置：字符串</p>
<h2 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h2><p>以何种方式导出库<br>配置：以下字符串<br>‘var’|’commonjs’|’commonjs2’|’this’|’window’|’global’</p>
<h2 id="libraryExport"><a href="#libraryExport" class="headerlink" title="libraryExport"></a>libraryExport</h2><p>在libraryTarget配置’commonjs’|’commonjs2’时，配置导出模块中哪些子模块被导出</p>
<h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><p>模块处理规则</p>
<h2 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h2><p>数组，每一项是处理同一类文件的相关配置对象</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>处理哪些文件，文件名命中规则，<br>配置：字符串</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>在什么目录范围内匹配<br>配置：字符串/字符串数组（每一项是或的关系，只要满足一个条件就会命中）</p>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p>排除哪些目录范围，再匹配<br>配置：字符串/字符串数组（每一项是或的关系，只要满足一个条件就会命中）</p>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>配置loader<br>loader可以看作具有文件转换功能的翻译员，告诉webpack在遇到哪些文件时使用哪些loader去加载和转换<br>配置：数组，每一项可以是是字符串，或者对象<br>默认执行顺序为数组倒序执行，即最末尾先执行<br>字符串：loader名称<br>对象：对于该loader的一些相关配置</p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>配置：字符串，loader名</p>
<h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>配置：对象，给loader处理函数传入的参数</p>
<h4 id="enforce"><a href="#enforce" class="headerlink" title="enforce"></a>enforce</h4><p>更改loader执行顺序<br>配置：<br>pre: 放在执行顺序最前面<br>post:放在执行顺序最后</p>
<h2 id="noparse"><a href="#noparse" class="headerlink" title="noparse"></a>noparse</h2><p>功能类似于exclude,排除不需要进行接续处理的文件，<br>此类文件中不能采用模块化方式编写，即不应包含import,require,define等语句，<br>否则导致无法在浏览器下执行<br>配置：字符串，文件路径</p>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>更细粒度地配置哪些语法被解析，哪些不被解析，精确到语法层面<br>{cmd:false,commonjs:false….}</p>
<h1 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h1><p>配置如何寻找模块对应的文件</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>通过将路径前缀指定别名，进行映射<br>配置：对象，key为别名，值为实际路径<br>例：{components：’./src/components’,…}</p>
<p>第三方模块一般会包含两套代码<br>一套采用comonjs规范的模块代码，这些文件都放在lib目录下，以package.json中指定的react.js为模块入口<br>一套是将React所有相关代码打包好的完整代码放到一个单独文件中，这些代码没有采用模块化，可以直接执行，<br>其中非压缩文件（dist/xxx.js）用于开发环境，里面包含检查和警告的代码，压缩的代码(dist/xxx.min.js)用于线上环境<br>默认情况下，webpack会从入口文件./node_module/xxx/xxx.js开始递归解析和处理依赖的几十个文件，会是一个耗时操作<br>可以通过配置reaolve.alias,让webpack处理第三方库时，直接使用单独完整的xxx.min.js，从而跳过耗时的递归解析操作</p>
<h2 id="mainFields"><a href="#mainFields" class="headerlink" title="mainFields"></a>mainFields</h2><p>决定优先使用第三方模块的哪份代码，按数组顺序查找，使用找到的第一份文件<br>默认值和target有关，<br>当target为web或者webwork时，值是[‘browser’,’module’,’main’]<br>当target为其他值时，值时[‘module’,’main’]<br>配置：第三方模块导出文件的关键字<br>例：[‘jsnext:main’,’brower’,’main’]</p>
<h2 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h2><p>导入语句没有带文件后缀时，尝试寻找的后缀代表<br>配置：后缀字符串数组<br>例：[‘.ts’,’.js’,’json’]</p>
<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>去哪些目录下寻找第三方模块，<br>默认node_modules 含义是先去当前目录的./node_module目录下找，如果没有找到，就去上一级目录../node_module中去找<br>再没有就去../../node_module中找，一次类推<br>配置：字符串数组<br>例：[‘.src/components’,’node_modules’],<br>可以直接在页面中import ‘.src/components’里面的模块，不用再写相对路径</p>
<h2 id="descriptionFiles"><a href="#descriptionFiles" class="headerlink" title="descriptionFiles"></a>descriptionFiles</h2><p>配置第三方模块名<br>配置：字符串数组</p>
<h2 id="enforceExtension"><a href="#enforceExtension" class="headerlink" title="enforceExtension"></a>enforceExtension</h2><p>是否强制导入语句中必须带后缀<br>true:必须带<br>false:不用必须带</p>
<h2 id="enforceModuleExtension"><a href="#enforceModuleExtension" class="headerlink" title="enforceModuleExtension"></a>enforceModuleExtension</h2><p>只对node_module文件夹下模块生效<br>通常设置false，与enforceExtension：true配合，兼容第三方模块，使用时不加后缀</p>
<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><p>扩展插件，在webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果或者做一些自定义的操作<br>比如将css文件单独打包，或者抽离公共模块<br>不使用plugin处理css文件的原理大概是将CSS内容用JS字符串存储起来，在网页执行JS时，通过DOM操作，动态向HTML head标签里插入HTML style标签<br>使用plugin将css抽离，是从打包好的js文件再提取出来<br>配置：plugin实例数组，使用new操作符调用构造函数，同时将参数传递进去<br>例：[new commonsChunkPlugin({name:’common’})]</p>
<h1 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h1><p>配置针对使用webpack-dev-server启动webpack时的一些配置，相当于配置webpack-dev-server<br>devServer 会启动一个http服务器，用于服务网页请求，<br>同时会启动webpack,将webpack构建的文件保存在内存中，在要访问输出的文件时，必须通过HTTP服务访问，<br>同时会开启webpack的监听模式，devServer会让webpack在构建出的js代码里注入一个代理客户端用于控制网页，<br>网页和devServer之间通过webSocket协议通信，以方便devServer主动向客户端发送命令，<br>devServer在收到来自webpack的文件变化通知时，通过注入的客户端控制自动刷新网页，做到实时预览。<br>1.由于devServer不会理会配置的output.path属性，所以获取打包文件时，应该依据HTTP获取，不再依据output.path获取<br>因此要注意使用devServer之后打包文件的获取路径要进行更改。<br>2.index.html因为脱离js模块化系统，webpack不知道它的存在，故，更改index.html，不会被监听到<br>3.除了通过重新刷新整个网页来实现预览，devServer还有一种被称作模块热替换的刷新技术。<br>模块热替换能做到在不重新加载整个网页的情况下，通过将已更新的模块替换老模块，再重新执行一次来实现实时预览。<br>模块热替换相对于默认的刷新机制能提供更快的响应速度和更好的开发体验。<br>可以在执行devServer时加上 –hot开启<br>4.启动webpack时，加上–devtool source-map 可生成souce-map，方便在浏览器中调试源代码</p>
<p>配置<br>hot是否开启热加载(热替换)<br>模块热替换原理：<br>类似于自动刷新，都需要向要开发的网页中注入一个代理客户端来连接DevServer和网页，区别在于热替换时会多出三个用于热替换的文件<br>在发生文件变化时，会重新生成一个用于替换老模块的补丁文件，补丁文件中会包含新编译的代码，页面会使用新编译的代码<br>当子模块发生更新时，更新事件会一层一层向上传递，会从根组件传递到main.js,直到有某层文件接收了当前变化的模块，<br>就会去执行自定义的逻辑，如果事件一直往上抛，到最外层都没有文件接收它，则会直接刷新网页，<br>最直观的就是修改main.js时，会发生整个页面刷新<br>而对于.css文件，在使用style-loader处理时会注入用于接收CSS的代码，所以在修改.css文件时，会触发模块热替换</p>
<p>inline<br>开启实现实时预览，自动刷新；<br>不开启，使用iframe方式运行开发的网页，需要去localhost:8080/webpack-dev-pack实时预览<br>historyApiFallback:用于H5History API单页应用开发<br>contentBase:devServer HTTP服务器文件根目录<br>headers:在HTTP响应中注入HTTP响应头<br>host:监听地址<br>port:监听端口<br>allowedHosts:只有HTTP请求的HOST在列表中才正常返回<br>disabledHostCheck:是否关闭用于DNS重新绑定的HTTP请求的HOST检查<br>https:是否运行在https上<br>clientloglevel:配置客户端日志等级</p>
<h1 id="target"><a href="#target" class="headerlink" title="target"></a>target</h1><p>构建不同运行环境的代码</p>
<h1 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h1><p>有很多选项可配置，选项之间可以随意组合<br>6个关键配置项：<br>eval:用eval语句包裹需要安装的模块<br>source-map:生成独立的Source Map文件<br>hidden：不在JS文件中指出 Source Map文件的位置，这样浏览器就不会自动加载Source Map<br>inline:将生成的Source Map转换成BASE64格式内嵌在JS文件中<br>cheap:在生成的Source Map文件中不会包含列信息，这样计算量更小，输出的Source Map文件更小，同时Loader输出的Source Map不会被采用<br>module:来自Loader的Source Map被简单的处理成每行一个模块</p>
<h2 id="‘source-map’"><a href="#‘source-map’" class="headerlink" title="‘source-map’"></a>‘source-map’</h2><p>仅设置source-map会造成以下两个问题<br>1.会输出质量最高且最详细的Source Map，会造成构建速度缓慢，特别是开发过程中需要频繁修改时会增加等待时间<br>2.会将Source Map暴露，若构建发布到线上代码的Source Map暴露等于源码被泄露<br>解决：<br>1.开发环境下将dev-tool设置成cheap-module-eval-source-map,因为生成这种Source Map的速度最快，能加速构建，<br>在开发环境下不会做代码压缩，所以在Source Map中即使没有列信息，也不会影响断点调试<br>2.生产环境下将dev-tool设置成hidden-source-map,生成最详细的Source Map，但不会将Source Map暴露出去<br>在生产环境会做代码压缩，一个JS文件只有一行，所以需要列信息</p>
<p>生产环境通常不会将Source Map上传到HTTP服务器让用户获取，而是上传到JS错误错误收集系统，<br>在错误收集系统上根据Source Map和收集到的JS运行错误堆栈，计算出错误所在源码位置</p>
<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>webpack是默认不会加载第三方模块附带的Source Map文件的，会在转换过程中生成Source Map，<br>为了让webpack加载这些第三方模块的Source Map，需要使用source-map-loader<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">rules:[&#123;</div><div class="line">	test:/\.js$/,</div><div class="line">	include:[path.resolve(root,&apos;node_module/some-component&apos;)],</div><div class="line">	//加载Source Map时计算量很大，因此要避免让该Loader处理过多的文件，不然会导致构建变慢</div><div class="line">	use:[source-map-loader],</div><div class="line">	//要将source-map-loader的执行顺序放到最前面，</div><div class="line">	//如果在source-map-loader之前有Loader转换了该JS文件，就会导致Source Map映射错误</div><div class="line">	enforce:&apos;pre&apos;</div><div class="line">	&#125;]</div></pre></td></tr></table></figure></p>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>是否开启监听文件变动模式</p>
<h1 id="watchOption"><a href="#watchOption" class="headerlink" title="watchOption"></a>watchOption</h1><p>配置监听规则,在开启监听模式时，才有用</p>
<p>ignore:不监听的文件/文件夹<br>aggregateTimeout:监听到变化发生后，等多少ms再去执行动作，截流，防止文件更新太快而导致重新编译的频率太快，默认为300ms<br>poll:判断文件是否发生变化是通过不停的询问系统指定文件有没有变化实现的，这里配置每秒询问多少次</p>
<p>文件监听原理：<br>默认情况下，webpack会从配置的Entry文件出发，递归出Entry文件依赖的文件，将这些依赖的文件都加入到监听列表中，而不是监听整个项目目录下的文件<br>然后对列表中每个文件都定时执行检查，定时获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后编辑时间不一致，<br>就认为该文件发生了变化，watchOption.poll控制定时检查的周期<br>文件发生变化后并不会立刻告诉监听者，而是先缓存起来，收集一段时间的变化后，再一次性告诉监听者。watchOption.aggregateTimeout用于配置这个等待时间<br>这样做的目的就是在编辑代码过程可能会高频地输入文字，导致文件变化的时间高频发生，如果每次都重新执行构建，就会让构建卡死</p>
<h1 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h1><p>配置哪些模块不用被打包</p>
<h1 id="resolveloader"><a href="#resolveloader" class="headerlink" title="resolveloader"></a>resolveloader</h1><p>配置如何去寻找loader</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack在启动后会从Entry里配置的Moudule开始，递归解析Entry依赖的所有Module，每找到一个module,就会根据配置的loader去找对应的转换规则，&lt;br&gt;对Module进行转换后，在解析当前Module依赖的Module。这些模块会以Entry
    
    </summary>
    
    
      <category term="performance" scheme="http://yoohannah.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>多请求loading处理</title>
    <link href="http://yoohannah.github.io/post/knowledge/loadingcount.html"/>
    <id>http://yoohannah.github.io/post/knowledge/loadingcount.html</id>
    <published>2019-03-03T01:53:37.000Z</published>
    <updated>2019-03-03T03:06:45.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目中所有http请求走同一个全局公共函数，函数参数为：请求方法，url, 请求参数，回调函数以及是否需要加loading的一个布尔值</p>
<p>一般情况下都需要加loading，所以第5个参数一般不填，默认为true,需要加loading<br>不加loading的情况也有，例如下载一个文件的过程，如果是由前端来组装文件流，这个时候是不加loading的</p>
<p>loading效果的添加是通过jquery判断有没有loading效果对应的DOM，有的话就先remove再append<br>loading效果的消失通过jquery remove掉相关DOM元素</p>
<p>即在全局公共函数发出http请求前，根据第5个参数，添加loading，请求结束后取消loading</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一个配置页面，跳转过来时需要加载多项数据进行初始化，而且数据之间有一定关联<br>比如，异步请求A,B,C,D四个数据，请求完D之后，在回调函数中，需要根据D数据发出请求E，再根据E返回数据请求F<br>导致的现象是，ABCD数据回来比较快，然后loading消失，发出E时loading重现，消失和重现时间距离较短，<br>造成页面闪烁</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>加载ABCDEF请求loading仅显示一次，消失一次</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>1.其实本身发出ABCD四个异步请求时也会发生loading问题，即，如果A请求回来的比其他三个早很多，loading会提前结束<br>2.从D返回的数据可能为空这时就不需要去请求E，F请求也就不用发出，同样如果E没数据，也就不要请求F，这时候loading在哪结束需要判断</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>1.在加载loading和消失loading时，添加一层计数，加载loading，计数count加1，消失loading计数count减1，当count减为0时，loading再消失<br>这样就可以解决异步请求loading提前消失<br>2.D请求完才会发出E请求，这时如果ABC请求早已结束，count已经被减为0 ，会重新开始计数，loading会重现造成闪烁，还是不能解决直接问题，<br>解决办法就是,在请求回来时，利用settimeout包裹计数减1,loading消失过程，先执行回调函数再减1，<br>这样，如果D有数据，count会因为要发请求E先加1，然后执行settimeout减1，这样loading就不会因为减到1而消失<br>如果    D没数据不发出请求E，同步执行完回调函数后，执行settimeout减1，count减到0，loading消失</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>回调函数中，有同事代码编写存在BUG，比如没有判断对象是否存在直接去使用其身上的属性值，这样的error会在请求的catch中被捕捉到，<br>因为请求发生错误，状态码非200都会被捕捉到catch中，这时也需要将loading关闭，<br>这样就会造成在回调函数发生错误时，count被减了两次，第一次是请求正常回来时，第二次是回调函数发生错误在catch中被减1，<br>这样count就被减成了小于0，之前的判断以及count等于0，loading消失不再适用，<br>因此将判断界限定为小于1即loading消失，进行容错处理</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目中所有http请求走同一个全局公共函数，函数参数为：请求方法，url, 请求参数，回调函数以及是否需要加loading的一个布尔值&lt;/p
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS3样式的一点小结</title>
    <link href="http://yoohannah.github.io/post/knowledge/css3.html"/>
    <id>http://yoohannah.github.io/post/knowledge/css3.html</id>
    <published>2019-02-21T14:27:58.000Z</published>
    <updated>2019-02-27T00:10:28.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h1><p>会覆盖border属性设置的边框样式<br>原理依据border-image-slice将图片切成九宫格<br><img src="/image/borderOri.jpg" alt="borderOri"><br>EFGH位于边框四角，不参与拉伸或重复<br>ABCD分别在各自所在边上进行拉伸或者重复<br>I不参加修饰</p>
<h2 id="border-image-source"><a href="#border-image-source" class="headerlink" title="border-image-source"></a>border-image-source</h2><p>图片地址<br>格式url(imgurl) </p>
<h2 id="border-image-slice"><a href="#border-image-slice" class="headerlink" title="border-image-slice"></a>border-image-slice</h2><p>从距离top，right,bottom,left边多少切割图片，切4刀，形成9宫格<br>可为数字(图像的像素（位图图像）或向量的坐标（如果图像是矢量图像）)/百分数(水平/垂直偏移图像宽度的百分之多少)<br>不设置时，图片整体位于边框四角。<br>一个值时表示4个距离一致；两个值表示垂直方向两刀和水平两刀距离相同，四个值表示距离四个边各自的距离<br>特殊情况，<br>如果距上下边的长度等于高的一半，即在图片水平中线来一刀，则BD两个切片不会被切出来，左右边框会因为没有切片覆盖显示background-color<br>同理，距左右边的长度等于宽的一半，在图片垂直中线来一刀，则AC两个切片不会被切出来，上下边框会因为没有切片覆盖显示background-color<br>所以如果仅装饰边框4个角，可以采用距离边等于宽高一半的方法切割图片</p>
<h2 id="border-image-repeat"><a href="#border-image-repeat" class="headerlink" title="border-image-repeat"></a>border-image-repeat</h2><p>水平边要不要repeat 垂直边要不要repeat 默认拉伸<br>可取值：stretch 默认拉伸；repeat 重复切片；round;重复切片，但会适当调整大小，避免出现半截图片<br><img src="/image/borderimg.jpg" alt="borderimg"><br><img src="/image/borderimg1.jpg" alt="borderimg1"></p>
<h1 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h1><p>设置边框外圆半径<br>5px ———— 4个角都设半径为5px的圆形圆角<br>5px/10px  ———— 4个角都设水平半径为5px，垂直半径为10px的椭圆形圆角<br>5px 10px  左上和右下角半径5px圆形，右上和左下半径10px的圆形圆角<br>5px 10px 20px  左上角半径5px圆形，右上和左下半径10px的圆形,右下角半径20px圆形圆角<br>5px 10px 20px 15px 左上角半径5px圆形，右上半径10px的圆形,右下角半径20px圆形,左下15p圆形圆角<br>5px 10px 20px 15px/10px 15px 25px 20px 四个角同时设置椭圆型圆角</p>
<p>当半径值小于等于边框border宽度时，border内部不会具有圆角效果，内圆半径=外圆半径-边框宽度<br>若相邻边宽不同，则角会从宽边平滑到窄边<br>表格table设置圆角时，只有将border-collapse:separate时才正常显示<br>如果想取消原有圆角设置，可以将对应值设置为0<br>特殊应用：直接通过设置容器长宽和border-radius绘制圆形，半圆，扇形，椭圆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">width:300px</div><div class="line">height:300px</div><div class="line">border-radius:150px;//圆形</div><div class="line">border-radius: 0 300px 0px 0px;//扇形</div><div class="line"></div><div class="line">width:600px</div><div class="line">height:300px</div><div class="line">border-radius:150px;//椭圆形</div><div class="line">border-radius: 300px 300px 0px 0px;//半圆</div></pre></td></tr></table></figure></p>
<h1 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h1><p>content-box  ———— 元素width代表内容宽度<br>border-box   ————  元素width = border+padding + 内容宽度</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>容器能否拖拽以及拖拽方式<br>none | both | horizontal | vertial | inherit</p>
<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p>相当于border,但不占文档流，不破坏布局<br>颜色 样式 宽度 偏移</p>
<h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><p>边框阴影，由多个值配置<br>insert ？ 水平方向偏移（正右负左）垂直偏移（正下负上）模糊半径 伸缩半径(相当于阴影宽度)<br>设置insert时，设置内阴影，不设时，设置外阴影<br>内阴影用在img标签上无效<br>实例应用<br>1.单边阴影<br>box-shadow:red 0px -5px 5px -3px,给top边设置了阴影，通过设置伸缩半径-3px防止其他边模糊半径5px效果<br>2.四边阴影<br>box-shadow:0 0 10px red;//10px为模糊半径<br>box-shadow:0 0 0 10px red;//10px为伸缩半径,此效果相当于设置了一个宽10px的红边，但不占文档流<br>层级关系：外阴影—&gt;背景色—&gt;背景图—&gt;内阴影—&gt;边框<br>3.多层阴影<br>每组用逗号隔开，靠前的设置面积（伸缩半径）太大的话会遮盖之后的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//彩虹色</div><div class="line">box-shadow: red 0px 0px 10px 10px, inset orange 0px 0px 10px 15px, inset yellow 0px 0px 10px 30px, inset green 0px 0px 10px 45px, inset blue 0px 0px 10px 60px, inset purple 0px 0px 10px 75px;</div></pre></td></tr></table></figure></p>
<h1 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h1><p>水平方向偏移(正右负左) 垂直偏移(正下负上) 模糊半径 颜色(位置随意)</p>
<h2 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h2><p>超出容器是否显示省略号<br>使用条件<br>width：500px;容器有具体宽度<br>overflow: hidden;超出隐藏<br>white-space: nowrap;//禁止换行</p>
<h2 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h2><p>长单词url换行<br>normal 默认，半角空格/连字符地方换行,长文本UrL会伸到容器外<br>break-word 在边界换行，不截断英文单词</p>
<h2 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h2><p>自动换行处理方法<br>normal 默认，整字，英文单词整个换行<br>break-all 可截断单词换行<br>keep-all 不允许断开换行，chrome，safari不支持</p>
<h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><p>页面显示与html文本书写格式处理<br>normal 根据容器宽度换行，连续空格合并成一个<br>pre 空白换行跟html书写格式一致，行为类似pre标签<br>nowrap 不换行，连续空格合并成一个，超出容器尺寸按容器overflow处理<br>pre-line 换行跟html书写格式一致，续空格合并成一个<br>pre-wrap  保留空白，正常换行，与pre区别在于pre标签对一些符号上的支持和规范</p>
<h2 id="文本换行"><a href="#文本换行" class="headerlink" title="文本换行"></a>文本换行</h2><p>1.pre标签自动换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pre&#123;</div><div class="line">    white-space:pre;</div><div class="line">    word-wrap:break-word</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.td自动换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">table&#123;</div><div class="line">    table-layout:fixed;</div><div class="line">    width:***px;</div><div class="line">&#125;</div><div class="line">table td&#123;</div><div class="line">    overflow:hidden;</div><div class="line">    word-wrap:break-word;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.除以上两种标签自动换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">element&#123;</div><div class="line">    overflow:hidden;</div><div class="line">    word-wrap:break-word;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.标签内容强制不换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">element&#123;</div><div class="line">    white-space:nowrap;</div><div class="line">    word-break:keep-all;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h1><p>背景图是否随页面滚动条滚动，始终不会随容器滚动条滚动<br>scroll ———— 滚动<br>fixed ———— 不滚动</p>
<h1 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h1><p>1.起始位置<br>background-color始终从border与margin交界线的左上角(用A表示)开始<br>background-image默认从padding与border交界线的左上角(用B表示)开始,但是可以通过设置background-position决定起始点<br>2.在Z轴上，覆盖顺序<br>background-color ——&gt; background-image ——&gt; border,conten的背景色<br>background-repeat值为repeat和no-repeat时,对覆盖有不同影响</p>
<h2 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h2><p>图片比容器小时，重复方式<br>no-repeat ———— 仅从B点开始铺一次,background-image不会填充border部分的background-color,图片不够大时会显示background-color<br><img src="/image/bgimg2.png" alt="bgimg2"><br>repeat ———— 从B点开始,先垂直重复，再整体水平重复，background-image会覆盖border部分的background-color,图片起点还是B,然后垂直重复,整体水平重复<br><img src="/image/bgimg1.png" alt="bgimg1"><br>repeat-x ———— 从B点开始，仅水平重复，不再整体垂直重复，覆盖border<br>repeat-y ———— 从B点开始，仅垂直重复，不再整体水平重复,覆盖border</p>
<h2 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h2><p>背景图片开始位置在padding与border交界线什么地方<br>两个值为长度或者百分数时，第一个值表示容器水平方向的位置，相对于left边位置；第二个值表示容器垂直方向的位置，相对于TOP边位置，可以混用<br>但只设一个值时，表示距离left位置，垂直方向默认为居中<br>两个值为关键字时，left,right,center表示水平位置，top,bottom,center表示垂直位置，<br>前后位置可随意，left bottom 等于 bottom left<br>仅设置一个值时，另一个方向默认center,例left 相当于left center,背景图位于左边垂直中间位置；center，即水平垂直居中<br><img src="/image/bgimg3.png" alt="bgimg3"></p>
<h2 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h2><p>同样可以重置图片开始位置，指定居于哪条线，<br>同时指定background-position时，先根据background-origin确定线，依线根据background-position确定位置<br>border-box ———— margin与border交界线<br>padding-box ———— border与padding交界线,默认值<br>content-box ———— padding与内容块交界线</p>
<h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>设置背景色background-color铺设范围<br>border-box ———— 从margin与border交界线开始铺<br>padding-box ———— 从border与padding交界线开始铺<br>content-box ———— 从padding与内容块交界线开始铺</p>
<h2 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h2><p>以background-origin设置的值为容器,设置图片大小<br>auto 原始尺寸<br>具体长度值1个或2个<br>百分数1个或2个 相对容器的百分之多少，不是图片大小<br>contain 放大，铺满容器<br>cover 按照图片宽高比例，缩放</p>
<h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h2><p>透明度：0-1的值，值越小越透明<br>表示颜色的rgba,hsla的第四位都表示透明度，取值同opacity</p>
<h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h2><p>线性渐变,用于background-image<br>到达方向，开始颜色，（中间过渡色，）结束颜色<br>到达方向：to left 从右到左；to top left 从右下到左上角；xx deg，使用角度正值顺时针，负值逆时针<br>颜色名后空格加百分数，百分数指色标，色标即颜色在整个距离上开始的位置</p>
<h2 id="radical-gradient"><a href="#radical-gradient" class="headerlink" title="radical-gradient"></a>radical-gradient</h2><p>径向渐变，用于background-image<br>半径 （形状）（at 圆心位置），开始颜色，（中间过渡色，）结束颜色<br>半径：两值相同即为圆形渐变，否则为椭圆渐变；<br>距离容器中心 closed-side 最近边| closed-corner 最近角| farthest-side 最远边| farthest-corner最远角距离<br>形状： circle | ellipse<br>圆心位置：left bottom |100px 200px |20% 15% 默认center</p>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><h2 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h2><p>重置变形函数作用起点，但translate()移动函数始终以元素中心点进行位移<br>left bottom | 20% 10%</p>
<h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><p>子元素以2D还是3D形式处理变换过程<br>flat :2D<br>present-3d: 3D<br>如果同时有设置overflow：hidden,那么设置present-3d不生效，相当于flat</p>
<h2 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h2><p>父元素是否呈现3d效果，这越小3D效果越明显，none不显示</p>
<h2 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h2><p>perspective 原点，从哪个点开始呈现3d效果</p>
<h2 id="perspective-1"><a href="#perspective-1" class="headerlink" title="perspective()"></a>perspective()</h2><p>用于子元素，参数大于0时，激活3d效果</p>
<h2 id="back-visibility"><a href="#back-visibility" class="headerlink" title="back-visibility"></a>back-visibility</h2><p>旋转180度，背面是否显示为正面的镜面效果，visible | hidden<br>3D表示是否透视</p>
<h2 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h2><p>可在transform中空格隔开同时使用多个<br>2D<br>位移<br>translate(<em> |X,Y) X正值为向右，Y正值为向下<br>translateX(</em>）<br>translateY(<em>）<br>放缩<br>scale(</em> |X,Y) 0-1缩小，大于1放大，取负值时，先翻转再放缩<br>scaleX(<em>）<br>scaleY(</em>）<br>旋转<br>rotate(<em>)角度值，顺时针正，逆时针负<br>倾斜<br>skew(</em> |X,Y) 水平 垂直方向倾斜<br>skewX(<em>)<br>skewY(</em>)</p>
<p>3D<br>位移<br>translate3d(X,Y,Z) X正值为向右，Y正值为向下<br>translateZ(<em>）<br>放缩<br>scale3d(</em> |X,Y,Z) 0-1缩小，大于1放大，取负值时，先翻转再放缩<br>scaleZ(<em>）<br>旋转<br>rotate3d(X,Y,Z,角度)X,Y,Z值为0-1，表示绕轴旋转的矢量值，角度值，顺时针正，逆时针负<br>rotateX(</em>)<br>rotateY(<em>)<br>rotateZ(</em>)</p>
<p>以上功能都能让矩阵函数表示<br>2d时使用matrix()<br>3d时使用matrix3d()</p>
<h1 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h1><p>过度属性(css样式)none/all，具备过渡效果的属性，color,阴影，渐变<br>过渡时间 s/ms 整个变化持续时间<br>过度函数 ease|linear|ease-in|ease-out|ease-in-out|step,以上函数表示以什么样的速度变化，都可以用三次贝塞尔曲线实现<br>延迟时间 s/ms 变化延迟多长时间再开始，赋值为负值时，立即开始，之前的变换被截断<br>配置多项时，每组配置逗号隔开<br>终状态一般定义于各种触发伪类：hover,active,focus,checked<br>或者根据媒体查询结果</p>
<h1 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h1><p>定义动画每一帧样式<br>@keyframes 取个名字apple{<br>   0%{动画第一帧样式}<br>   各种百分数{动画过渡帧样式}<br>   100%{动画最后一帧样式}<br>}</p>
<h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><p>animation各个子属性<br>animation-name:@keyframes声明的动画帧的名字，例如apple<br>animation-duration:播放一遍的时间<br>animation-timing-function:播放方式<br>animation-delay:延迟多长时间再播放<br>animation-iteration-count:播放次数<br>animation-direction:倒放还是正放动画normal正放alternate倒放<br>animation-play-state:播放状态running播放|paused暂停<br>animation-fill-mode:结束定格在哪一帧</p>
<h1 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h1><p>媒体查询<br>@media 10种媒体类型 and (13种设备特性) and (13种设备特性){样式}</p>
<h1 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h1><p>从服务器加载字体类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@font-face&#123;</div><div class="line">    font=family:xxx;</div><div class="line">    src:url()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;border-image&quot;&gt;&lt;a href=&quot;#border-image&quot; class=&quot;headerlink&quot; title=&quot;border-image&quot;&gt;&lt;/a&gt;border-image&lt;/h1&gt;&lt;p&gt;会覆盖border属性设置的边框样式&lt;br&gt;原理依据bord
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>探索flex布局</title>
    <link href="http://yoohannah.github.io/post/knowledge/css3flex.html"/>
    <id>http://yoohannah.github.io/post/knowledge/css3flex.html</id>
    <published>2019-01-31T23:54:58.000Z</published>
    <updated>2019-02-21T14:16:19.709Z</updated>
    
    <content type="html"><![CDATA[<p>flex布局<br>盒状弹性布局，盒子大小可以随容器大小变化</p>
<h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><p><b>display</b>  决定开始作为弹性容器</p>
<p>—— flex : 将容器设置为弹性伸缩容器<br>—— inline-flex :使弹性容器成为单个不可分的行内级元素<br>注意，columns属性此时在flex容器上不在有效果</p>
<p><b>flex-direction</b> 决定主轴方向<br>—— row:水平向右，子模块书写顺序横向排列，开头的放在最左端,子模块不设宽度情况下宽度由内容决定<br>—— row-reverse:水平向左，子模块书写顺序横向排列，开头的放在最右端，子模块不设宽度情况下宽度由内容决定<br>—— column:从上到下，子模块书写顺序纵向排列，开头的放在最上面，子模块不设高度情况下高度由内容决定<br>—— column-reverse:从下到上，子模块书写顺序纵向排列，开头的放在最下面，子模块不设高度情况下高度由内容决定<br><img src="/image/flex1.png" alt="flex1"></p>
<p><b>flex-wrap</b> 对于子模块是否超出最大宽度或高度时要不要换行/列，默认不换行/列,宽/高度自动按所有模块比例缩小<br>—— nowrap:默认值<br>—— wrap:换行,水平排列的子模块多出的部分沿column方向排第二行;纵向排列的子模块多出的部分沿row方向排第二列;<br>—— wrap-reverse:换行，水平排列的子模块多出的部分沿column-reverse方向排第二行；纵向排列的子模块多出的部分沿row-reverse方向排第二列;<br><img src="/image/flex2.png" alt="flex2.png"><br><img src="/image/flex3.png" alt="flex3.png"><br><img src="/image/flex4.png" alt="flex4.png"></p>
<p><b>flex-flow</b> :[flex-direction][flex-wrap]flex-direction和 flex-wrap的复合属性,<br>先按flex-direction排列，超出部分用flex-wrap决定<br><img src="/image/flex5.png" alt="flex5.png"></p>
<p><b>justify-content</b> 在剩余子模块允许换行或者有剩余宽度或者高度时相对主轴的对齐方式，超出但不换行时，按比例放缩<br>—— center：按实际间距位于主轴中心<br>—— flex-start:按实际间距位于主轴开始排列的位置，第一个贴边<br>—— flex-end :按实际间距和顺序向主轴方向排列，最后一个贴边<br>—— space-between ：第一个和最后一个挨着边框，其它间距相等<br>—— space-around：第一个和最后一个离边框距离为子模块间距的一半<br>处理主轴为侧轴的布局时,设置了具体高度才会生效<br><img src="/image/flex6.png" alt="flex6.png"></p>
<p><b>align-items</b> 子模块整体相对侧轴的位置,row和row-reverse侧轴为column,column和column-reverse侧轴为row<br>—— center：侧轴中心<br>—— flex-start:侧轴起点位置<br>—— flex-end :侧轴终点位置<br>—— stretch：侧轴方向属性值未设置时，拉伸子模块该属性为容器对应属性值，弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。<br>—— baseline:所有模块的内容第一行对齐<br><img src="/image/flex7.png" alt="flex7.png"></p>
<p><b>align-content</b> 决定多行或者多列在侧轴排列方式，row和row-reverse侧轴为column,column和column-reverse侧轴为row<br>—— center：整体在侧轴中心<br>—— flex-start:整体在侧轴起点位置<br>—— flex-end :整体在侧轴终点位置<br>—— stretch：侧轴方向属性值未设置时，拉伸子模块该属性填满容器对应属性值<br>—— space-between ：第一行/列和最后一行/列挨着边框，其它间距相等<br>—— space-around:第一行/列和最后一行/列离边框距离为子模块间距的一半<br><img src="/image/flex8.png" alt="flex8.png"></p>
<h1 id="模块属性"><a href="#模块属性" class="headerlink" title="模块属性"></a>模块属性</h1><p><b>align-self</b>  自己决定相对侧轴的位置<br>属性值同align-items,默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<p><b>order</b> 决定模块排列顺序，值越大，越最后被排列</p>
<p><b>flex-grow</b> 放大比例，当容器空间有剩余时按此比列分配内存空间，填满，比如<br>宽度1000px的容器，4个子模块一共占了800，剩200，4个模块该值分别设为2 ：1：1：1，<br>则200被分为5份，一份40，每个模块按比例 分别拿80，40，40，40 放大自己的面积</p>
<p><b>flex-shrink</b> 缩小比例，当容器空间有不足时按此比列分配缩小子模块，比如<br>容器宽800，5个模块需要占1000，差200，5个模块该值比为4：1：1：1：1，<br>则200被分为8份，一份25，，每个模块按比例分别减少100，25，25，25，25 缩小自己的面积</p>
<p><b>flex-basis</b> 在分配多余空间/缩小之前，项目占据的主轴空间，用于计算一共需要多少空间时放大还是缩小<br>auto 默认值，子模块本来大小</p>
<p><b>flex</b>  ：none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] 以上三项复合属性</p>
<p>一些特殊flex 值的表现情况<br>flex:auto | 1 1 auto;  空间充裕时，模块等比例分配多余空间进行扩展；空间不足时，模块等比例缩小<br>flex:none | 0 0 auto;  不论空间是否充裕，模块大小根据自身设置的尺寸不变，间距变化<br>flex:initial | 0 1 auto | 0 auto; 空间即使充裕也保持原始大小，但空间不足时，模块等比例缩小<br>flex:正值； 模块可根据空间大小收缩，同时多个模块设置时，以该值作为比例进行收缩，放大比等于缩小比</p>
<p>注意，float,clear和vertical-align在伸缩项目上没有效果<br><a href="https://yoohannah.github.io/post/knowledge/layouts.html">flex 实现 圣杯布局</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flex布局&lt;br&gt;盒状弹性布局，盒子大小可以随容器大小变化&lt;/p&gt;
&lt;h1 id=&quot;容器属性&quot;&gt;&lt;a href=&quot;#容器属性&quot; class=&quot;headerlink&quot; title=&quot;容器属性&quot;&gt;&lt;/a&gt;容器属性&lt;/h1&gt;&lt;p&gt;&lt;b&gt;display&lt;/b&gt;  决定开始作为弹性
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Slot复用</title>
    <link href="http://yoohannah.github.io/post/vue/vueSlot.html"/>
    <id>http://yoohannah.github.io/post/vue/vueSlot.html</id>
    <published>2019-01-13T08:38:15.000Z</published>
    <updated>2019-01-13T06:18:17.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目列表组件需要实现点击自动增加一行,可展示自定义内容的可扩展内容<br>列表table组件被应用在page组件，page组件被应用在具体业务页面，slot的具体内容在业务页面传递进去<br><img src="/image/tableextend1.png" alt="tableextend1"><br>问题难点<br>1.多层组件slot传递<br>2.同一个slot在table组件中循环使用在多处时，不会被渲染</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>1.slot 只能一层一层传递，所以解决多层传递，就是在page层应用table时，增加slot接收业务页面传递进来的slot具体内容<br>2.同名slot不能在同一组件被重复渲染，即不允许有重名slot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">重名的 Slots 移除</div><div class="line">同一模板中的重名 &lt;slot&gt; 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用 prop 来传递。</div></pre></td></tr></table></figure></p>
<h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><h2 id="多层组件slot传递"><a href="#多层组件slot传递" class="headerlink" title="多层组件slot传递"></a>多层组件slot传递</h2><p>在page层使用table组件时将&lt;slot&gt;&lt;/slot&gt;放在table组件中，将slot内容当作table的slot传递给table<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">1.业务页面具体自定义内容传入</div><div class="line">&lt;PageComponent :pageConfig=&quot;pageConfig&quot; ref=&quot;child&quot;&gt;</div><div class="line">    &lt;div slot=&apos;tableExtend&apos;&gt;</div><div class="line">    &lt;extendTable :detailConfig=&quot;pageConfig.table.isExtend.detailConfig&quot;</div><div class="line">        v-if=&quot;pageConfig.table.isExtend.detailConfig[0].data.length&gt;0&quot;&gt;</div><div class="line">    &lt;/extendTable&gt;</div><div class="line">    &lt;div style=&quot;padding: 10px;&quot; v-if=&quot;pageConfig.table.isExtend.detailConfig[0].data.length === 0&quot;&gt;暂无数据&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/PageComponent&gt;</div><div class="line"></div><div class="line">2.page组件table部分</div><div class="line">&lt;section class=&quot;page-table&quot;&gt;</div><div class="line">    &lt;tableTemp :table=&quot;pageConfig.table&quot; :pageConfig=&quot;pageConfig&quot; @sendIds=&quot;receiveIds&quot; ref=&quot;refTest&quot;&gt;</div><div class="line">        &lt;slot :name=&apos;pageConfig.table.isExtend.slot&apos; v-if=&quot;pageConfig.table.isExtend&quot;&gt;&lt;/slot&gt; //将slot放在这里</div><div class="line">    &lt;/tableTemp&gt;</div><div class="line">&lt;/section&gt;</div><div class="line">3.table部分</div><div class="line"> 利用template实现列表行和扩展行一对一</div><div class="line"> &lt;template v-for=&quot;(value,index) in table.tableData&quot;&gt; </div><div class="line">    &lt;tr :key=&quot;index&quot;&gt;</div><div class="line">        &lt;td v-for=&quot;(val,i) in table.tableEle&quot; v-if=&quot;val.display&quot; :key=&quot;i&quot;&gt;</div><div class="line">            &lt;div class=&quot;extendStyle&quot; v-if=&apos;table.isExtend &amp;&amp; i==firstShow&apos;&gt;</div><div class="line">                &lt;a v-show=&quot;index != currentActive&quot; @click=&quot;loadDetail(value,index)&quot;&gt;&lt;i class=&quot;ivu-icon ivu-icon-ios-arrow-forward&quot;&gt;&lt;/i&gt;&lt;/a&gt; //loadDetail去调父组件函数获取详情数据</div><div class="line">                &lt;a v-show=&quot;index === currentActive&quot; @click=&quot;loadDetail(value,index)&quot; class=&quot;active&quot;&gt;&lt;i class=&quot;ivu-icon ivu-icon-ios-arrow-forward&quot;&gt;&lt;/i&gt;&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div v-if=&apos;!table.isExtend&apos;&gt;</div><div class="line">            ...</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    //在组装行的时候增加备用扩展行，利用第三方变量控制扩展行显示隐藏</div><div class="line">    &lt;tr v-if=&quot;index === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt;  </div><div class="line">        &lt;td :colspan=&apos;tdNumber&apos; id=&apos;extend1&apos;&gt;//合并单元格</div><div class="line">            &lt;slot :name=&apos;table.isExtend.slot&apos;&gt;&lt;/slot&gt;//直接这样是不能渲染的，因为这样通过循环会出现多个同名slot</div><div class="line">        &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">&lt;/template&gt; </div><div class="line">//去调父组件函数获取详情数据</div><div class="line">loadDetail(item, index) &#123;</div><div class="line">    this.currentActive = this.currentActive === index ? -1 : index</div><div class="line">    this.$store.commit(&apos;changeTableExtendActive&apos;,this.currentActive)</div><div class="line">    if(this.currentActive === -1)&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    let func = this.pageConfig.table.isExtend.func</div><div class="line">    this.$parent.$parent[func](item,index)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h2 id="slot重用"><a href="#slot重用" class="headerlink" title="slot重用"></a>slot重用</h2><h3 id="方法一-作用域插槽"><a href="#方法一-作用域插槽" class="headerlink" title="方法一 作用域插槽"></a>方法一 作用域插槽</h3><p>在子组件中将slot中用到的数据传递给slot标签的data属性,<br>父组件借助slot-scope属性,获取子组件中slot标签的data属性传递的数据<br>即可应用在slot模板中，另外slot模板中如果用到点击事件回调函数，可以直接在父组件中定义，直接调用</p>
<p>注意slot-scope绑定的变量在使用时,子组件传递的实际值被包含在一个data属性中，所以需要通过slotscope.data.xxxxx去获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">爷爷组件</div><div class="line">&lt;PageComponent :pageConfig=&quot;pageConfig&quot; ref=&quot;child&quot;&gt;</div><div class="line">    &lt;template slot-scope=&quot;isExtend&quot;&gt;</div><div class="line">        &lt;extendTable :detailConfig=&quot;isExtend.data.detailConfig&quot; //包含的data中</div><div class="line">            v-if=&quot;isExtend.data.detailConfig[0].data.length&gt;0&quot;&gt;</div><div class="line">        &lt;/extendTable&gt;</div><div class="line">        &lt;div style=&quot;padding: 10px;&quot; v-if=&quot;isExtend.data.detailConfig[0].data.length === 0&quot;&gt;暂无数据&lt;/div&gt;</div><div class="line">    &lt;/template&gt;</div><div class="line">&lt;/PageComponent&gt;</div><div class="line">父组件</div><div class="line">&lt;section class=&quot;page-table&quot;&gt;</div><div class="line">    &lt;tableTemp :table=&quot;pageConfig.table&quot; :pageConfig=&quot;pageConfig&quot; @sendIds=&quot;receiveIds&quot; ref=&quot;refTest&quot;&gt;</div><div class="line">        &lt;slot :data=&apos;pageConfig.table.isExtend&apos; v-if=&quot;pageConfig.table.isExtend&quot;&gt;&lt;/slot&gt;</div><div class="line">    &lt;/tableTemp&gt;</div><div class="line">&lt;/section&gt;</div><div class="line">子组件</div><div class="line">&lt;tr v-if=&quot;index === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt; </div><div class="line">    &lt;td :colspan=&apos;tdNumber&apos; id=&apos;extend1&apos;&gt;</div><div class="line">        &lt;slot :data=&apos;table.isExtend&apos;&gt;&lt;/slot&gt; //直接使用</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<h3 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h3><p>一个业务场景需要同时渲染多个table,即通过一次配置，可渲染多个table的组件，<br>一个同事将循环table的逻辑放在了table组件本身里面，造成table本身是一个可循环输出多个table的组件<br>这样如果一开始在爷爷组件放入多个具名slot,因为不能在子组件slot标签添加name属性（会循环出同名slot），<br>那所有的slot都会出现在每一个table组件中<br>因此有了方法二<br><img src="/image/tableextend2.png" alt="tableextend2"></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>利用page层传递slot到table组件思想，在table中使用slot时，将其包裹在一个新组件中，<br>利用新组件复用，实现slot组件复用，(相当于将slot传递到新组件——-&gt;待查原理)<br>而新组件通过render函数依据slot节点生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">子组件</div><div class="line"> &lt;tr v-if=&quot;(indexx+&apos;-&apos;+index) === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt;</div><div class="line">    &lt;td :colspan=&apos;itemConfig.config.length&apos;&gt;</div><div class="line">        &lt;!-- slot标签要放在tdslot标签充当slot,否则详情数据拉回来之后不会进行更新组件 --&gt;</div><div class="line">        &lt;tdSlot :name=&apos;itemConfig.isExtend.slot&apos;&gt; &lt;slot :name=&apos;itemConfig.isExtend.slot&apos;&gt;&lt;/slot&gt; &lt;/tdSlot&gt;</div><div class="line">        &lt;!-- tdslot在main.js中定义 --&gt;</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">loadDetail(item, indexx, index) &#123;</div><div class="line">    this.currentActive = this.currentActive === indexx+&apos;-&apos;+index ? -1 : indexx+&apos;-&apos;+index //通过多层key判断展开</div><div class="line">    if(this.currentActive === -1)&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    let func = this.detailConfig[indexx].isExtend.func</div><div class="line">    this.$parent.$parent[func](item,indexx, index)</div><div class="line">&#125;</div><div class="line">新组件带着slot生成</div><div class="line">Vue.component(&apos;tdSlot&apos;, &#123;</div><div class="line"></div><div class="line">  render(createElement) &#123;</div><div class="line">    function deepClone(vnodes, createElement) &#123;</div><div class="line">      function cloneVNode (vnode) &#123;对slot节点进行深度复制</div><div class="line">        const clonedChildren = vnode.children &amp;&amp; vnode.children.map(vnode =&gt; cloneVNode(vnode))</div><div class="line">        const cloned = createElement(vnode.tag, vnode.data, clonedChildren)</div><div class="line">        cloned.text = vnode.text</div><div class="line">        cloned.isComment = vnode.isComment</div><div class="line">        cloned.componentOptions = vnode.componentOptions</div><div class="line">        cloned.elm = vnode.elm</div><div class="line">        cloned.context = vnode.context</div><div class="line">        cloned.ns = vnode.ns</div><div class="line">        cloned.isStatic = vnode.isStatic</div><div class="line">        cloned.key = vnode.key</div><div class="line"></div><div class="line">        return cloned</div><div class="line">      &#125;</div><div class="line">      const clonedVNodes = vnodes.map(vnode =&gt; cloneVNode(vnode))</div><div class="line">      return clonedVNodes</div><div class="line">    &#125;</div><div class="line">    var slots = this.$parent.$slots.default //从父组件拿到slot</div><div class="line">    var slot = null</div><div class="line">    for(let i=0;i&lt;slots.length;i++)&#123;</div><div class="line">      if(slots[i].data &amp;&amp; this.name === slots[i].data.slot)&#123; //多个slot，拿到自己table.isExtend配置的那一个</div><div class="line">        slot = slots[i]</div><div class="line">        break</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return createElement(&apos;div&apos;,&#123;class:&apos;tdslot&apos;&#125;,deepClone([slot], createElement)) //做一下深度复制</div><div class="line">    &lt;!-- return createElement(&apos;div&apos;,&#123;class:&apos;tdslot&apos;&#125;,[slot]) --&gt; 这样也可以</div><div class="line">  &#125;,</div><div class="line">  props:&#123;</div><div class="line">    name:&#123;</div><div class="line">      type:String,</div><div class="line">      default:&apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">父组件</div><div class="line">&lt;detailsTable v-if=&quot;detailPageConfig.detailConfig&quot; :detailConfig=&quot;detailPageConfig.detailConfig&quot;&gt;</div><div class="line">    &lt;slot v-for=&apos;(item,index) in detailPageConfig.detailConfig&apos; v-if=&apos;item.isExtend&apos; :name=&apos;detailPageConfig.detailConfig[index].isExtend.slot&apos; &gt;&lt;/slot&gt;</div><div class="line">&lt;/detailsTable&gt;</div><div class="line">爷爷组件</div><div class="line">&lt;detailsPage :detailPageConfig=&quot;detailPageConfig&quot;&gt;</div><div class="line">    &lt;div slot=&apos;tableExtend-1&apos;&gt; //多个slot 并列写即可</div><div class="line">    &lt;detailsTable :detailConfig=&quot;detailPageConfig.detailConfig[1].isExtend.detailConfig&quot;</div><div class="line">        v-if=&quot;this.detailPageConfig.detailConfig[1].isExtend.detailConfig[0].data.length&gt;0&quot;&gt;</div><div class="line">    &lt;/detailsTable&gt;</div><div class="line">    &lt;div v-if=&quot;this.detailPageConfig.detailConfig[1].isExtend.detailConfig[0].data.length&lt;1&quot;&gt;暂无数据&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/detailsPage&gt;</div></pre></td></tr></table></figure></p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>其实之所以会出现重名slot是因为table的大循环逻辑放在了自己组件内，<br>其实输出多个table的逻辑放在page层即可，table还是独立的table，<br>这样插入slot时就不是同名slot，各自slot,插入各自table<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">父组件</div><div class="line">&lt;template v-for=&apos;(item,index) in detailPageConfig.detailConfig&apos;&gt;</div><div class="line">    &lt;detailsTable :detailConfig=&quot;item&quot; :key=&apos;index&apos;&gt;</div><div class="line">    &lt;slot v-if=&apos;item.isExtend&apos; :name=&apos;item.isExtend.slot&apos; &gt;&lt;/slot&gt;</div><div class="line">    &lt;/detailsTable&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">子组件</div><div class="line">&lt;tr v-if=&quot;index === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt;</div><div class="line">    &lt;td :colspan=&apos;detailConfig.config.length&apos;&gt;</div><div class="line">        &lt;slot&gt;&lt;/slot&gt;//只要将自己的slot放进来即可</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.jianshu.com/p/c735cc612e63" target="_blank" rel="external">参考资料</a><br><a href="https://cnodejs.org/topic/58c0ad17d282728c0ec4029a" target="_blank" rel="external">参考资料</a><br><a href="https://segmentfault.com/a/1190000010913794" target="_blank" rel="external">参考资料</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目列表组件需要实现点击自动增加一行,可展示自定义内容的可扩展内容&lt;br&gt;列表table组件被应用在page组件，page组件被应用在具体业
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react 合成事件原理</title>
    <link href="http://yoohannah.github.io/post/react/SyntheticEvent.html"/>
    <id>http://yoohannah.github.io/post/react/SyntheticEvent.html</id>
    <published>2019-01-05T07:37:37.000Z</published>
    <updated>2019-02-11T13:45:57.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h1><h2 id="注册到document"><a href="#注册到document" class="headerlink" title="注册到document"></a>注册到document</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div></pre></td><td class="code"><pre><div class="line">1. reactDOMComponent.js</div><div class="line">export function setInitialProperties(</div><div class="line">  domElement: Element,</div><div class="line">  tag: string,</div><div class="line">  rawProps: Object,</div><div class="line">  rootContainerElement: Element | Document,</div><div class="line">): void &#123;</div><div class="line">  const isCustomComponentTag = isCustomComponent(tag, rawProps);</div><div class="line">  if (__DEV__) &#123; ... &#125;</div><div class="line">  let props: Object;</div><div class="line">  switch (tag) &#123;</div><div class="line">    case &apos;iframe&apos;:</div><div class="line">    case &apos;object&apos;:</div><div class="line">      trapBubbledEvent(TOP_LOAD, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;video&apos;:</div><div class="line">    case &apos;audio&apos;:</div><div class="line">      // Create listener for each media event</div><div class="line">      for (let i = 0; i &lt; mediaEventTypes.length; i++) &#123;</div><div class="line">        trapBubbledEvent(mediaEventTypes[i], domElement); //trapBubbledEvent</div><div class="line">      &#125;</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;source&apos;:</div><div class="line">      trapBubbledEvent(TOP_ERROR, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;img&apos;:</div><div class="line">    case &apos;image&apos;:</div><div class="line">    case &apos;link&apos;:</div><div class="line">      trapBubbledEvent(TOP_ERROR, domElement); //trapBubbledEvent</div><div class="line">      trapBubbledEvent(TOP_LOAD, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;form&apos;:</div><div class="line">      trapBubbledEvent(TOP_RESET, domElement);  //trapBubbledEvent</div><div class="line">      trapBubbledEvent(TOP_SUBMIT, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;details&apos;:</div><div class="line">      trapBubbledEvent(TOP_TOGGLE, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;input&apos;:</div><div class="line">      ReactDOMInputInitWrapperState(domElement, rawProps);</div><div class="line">      props = ReactDOMInputGetHostProps(domElement, rawProps);</div><div class="line">      trapBubbledEvent(TOP_INVALID, domElement);  //trapBubbledEvent</div><div class="line">      // For controlled components we always need to ensure we&apos;re listening</div><div class="line">      // to onChange. Even if there is no listener.</div><div class="line">      ensureListeningTo(rootContainerElement, &apos;onChange&apos;); // ensureListeningTo</div><div class="line">      break;</div><div class="line">    case &apos;option&apos;:</div><div class="line">      ReactDOMOptionValidateProps(domElement, rawProps);</div><div class="line">      props = ReactDOMOptionGetHostProps(domElement, rawProps);</div><div class="line">      break;</div><div class="line">    case &apos;select&apos;:</div><div class="line">      ReactDOMSelectInitWrapperState(domElement, rawProps);</div><div class="line">      props = ReactDOMSelectGetHostProps(domElement, rawProps);</div><div class="line">      trapBubbledEvent(TOP_INVALID, domElement);    //trapBubbledEvent</div><div class="line">      // For controlled components we always need to ensure we&apos;re listening</div><div class="line">      // to onChange. Even if there is no listener.</div><div class="line">      ensureListeningTo(rootContainerElement, &apos;onChange&apos;);  // ensureListeningTo</div><div class="line">      break;</div><div class="line">    case &apos;textarea&apos;:</div><div class="line">      ReactDOMTextareaInitWrapperState(domElement, rawProps);</div><div class="line">      props = ReactDOMTextareaGetHostProps(domElement, rawProps);</div><div class="line">      trapBubbledEvent(TOP_INVALID, domElement);  //trapBubbledEvent</div><div class="line">      // For controlled components we always need to ensure we&apos;re listening</div><div class="line">      // to onChange. Even if there is no listener.</div><div class="line">      ensureListeningTo(rootContainerElement, &apos;onChange&apos;); // ensureListeningTo</div><div class="line">      break;</div><div class="line">    default:</div><div class="line">      props = rawProps;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  assertValidProps(tag, props);</div><div class="line"></div><div class="line">  setInitialDOMProperties(</div><div class="line">    tag,</div><div class="line">    domElement,</div><div class="line">    rootContainerElement,</div><div class="line">    props,</div><div class="line">    isCustomComponentTag,</div><div class="line">  );//这个函数中也会用到 ensureListeningTo</div><div class="line"></div><div class="line">  switch (tag) &#123;</div><div class="line">   //给一些DOM标签通过setAttribute赋值</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function setInitialDOMProperties(</div><div class="line">  tag: string,</div><div class="line">  domElement: Element,</div><div class="line">  rootContainerElement: Element | Document,</div><div class="line">  nextProps: Object,</div><div class="line">  isCustomComponentTag: boolean,</div><div class="line">): void &#123;</div><div class="line">    if(...)&#123;</div><div class="line">      ...</div><div class="line">    &#125; else if (registrationNameModules.hasOwnProperty(propKey)) &#123;</div><div class="line">      if (nextProp != null) &#123;</div><div class="line">        if (__DEV__ &amp;&amp; typeof nextProp !== &apos;function&apos;) &#123;</div><div class="line">          warnForInvalidEventListener(propKey, nextProp);</div><div class="line">        &#125;</div><div class="line">        ensureListeningTo(rootContainerElement, propKey); // ensureListeningTo</div><div class="line">      &#125;</div><div class="line">    &#125; else if (nextProp != null) &#123;</div><div class="line">      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function ensureListeningTo(rootContainerElement, registrationName) &#123;</div><div class="line">  const isDocumentOrFragment =</div><div class="line">    rootContainerElement.nodeType === DOCUMENT_NODE ||</div><div class="line">    rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;</div><div class="line">  const doc = isDocumentOrFragment</div><div class="line">    ? rootContainerElement</div><div class="line">    : rootContainerElement.ownerDocument;</div><div class="line">  listenTo(registrationName, doc);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2.ReactBrowerEventEmitter.js</div><div class="line"></div><div class="line">export function listenTo(</div><div class="line">  registrationName: string,</div><div class="line">  mountAt: Document | Element,</div><div class="line">) &#123;</div><div class="line">  const isListening = getListeningForDocument(mountAt);</div><div class="line">  const dependencies = registrationNameDependencies[registrationName];</div><div class="line"></div><div class="line">  for (let i = 0; i &lt; dependencies.length; i++) &#123;</div><div class="line">    const dependency = dependencies[i];</div><div class="line">    if (!(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])) &#123;</div><div class="line">      switch (dependency) &#123;</div><div class="line">        case TOP_SCROLL:</div><div class="line">          trapCapturedEvent(TOP_SCROLL, mountAt);</div><div class="line">          break;</div><div class="line">        case TOP_FOCUS:</div><div class="line">        case TOP_BLUR:</div><div class="line">          trapCapturedEvent(TOP_FOCUS, mountAt);</div><div class="line">          trapCapturedEvent(TOP_BLUR, mountAt);</div><div class="line">          // We set the flag for a single dependency later in this function,</div><div class="line">          // but this ensures we mark both as attached rather than just one.</div><div class="line">          isListening[TOP_BLUR] = true;</div><div class="line">          isListening[TOP_FOCUS] = true;</div><div class="line">          break;</div><div class="line">        case TOP_CANCEL:</div><div class="line">        case TOP_CLOSE:</div><div class="line">          if (isEventSupported(getRawEventName(dependency))) &#123;</div><div class="line">            trapCapturedEvent(dependency, mountAt);</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">        case TOP_INVALID:</div><div class="line">        case TOP_SUBMIT:</div><div class="line">        case TOP_RESET:</div><div class="line">          // We listen to them on the target DOM elements.</div><div class="line">          // Some of them bubble so we don&apos;t want them to fire twice.</div><div class="line">          break;</div><div class="line">        default:</div><div class="line">          // By default, listen on the top level to all non-media events.</div><div class="line">          // Media events don&apos;t bubble so adding the listener wouldn&apos;t do anything.</div><div class="line">          const isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;</div><div class="line">          if (!isMediaEvent) &#123;</div><div class="line">            trapBubbledEvent(dependency, mountAt);</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">      &#125;</div><div class="line">      isListening[dependency] = true;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">3. ReactDOMEventListener.js</div><div class="line"></div><div class="line">export function trapBubbledEvent(</div><div class="line">  topLevelType: DOMTopLevelEventType,</div><div class="line">  element: Document | Element,</div><div class="line">) &#123;</div><div class="line">  if (!element) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  const dispatch = isInteractiveTopLevelEventType(topLevelType) </div><div class="line">    ? dispatchInteractiveEvent</div><div class="line">    : dispatchEvent;</div><div class="line"></div><div class="line">  addEventBubbleListener(</div><div class="line">    element,//document</div><div class="line">    getRawEventName(topLevelType),//事件类型</div><div class="line">    // Check if interactive and wrap in interactiveUpdates</div><div class="line">    dispatch.bind(null, topLevelType), //回调函数是分发函数 详见执行过程</div><div class="line">  );</div><div class="line">&#125;</div><div class="line">export function trapCapturedEvent(topLevelType, element)&#123;...&#125;</div><div class="line">export function dispatchEvent(topLevelType,nativeEvent) &#123;... &#125;</div><div class="line"></div><div class="line">4. EventListener.js</div><div class="line">export function addEventBubbleListener(</div><div class="line">  element: Document | Element,</div><div class="line">  eventType: string,</div><div class="line">  listener: Function,</div><div class="line">): void &#123;</div><div class="line">  element.addEventListener(eventType, listener, false);</div><div class="line">&#125;</div><div class="line">export function addEventCaptureListener()&#123;...&#125;</div></pre></td></tr></table></figure>
<p>在使用setInitialProperties对标签属性初始化的时候，<br>会根据不同标签自动绑定上冒泡事件或者监听事件<br>document事件回调函数是分发功能函数，不会对任何事件的直接回调函数进行处理，只会根据事件类型进行分发</p>
<h2 id="存储回调函数"><a href="#存储回调函数" class="headerlink" title="存储回调函数"></a>存储回调函数</h2><h1 id="事件执行"><a href="#事件执行" class="headerlink" title="事件执行"></a>事件执行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">//ReactDOMEventListener</div><div class="line">export function dispatchEvent(</div><div class="line">  topLevelType: DOMTopLevelEventType,</div><div class="line">  nativeEvent: AnyNativeEvent,</div><div class="line">) &#123;</div><div class="line">  if (!_enabled) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const nativeEventTarget = getEventTarget(nativeEvent);</div><div class="line">  let targetInst = getClosestInstanceFromNode(nativeEventTarget);</div><div class="line">  if (</div><div class="line">    targetInst !== null &amp;&amp;</div><div class="line">    typeof targetInst.tag === &apos;number&apos; &amp;&amp;</div><div class="line">    !isFiberMounted(targetInst)</div><div class="line">  ) &#123;</div><div class="line">    // If we get an event (ex: img onload) before committing that</div><div class="line">    // component&apos;s mount, ignore it for now (that is, treat it as if it was an</div><div class="line">    // event on a non-React tree). We might also consider queueing events and</div><div class="line">    // dispatching them after the mount.</div><div class="line">    targetInst = null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const bookKeeping = getTopLevelCallbackBookKeeping(</div><div class="line">    topLevelType,</div><div class="line">    nativeEvent,</div><div class="line">    targetInst,</div><div class="line">  );</div><div class="line"></div><div class="line">  try &#123;</div><div class="line">    // Event queue being processed in the same cycle allows</div><div class="line">    // `preventDefault`.</div><div class="line">    batchedUpdates(handleTopLevel, bookKeeping);</div><div class="line">  &#125; finally &#123;</div><div class="line">    releaseTopLevelCallbackBookKeeping(bookKeeping);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function handleTopLevel(bookKeeping) &#123;</div><div class="line">  let targetInst = bookKeeping.targetInst;</div><div class="line"></div><div class="line">  // Loop through the hierarchy, in case there&apos;s any nested components.</div><div class="line">  // It&apos;s important that we build the array of ancestors before calling any</div><div class="line">  // event handlers, because event handlers can modify the DOM, leading to</div><div class="line">  // inconsistencies with ReactMount&apos;s node cache. See #1105.</div><div class="line">  let ancestor = targetInst;</div><div class="line">  do &#123;</div><div class="line">    if (!ancestor) &#123;</div><div class="line">      bookKeeping.ancestors.push(ancestor);</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">    const root = findRootContainerNode(ancestor);</div><div class="line">    if (!root) &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">    bookKeeping.ancestors.push(ancestor);</div><div class="line">    ancestor = getClosestInstanceFromNode(root);</div><div class="line">  &#125; while (ancestor);</div><div class="line"></div><div class="line">  for (let i = 0; i &lt; bookKeeping.ancestors.length; i++) &#123;</div><div class="line">    targetInst = bookKeeping.ancestors[i];</div><div class="line">    runExtractedEventsInBatch(</div><div class="line">      bookKeeping.topLevelType,</div><div class="line">      targetInst,</div><div class="line">      bookKeeping.nativeEvent,</div><div class="line">      getEventTarget(bookKeeping.nativeEvent),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//ReactGenericBatching.js</div><div class="line">export function batchedUpdates(fn, bookkeeping) &#123;</div><div class="line">  if (isBatching) &#123;</div><div class="line">    // If we are currently inside another batch, we need to wait until it</div><div class="line">    // fully completes before restoring state.</div><div class="line">    return fn(bookkeeping);</div><div class="line">  &#125;</div><div class="line">  isBatching = true;</div><div class="line">  try &#123;</div><div class="line">    return _batchedUpdatesImpl(fn, bookkeeping);</div><div class="line">  &#125; finally &#123;</div><div class="line">    // Here we wait until all updates have propagated, which is important</div><div class="line">    // when using controlled components within layers:</div><div class="line">    // https://github.com/facebook/react/issues/1698</div><div class="line">    // Then we restore state of any controlled component.</div><div class="line">    isBatching = false;</div><div class="line">    const controlledComponentsHavePendingUpdates = needsStateRestore();</div><div class="line">    if (controlledComponentsHavePendingUpdates) &#123;</div><div class="line">      // If a controlled event was fired, we may need to restore the state of</div><div class="line">      // the DOM node back to the controlled value. This is necessary when React</div><div class="line">      // bails out of the update without touching the DOM.</div><div class="line">      _flushInteractiveUpdatesImpl();</div><div class="line">      restoreStateIfNeeded();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let _batchedUpdatesImpl = function(fn, bookkeeping) &#123;</div><div class="line">  return fn(bookkeeping);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//EventPluginHub</div><div class="line">export function runExtractedEventsInBatch(</div><div class="line">  topLevelType: TopLevelType,</div><div class="line">  targetInst: null | Fiber,</div><div class="line">  nativeEvent: AnyNativeEvent,</div><div class="line">  nativeEventTarget: EventTarget,</div><div class="line">) &#123;</div><div class="line">  const events = extractEvents(//生成合成事件</div><div class="line">    topLevelType,</div><div class="line">    targetInst,</div><div class="line">    nativeEvent,</div><div class="line">    nativeEventTarget,</div><div class="line">  );</div><div class="line">  runEventsInBatch(events); //批量更新</div><div class="line">&#125;</div><div class="line">export function runEventsInBatch(</div><div class="line">  events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null,</div><div class="line">) &#123;</div><div class="line">  if (events !== null) &#123;</div><div class="line">    eventQueue = accumulateInto(eventQueue, events);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Set `eventQueue` to null before processing it so that we can tell if more</div><div class="line">  // events get enqueued while processing.</div><div class="line">  const processingEventQueue = eventQueue;</div><div class="line">  eventQueue = null;</div><div class="line"></div><div class="line">  if (!processingEventQueue) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);//批量执行</div><div class="line">  invariant(</div><div class="line">    !eventQueue,</div><div class="line">    &apos;processEventQueue(): Additional events were enqueued while processing &apos; +</div><div class="line">      &apos;an event queue. Support for this has not yet been implemented.&apos;,</div><div class="line">  );</div><div class="line">  // This would be a good time to rethrow if any of the event handlers threw.</div><div class="line">  rethrowCaughtError();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="生成合成事件"><a href="#生成合成事件" class="headerlink" title="生成合成事件"></a>生成合成事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//EventPluginHub</div><div class="line">function extractEvents(</div><div class="line">  topLevelType: TopLevelType,</div><div class="line">  targetInst: null | Fiber,</div><div class="line">  nativeEvent: AnyNativeEvent,</div><div class="line">  nativeEventTarget: EventTarget,</div><div class="line">): Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null &#123;</div><div class="line">  let events = null;</div><div class="line">  for (let i = 0; i &lt; plugins.length; i++) &#123;</div><div class="line">    // Not every plugin in the ordering may be loaded at runtime.</div><div class="line">    const possiblePlugin: PluginModule&lt;AnyNativeEvent&gt; = plugins[i];</div><div class="line">    if (possiblePlugin) &#123;</div><div class="line">      const extractedEvents = possiblePlugin.extractEvents(</div><div class="line">        topLevelType,</div><div class="line">        targetInst,</div><div class="line">        nativeEvent,</div><div class="line">        nativeEventTarget,</div><div class="line">      );</div><div class="line">      if (extractedEvents) &#123;</div><div class="line">        events = accumulateInto(events, extractedEvents);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return events;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//DOMEventPluginOrder</div><div class="line">const DOMEventPluginOrder = [</div><div class="line">  &apos;ResponderEventPlugin&apos;,</div><div class="line">  &apos;SimpleEventPlugin&apos;,</div><div class="line">  &apos;EnterLeaveEventPlugin&apos;,</div><div class="line">  &apos;ChangeEventPlugin&apos;,</div><div class="line">  &apos;SelectEventPlugin&apos;,</div><div class="line">  &apos;BeforeInputEventPlugin&apos;,</div><div class="line">];</div><div class="line"></div><div class="line">export default DOMEventPluginOrder;</div></pre></td></tr></table></figure>
<h2 id="获取回调函数"><a href="#获取回调函数" class="headerlink" title="获取回调函数"></a>获取回调函数</h2><h2 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件注册&quot;&gt;&lt;a href=&quot;#事件注册&quot; class=&quot;headerlink&quot; title=&quot;事件注册&quot;&gt;&lt;/a&gt;事件注册&lt;/h1&gt;&lt;h2 id=&quot;注册到document&quot;&gt;&lt;a href=&quot;#注册到document&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
    
      <category term="react" scheme="http://yoohannah.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>VUE 数据绑定初探</title>
    <link href="http://yoohannah.github.io/post/vue/mvvm.html"/>
    <id>http://yoohannah.github.io/post/vue/mvvm.html</id>
    <published>2018-12-30T08:38:15.000Z</published>
    <updated>2018-12-30T08:52:26.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目中遇到一个需求是需要渲染一个列表，然后点击每一行展开按钮，显示该行一个详情<br><img src="/image/vuedata1.png" alt="vuedata1"><br>初步实现想法是在拿到列表数据时，给每一项添加属性show,初始值为false,点击按钮将show改为!show，从而控制详情显示隐藏<br>但发现不生效，详情没有按照预期显示<br>探究其原因是因为数据的改变没有引起界面的重新渲染<br>那么数据是怎么引发界面重新渲染的呢？什么样的数据改变才会引起界面重新渲染呢？</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>VUE 在进行数据双向绑定时，主要用到了两个思想：数据劫持和订阅发布模式</p>
<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>vue 在拿到export default 的data中声明的变量后，会进行跟踪处理，<br>这个跟踪处理主要就是将变量的赋值和读取,参照对象属性的setter和getter进行使用Object.defineProperty重写成响应对象<br>即读取一个变量的数据时会通过调用getter方法return获取值，<br>重新赋值时会通过setter方法判断新值旧值是否相同，不同则进行更新，从而调用更新函数，进行视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a reactive property on an Object.</div><div class="line"> */</div><div class="line">export function defineReactive (</div><div class="line">  obj: Object,</div><div class="line">  key: string,</div><div class="line">  val: any,</div><div class="line">  customSetter?: ?Function,</div><div class="line">  shallow?: boolean</div><div class="line">) &#123;</div><div class="line">  const dep = new Dep()</div><div class="line"></div><div class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</div><div class="line">  if (property &amp;&amp; property.configurable === false) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // cater for pre-defined getter/setters</div><div class="line">  const getter = property &amp;&amp; property.get</div><div class="line">  if (!getter &amp;&amp; arguments.length === 2) &#123;</div><div class="line">    val = obj[key]</div><div class="line">  &#125;</div><div class="line">  const setter = property &amp;&amp; property.set</div><div class="line"></div><div class="line">  let childOb = !shallow &amp;&amp; observe(val)</div><div class="line">  Object.defineProperty(obj, key, &#123;</div><div class="line">    enumerable: true,</div><div class="line">    configurable: true,</div><div class="line">    /******/</div><div class="line">    get: function reactiveGetter () &#123;</div><div class="line">      const value = getter ? getter.call(obj) : val</div><div class="line">      if (Dep.target) &#123; </div><div class="line">        dep.depend()//获取这个值时，即将获取的这个地方当作订阅者放到订阅者列表中</div><div class="line">        if (childOb) &#123;</div><div class="line">          childOb.dep.depend()</div><div class="line">          if (Array.isArray(value)) &#123;</div><div class="line">            dependArray(value)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return value</div><div class="line">    &#125;,</div><div class="line">    /******/</div><div class="line">    /******/</div><div class="line">    set: function reactiveSetter (newVal) &#123;</div><div class="line">      const value = getter ? getter.call(obj) : val</div><div class="line">      /* eslint-disable no-self-compare */</div><div class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; //与旧值相同，直接return 不更新</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      /* eslint-enable no-self-compare */</div><div class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</div><div class="line">        customSetter()</div><div class="line">      &#125;</div><div class="line">      if (setter) &#123;</div><div class="line">        setter.call(obj, newVal)</div><div class="line">      &#125; else &#123;</div><div class="line">        val = newVal //与旧值不同，重新赋值</div><div class="line">      &#125;</div><div class="line">      childOb = !shallow &amp;&amp; observe(newVal)</div><div class="line">      dep.notify() //通知更新</div><div class="line">    &#125;</div><div class="line">    /******/</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h2><p>进行视图更新时,更新函数需要知道视图哪些地方需要更新，以及由于该变量发生变化可能引起的其他变量变化或者触发一定的功能函数，<br>所以我们需要对数据的变化进行监听，并告知用到变量的地方（即订阅者），变量发生了变化，需要执行依据此变化要做的事<br>因为订阅者很可能不止一个（即一个变量被多处用到,包括js和html模板）,所以我们需要一个地方存放订阅者，并批量通知订阅者进行更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">mport type Watcher from &apos;./watcher&apos; //或初始化watcher</div><div class="line">import &#123; remove &#125; from &apos;../util/index&apos;</div><div class="line"></div><div class="line">let uid = 0</div><div class="line"></div><div class="line">/**</div><div class="line"> * A dep is an observable that can have multiple</div><div class="line"> * directives subscribing to it.</div><div class="line"> */</div><div class="line">export default class Dep &#123;</div><div class="line">  static target: ?Watcher;</div><div class="line">  id: number;</div><div class="line">  subs: Array&lt;Watcher&gt;;</div><div class="line"></div><div class="line">  constructor () &#123;</div><div class="line">    this.id = uid++</div><div class="line">    this.subs = [] //订阅者集合</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addSub (sub: Watcher) &#123;  //添加订阅者集合</div><div class="line">    this.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  removeSub (sub: Watcher) &#123;</div><div class="line">    remove(this.subs, sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  depend () &#123;</div><div class="line">    if (Dep.target) &#123;</div><div class="line">      Dep.target.addDep(this)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify () &#123; //批量更新</div><div class="line">    // stabilize the subscriber list first</div><div class="line">    const subs = this.subs.slice()</div><div class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// the current target watcher being evaluated.</div><div class="line">// this is globally unique because there could be only one</div><div class="line">// watcher being evaluated at any time.</div><div class="line">Dep.target = null</div><div class="line">const targetStack = []</div><div class="line"></div><div class="line">export function pushTarget (_target: ?Watcher) &#123;</div><div class="line">  if (Dep.target) targetStack.push(Dep.target)</div><div class="line">  Dep.target = _target  //将watcher缓存到Dep.target</div><div class="line">&#125;</div><div class="line"></div><div class="line">export function popTarget () &#123;</div><div class="line">  Dep.target = targetStack.pop()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义订阅者，订阅者需要自己将自己放到变量的订阅者列表中，采用的方法是将自己暂存在Dep.target上，<br>在初始化的时候调用一下变量，利用变量getter方法，将自己添加到订阅者列表，然后将Dep.target至空，取消暂存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">export default class Watcher &#123;</div><div class="line">  vm: Component;</div><div class="line">  expression: string;</div><div class="line">  cb: Function;</div><div class="line">  id: number;</div><div class="line">  deep: boolean;</div><div class="line">  user: boolean;</div><div class="line">  lazy: boolean;</div><div class="line">  sync: boolean;</div><div class="line">  dirty: boolean;</div><div class="line">  active: boolean;</div><div class="line">  deps: Array&lt;Dep&gt;;</div><div class="line">  newDeps: Array&lt;Dep&gt;;</div><div class="line">  depIds: SimpleSet;</div><div class="line">  newDepIds: SimpleSet;</div><div class="line">  getter: Function;</div><div class="line">  value: any;</div><div class="line"></div><div class="line">  constructor (</div><div class="line">    vm: Component,</div><div class="line">    expOrFn: string | Function,</div><div class="line">    cb: Function,</div><div class="line">    options?: ?Object,</div><div class="line">    isRenderWatcher?: boolean</div><div class="line">  ) &#123;</div><div class="line">    this.value = this.lazy</div><div class="line">      ? undefined</div><div class="line">      : this.get() //将watcher 自己装进变量的订阅者列表</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Evaluate the getter, and re-collect dependencies.</div><div class="line">   */</div><div class="line">  get () &#123;</div><div class="line">    pushTarget(this) //暂存到Dep.target</div><div class="line">    let value</div><div class="line">    const vm = this.vm</div><div class="line">    try &#123;</div><div class="line">      value = this.getter.call(vm, vm) //调用变量的getter函数，将自己装到订阅者列表</div><div class="line">    &#125; catch (e) &#123;</div><div class="line">      if (this.user) &#123;</div><div class="line">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</div><div class="line">      &#125; else &#123;</div><div class="line">        throw e</div><div class="line">      &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">      // &quot;touch&quot; every property so they are all tracked as</div><div class="line">      // dependencies for deep watching</div><div class="line">      if (this.deep) &#123;</div><div class="line">        traverse(value)</div><div class="line">      &#125;</div><div class="line">      popTarget()//取消watcher暂存，释放该watcher的绑定</div><div class="line">      this.cleanupDeps()</div><div class="line">    &#125;</div><div class="line">    return value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  </div><div class="line">  /**</div><div class="line">   * Subscriber interface.</div><div class="line">   * Will be called when a dependency changes.</div><div class="line">   */</div><div class="line">  update () &#123; //dep批量更新调用</div><div class="line">    /* istanbul ignore else */</div><div class="line">    if (this.lazy) &#123;</div><div class="line">      this.dirty = true</div><div class="line">    &#125; else if (this.sync) &#123;</div><div class="line">      this.run()</div><div class="line">    &#125; else &#123;</div><div class="line">      queueWatcher(this)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Scheduler job interface.</div><div class="line">   * Will be called by the scheduler.</div><div class="line">   */</div><div class="line">  run () &#123;</div><div class="line">    if (this.active) &#123;</div><div class="line">      const value = this.get()</div><div class="line">      if (</div><div class="line">        value !== this.value ||</div><div class="line">        // Deep watchers and watchers on Object/Arrays should fire even</div><div class="line">        // when the value is the same, because the value may</div><div class="line">        // have mutated.</div><div class="line">        isObject(value) ||</div><div class="line">        this.deep</div><div class="line">      ) &#123;</div><div class="line">        // set new value</div><div class="line">        const oldValue = this.value</div><div class="line">        this.value = value</div><div class="line">        if (this.user) &#123;</div><div class="line">          try &#123;</div><div class="line">            this.cb.call(this.vm, value, oldValue) //执行更新回调</div><div class="line">          &#125; catch (e) &#123;</div><div class="line">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</div><div class="line">          &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">          this.cb.call(this.vm, value, oldValue) //执行更新回调</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h2><p>在解析模板时遇到指令或者&#123;&#123;&#125;&#125;时，将变量值替换到dom节点中，然后生成一个订阅者(根据参数将自己添加到对应绑定变量的订阅者列表中)，将自己的更新订阅到变量的变化中，从而在变量变化时，更新视图，<br>每解析到一个地方用到同一个变量，就生成一个watcher,从而反应出需要使用订阅者列表进行批量更新</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上，当变量在声明时会被劫持转成可响应对象，变量的读取更新，通过get和set完成，<br>在get时添加自己的订阅者，在set时告诉订阅者进行批量更新<br>订阅者管家由一个Dep对象负责，进行添加，触发更新等工作<br>订阅者对象需要表明自己是谁，能够将自己添加到订阅者列表，根据变量变化执行更新回调<br>页面上的变量会在编译时生成订阅器，将自己订阅到变量的订阅列表中，从而在变量变化时得到更新</p>
<p><img src="/image/vuedata2.png" alt="vuedata2"></p>
<h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>vue 在进行数据劫持时，会对对象进行递归处理，直到递归到的属性值是一个基本变量，即监听到基本变量变化，值监听<br>所以变量本身值是一个基本变量，则直接进行响应对象转化<br>但会根据变量是否是数组进行特殊处理，只是对数组每一项进行监听，除非值又是一个数组才会递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">export class Observer &#123;</div><div class="line">  value: any;</div><div class="line">  dep: Dep;</div><div class="line">  vmCount: number; // number of vms that has this object as root $data</div><div class="line"></div><div class="line">  constructor (value: any) &#123;</div><div class="line">    this.value = value</div><div class="line">    this.dep = new Dep()</div><div class="line">    this.vmCount = 0</div><div class="line">    def(value, &apos;__ob__&apos;, this)</div><div class="line">    if (Array.isArray(value)) &#123; //数组</div><div class="line">      const augment = hasProto</div><div class="line">        ? protoAugment</div><div class="line">        : copyAugment</div><div class="line">      augment(value, arrayMethods, arrayKeys)</div><div class="line">      this.observeArray(value)</div><div class="line">    &#125; else &#123;</div><div class="line">      this.walk(value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Walk through each property and convert them into</div><div class="line">   * getter/setters. This method should only be called when</div><div class="line">   * value type is Object.</div><div class="line">   */</div><div class="line">  walk (obj: Object) &#123;</div><div class="line">    const keys = Object.keys(obj)</div><div class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</div><div class="line">      defineReactive(obj, keys[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Observe a list of Array items.</div><div class="line">   */</div><div class="line">  observeArray (items: Array&lt;any&gt;) &#123;</div><div class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</div><div class="line">      observe(items[i]) //判断对数组值进行判断</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</div><div class="line">  if (!isObject(value) || value instanceof VNode) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  let ob: Observer | void</div><div class="line">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</div><div class="line">    ob = value.__ob__</div><div class="line">  &#125; else if (</div><div class="line">    shouldObserve &amp;&amp;</div><div class="line">    !isServerRendering() &amp;&amp;</div><div class="line">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp; //值又是数组</div><div class="line">    Object.isExtensible(value) &amp;&amp;</div><div class="line">    !value._isVue</div><div class="line">  ) &#123;</div><div class="line">    ob = new Observer(value) //递归转化</div><div class="line">  &#125;</div><div class="line">  if (asRootData &amp;&amp; ob) &#123;</div><div class="line">    ob.vmCount++</div><div class="line">  &#125;</div><div class="line">  return ob</div></pre></td></tr></table></figure>
<p>带来的缺陷就是<br>对于对象来说，初始化以后，对象新增的属性不会被纳入监听范围,属性的删除也不能被监听到<br>对于数组来说，如果是一个对象数组，则数组里每一个对象里的属性值的增删改均不会被监听到</p>
<p>解决办法<br>对于数组来说，通过使用代码规定的<br>  ‘push’,<br>  ‘pop’,<br>  ‘shift’,<br>  ‘unshift’,<br>  ‘splice’,<br>  ‘sort’,<br>  ‘reverse’<br>几种方法可触发更新，实现对数组的修改，<br>例如，这里的问题，使用this.data.splice(index,1,obj),将原来的数组项替换掉，<br>从而达到更新</p>
<p>对于对象来说,可以使用如下两中方法进行更新<br>this.$set(obj,keyStr,val)//新增属性<br>obj = Object.assign({},obj,newItemObj) //删除/更改</p>
<p>在本问题中，目前的解决办法是引入新变量存放点击的行数，根据该变量值是否等于当前行，<br>更改class值，从而控制展开关闭</p>
<p><a href="https://www.cnblogs.com/libin-1/p/6893712.html" target="_blank" rel="external">参照资料</a><br><a href="https://github.com/vuejs/vue/tree/dev/src/core/observer" target="_blank" rel="external">源码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目中遇到一个需求是需要渲染一个列表，然后点击每一行展开按钮，显示该行一个详情&lt;br&gt;&lt;img src=&quot;/image/vuedata1.p
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
