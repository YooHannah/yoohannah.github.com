<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Little World</title>
  <subtitle>learn and share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoohannah.github.io/"/>
  <updated>2017-05-02T14:21:36.294Z</updated>
  <id>http://yoohannah.github.io/</id>
  
  <author>
    <name>YooHannah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片上传</title>
    <link href="http://yoohannah.github.io/post/php/php_imge.html"/>
    <id>http://yoohannah.github.io/post/php/php_imge.html</id>
    <published>2017-05-02T14:22:37.000Z</published>
    <updated>2017-05-02T14:21:36.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用函数画图"><a href="#用函数画图" class="headerlink" title="用函数画图"></a>用函数画图</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">//创建图片</div><div class="line">$img = imagecreatetruecolor(500, 500);</div><div class="line"></div><div class="line">//分配颜色 为图片准备需要用到的颜色</div><div class="line">$red = imagecolorallocate($img, 255, 0, 0);</div><div class="line"></div><div class="line">$green = imagecolorallocate($img, 0, 255, 0);</div><div class="line"></div><div class="line">$blue = imagecolorallocate($img, 0, 0, 255);</div><div class="line"></div><div class="line">$pur = imagecolorallocate($img, 255, 0, 255);</div><div class="line"></div><div class="line">$yellow = imagecolorallocate($img, 121, 72, 0);</div><div class="line"></div><div class="line"></div><div class="line">//填充背景 (0,0)(500,500)指图片左上角和右下角两点，从而确定图片的矩形</div><div class="line">imagefilledrectangle($img, 0, 0, 500, 500, $green);</div><div class="line"></div><div class="line">//画对角线 对角线起始点坐标</div><div class="line">imageline($img, 0, 0, 500, 500, $red);</div><div class="line">imageline($img, 500, 0, 0, 500, $blue);</div><div class="line"></div><div class="line">//画圆</div><div class="line">//bool imagefilledellipse ( resource $图片资源 , int $圆心x , int $圆心y , int $圆的宽 , int $圆的高 , int $圆的颜色 )</div><div class="line">imagefilledellipse($img, 250, 250, 200, 200, $yellow);</div><div class="line"></div><div class="line">//圆中间画矩形，同样通过左上角右下角确定矩形</div><div class="line">imagefilledrectangle($img, 200, 200, 300, 300, $blue);</div><div class="line"></div><div class="line"></div><div class="line">//保存图片，图片名为haha.jpg</div><div class="line">imagejpeg($img, &apos;haha.jpg&apos;);</div><div class="line"></div><div class="line">//销毁资源</div><div class="line">imagedestroy($img);</div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h1 id="画验证码"><a href="#画验证码" class="headerlink" title="画验证码"></a>画验证码</h1><p><a href="https://github.com/YooHannah/algorithm/blob/master/php/Verificationcode.php" target="_blank" rel="external">代码链接</a></p>
<h1 id="图片加水印"><a href="#图片加水印" class="headerlink" title="图片加水印"></a>图片加水印</h1><p>bool imagecopymerge ( resource $目标图片 , resource $来源图片, int $目标开始的x , int $目标开始的y, int $来源的x , int $来源的y , int $来源的宽 , int $来源的高 , int $透明度)<br>注意：<br>透明度的值为0-100的整数。imagecopy和imagecopymerge的区别在于一个有透明度，一个没有透明度。<br> 1.打开原图（也叫操作的目标图片）<br> 2.打开水印图（也叫水印来源图片）<br> 3.使用 imagecopymerge 将小图合并至大图的指定位置<br> 4.输出图片<br> 5.销毁资源<br> <a href="https://github.com/YooHannah/algorithm/blob/master/php/Watermark.php" target="_blank" rel="external">代码链接</a></p>
<h1 id="图像放缩和裁剪"><a href="#图像放缩和裁剪" class="headerlink" title="图像放缩和裁剪"></a>图像放缩和裁剪</h1><p>操作方式说明：<br>从来源图片的开始点(x,y)起，指定的宽高的大小图片。放至到目标图片的起点(x,y)，指定宽高大小的图片中。</p>
<h2 id="缩放图片"><a href="#缩放图片" class="headerlink" title="缩放图片"></a>缩放图片</h2><p>imagecopyresampled    重采样拷贝部分图像并调整大小<br>bool imagecopyresampled ( resource $目标图 , resource $来源图 , int $目标开始的x位置 , int $目标开始的y位置 , int $来源开始的x位置 , int $来源开始的y位置 , int $目标图片的宽 , int $目标图片的高, int $来源图片的宽 , int $来源图片的高 )<br>1.打开来源图片<br>2.设置图片缩放百分比（缩放）<br>3.获得来源图片，按比调整大小<br>4.新建一个指定大小的图片为目标图<br>5.将来源图调整后的大小放到目标中<br>6.销毁资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">//打开来源图片</div><div class="line">$image = imagecreatefrompng(&apos;fbb.png&apos;);</div><div class="line"></div><div class="line"></div><div class="line">//定义百分比，缩放到0.1大小</div><div class="line">$percent = 0.1;</div><div class="line"></div><div class="line"></div><div class="line">// 将图片宽高获取到</div><div class="line">list($width, $height) = getimagesize(&apos;fbb.png&apos;);</div><div class="line"></div><div class="line">//设置新的缩放的宽高</div><div class="line">$new_width = $width * $percent;</div><div class="line">$new_height = $height * $percent;</div><div class="line"></div><div class="line">//创建新图片</div><div class="line">$new_image = imagecreatetruecolor($new_width, $new_height);</div><div class="line"></div><div class="line">//将原图$image按照指定的宽高，复制到$new_image指定的宽高大小中</div><div class="line">imagecopyresampled($new_image, $image, 0, 0, 0, 0, $new_width, $new_height, $width, $height);</div><div class="line"></div><div class="line">header(&apos;content-type:image/jpeg&apos;);</div><div class="line">imagejpeg($new_image);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h2 id="裁剪图片"><a href="#裁剪图片" class="headerlink" title="裁剪图片"></a>裁剪图片</h2><p>imagecopyresized    拷贝部分图像并调整大小<br>bool imagecopyresized ( resource $目标图 , resource $来源图 , int $目标开始的x位置 , int $目标开始的y位置 , int $来源开始的x位置 , int $来源开始的y位置 , int $目标图片的宽 , int $目标图片的高, int $来源图片的宽 , int $来源图片的高 )<br> 1.打开来源图片和目标图片<br> 2.截取来源图片中的点，设置宽高。放至到目标图片中。（裁剪）<br> 3.保存图片输入<br> 4.销毁资源</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"> $dst = imagecreatefrompng(&apos;hsq.png&apos;);</div><div class="line"> $src = imagecreatefrompng(&apos;du.png&apos;);</div><div class="line"> imagecopyresized($dst, $src, 281, 71, 407, 154, 132, 160, 80, 90);</div><div class="line"> header(&apos;content-type:image/jpeg&apos;);</div><div class="line">imagejpeg($dst);</div><div class="line">imagedestroy($dst);</div><div class="line"> imagedestroy($src);</div><div class="line"> ?&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用函数画图&quot;&gt;&lt;a href=&quot;#用函数画图&quot; class=&quot;headerlink&quot; title=&quot;用函数画图&quot;&gt;&lt;/a&gt;用函数画图&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
    
    </summary>
    
    
      <category term="php" scheme="http://yoohannah.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="http://yoohannah.github.io/post/php/php_fileupload.html"/>
    <id>http://yoohannah.github.io/post/php/php_fileupload.html</id>
    <published>2017-05-02T14:21:37.000Z</published>
    <updated>2017-05-02T14:21:14.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改php-ini文件配置"><a href="#修改php-ini文件配置" class="headerlink" title="修改php.ini文件配置"></a>修改php.ini文件配置</h1><p>php.ini文件在不同的集成环境包中都在安装目录的php文件下,如果有多个版本php,则在每个版本里面都会有一个php.ini文件<br>配置项    功能说明<br>file_uploads    on为 开启文件上传功能，off为关闭<br>post_max_size    系统允许的POST传参的最大值<br>upload_max_filesize    系统允许的上传文件的最大值<br>memory_limit    内存使用限制<br>建议尺寸： file_size(文件大小) &lt; upload_max_filesize &lt; post_max_size &lt; memory_limit<br>max_execution_time 设定脚本的最大执行时间。<br>也可以根据需求做适当的改变。通常不需要来修改，系统默认值即可。超大文件上传的时候，可能会涉及到这一项参数的修改<br>上传时间太长了，会超时。如果你将此项参数设为0，则是不限制超时时间，不建议使。</p>
<h1 id="html页面"><a href="#html页面" class="headerlink" title="html页面"></a>html页面</h1><p>1.form 表单中的参数method 必须为post。若为get是无法进行文件上传的<br>2.enctype须为multipart/form-data<br><a href="https://github.com/YooHannah/algorithm/blob/master/php/fileupload/fileupload.html" target="_blank" rel="external">代码链接</a></p>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>按照数组和步骤完成文件上传<br>所有文件的信息存储在$_FILES[‘file’]中<br><a href="https://github.com/YooHannah/algorithm/blob/master/php/fileupload/file.php" target="_blank" rel="external">代码链接</a></p>
<h1 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h1><p>写了2个或者多个input<br>将每个input name设置为”file[]”<br>对每个input上传文件后 $_FILE[‘file’]的每个属性将变成数组，依次对应每个input上传的文件</p>
<h1 id="上传进度处理"><a href="#上传进度处理" class="headerlink" title="上传进度处理"></a>上传进度处理</h1><p>首先要修改php.ini的相关配置<br>配置项    说明<br>session.upload_progress.enabled    是否启用上传进度报告(默认开启) 1为开启，0为关闭<br>session.upload_progress.cleanup    是否在上传完成后及时删除进度数据(默认开启, 推荐开启)<br>session.upload_progress.prefix[=upload<em>progress</em>]    进度数据将存储在_SESSION[session.upload_progress.prefix . _POST[session.upload_progress.name]]<br>session.upload_progress.name[=PHP_SESSION_UPLOAD_PROGRESS]    如果_POST[session.upload_progress.name]没有被设置, 则不会报告进度.<br>session.upload_progress.freq[=1%]    更新进度的频率(已经处理的字节数), 也支持百分比表示’%’.<br>session.upload_progress.min_freq[=1.0]    更新进度的时间间隔(秒)</p>
<p>文件上传的进度信息存储在$_SESSION中<br><a href="https://github.com/YooHannah/algorithm/blob/master/php/fileupload/progress.php" target="_blank" rel="external">代码链接</a></p>
<p>If no other git process is currently running, this probably means a<br>git process crashed in this repository earlier. Make sure no other git<br>process is running and remove the file manually to continue.<br>解决方法：<br>rm -f ./.git/index.lock</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;修改php-ini文件配置&quot;&gt;&lt;a href=&quot;#修改php-ini文件配置&quot; class=&quot;headerlink&quot; title=&quot;修改php.ini文件配置&quot;&gt;&lt;/a&gt;修改php.ini文件配置&lt;/h1&gt;&lt;p&gt;php.ini文件在不同的集成环境包中都在安装目录的
    
    </summary>
    
    
      <category term="php" scheme="http://yoohannah.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>文件</title>
    <link href="http://yoohannah.github.io/post/php/php_file.html"/>
    <id>http://yoohannah.github.io/post/php/php_file.html</id>
    <published>2017-05-01T00:40:37.000Z</published>
    <updated>2017-05-01T14:34:31.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读"><a href="#读" class="headerlink" title="读"></a>读</h1><p>readfile 传入一个文件路径，输出一个文件<br>int readfile ( string $文件名)</p>
<p>file_get_contents 传入一个文件或文件路径，打开这个文件返回文件的内容。文件的内容是一个字符串。<br>string file_get_contents ( string filename)</p>
<p>资源类型处理方式<br>fopen函数，打开资源，参数为文件打开路径，打开文件模式，返回资源类型<br>resource fopen ( string $文件名, string 模式)</p>
<p>fread函数 读取打开的文件资源。读取指定长度的文件资源，读取一部份向后移动一部份。至到文件结尾。<br>string fread ( resource $操作资源, int 读取长度)</p>
<p>fclose函数的功能是关闭资源。资源有打开就有关闭<br>bool fclose ( resource $操作资源 )</p>
<p>fopen的模式<br>模式    说明<br>r    只读方式打开，将文件指针指向文件头。<br>r+    读写方式打开，将文件指针指向文件头。<br>w    写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建<br>w+    读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建<br>a    写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建<br>a+    读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之<br>x    创建并以写入方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建<br>x+<br>创建并以读写方式打开，将文件指针指向文件头。如果文件已存在，则 fopen() 调用失败并返回 FALSE，并生成一条 E_WARNING 级别的错误信息。如果文件不存在则尝试创建<br>t    windows下将\n转为\r\n<br>b    二进制打开模式</p>
<h1 id="创建和修改"><a href="#创建和修改" class="headerlink" title="创建和修改"></a>创建和修改</h1><p>file_put_contents 向指定的文件当中写入一个字符串，如果文件不存在则创建文件。返回的是写入的字节长度<br>int file_put_contents ( string $文件路径, string $写入数据])</p>
<p> fwrite 配合fopen进行写入操作，写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建<br> int fwrite ( resource $文件资源变量, string $写入的字符串 [, int 长度])<br> 1.不论有没有新建都会打开文件重新写入<br> 2.原有的文件内容会被覆盖掉<br> 3.文件不存在会创建<br> 模式<br> x    每次写入会干掉原有文件的内容，文件不存在都会创建<br> a    每次写入都会向文件的尾端追加内容</p>
<p>  tmpfile  创建一个临时文件，返回资源类型。关闭文件即被删除<br>  resource tmpfile ( )</p>
<p>  rename 重命名文件 返回一个bool值，将旧的名字改为新的名字<br>  bool rename($旧名,$新名);</p>
<p>  copy 复制文件 将指定路径的源文件，复制一份到目标文件的位置。<br>  bool copy(源文件,目标文件)</p>
<p>  unlink 删除文件 这个删除是直接删除。使用的是windows电脑，在回收站看不到这个文件<br>  bool unlink(指定路径的文件)</p>
<h1 id="检测文件属性函数"><a href="#检测文件属性函数" class="headerlink" title="检测文件属性函数"></a>检测文件属性函数</h1><pre><code>bool file_exists ( $指定文件名或者文件路径) 功能：文件是否存在。
bool is_readable ( $指定文件名或者文件路径) 功能：文件是否可读
bool is_writeable ( $指定文件名或者文件路径) 功能：文件是否可写
bool is_executable ( $指定文件名或者文件路径) 功能：文件是否可执行
bool is_file ( $指定文件名或者文件路径) 功能：是否是文件
bool is_dir ( $指定文件名或者文件路径) 功能：是否是目录
void clearstatcache ( void ) 功能：清楚文件的状态缓存
</code></pre><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><p>rewind ( resource handle) 指针回到开始处<br>fseek ( resource handle, int offset [, int from_where]) 文件指针向后移动指定字符<br>filesize 检测文件的大小<br>file(文件名)    把整个文件读入一个数组中<br>fgets(文件名)    从文件指针中读取一行,读到最后返回false<br>fgetc(文件名)    从文件指针中读取一个字符，读到最后返回false<br>ftruncate(文件名，长度)    将文件截断到给定的长度<br>filectime(文件名)    文件创建时间<br>filemtime(文件名)    文件修改时间<br>fileatime(文件名)    文件上次访问时间</p>
<h1 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h1><p>bool flock ( resource $handle , int $operation) 轻便的咨询文件锁定<br>锁类型    说明<br>LOCK_SH    取得共享锁定（读取的程序）<br>LOCK_EX    取得独占锁定（写入的程序<br>LOCK_UN    释放锁定（无论共享或独占）<br>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">$fp = fopen(&quot;demo.txt&quot;, &quot;r+&quot;);</div><div class="line"></div><div class="line">// 进行排它型锁定</div><div class="line">if (flock($fp, LOCK_EX)) &#123; </div><div class="line"></div><div class="line">   fwrite($fp, &quot;文件这个时候被我独占了哟\n&quot;);</div><div class="line"></div><div class="line">  // 释放锁定</div><div class="line">   flock($fp, LOCK_UN);    </div><div class="line">&#125; else &#123;</div><div class="line">   echo &quot;锁失败，可能有人在操作，这个时候不能将文件上锁&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fclose($fp);</div><div class="line"></div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="处理文件夹"><a href="#处理文件夹" class="headerlink" title="处理文件夹"></a>处理文件夹</h1><p>处理文件夹的基本思想如下：<br>1.读取某个路径的时候判断是否是文件夹<br>2.是文件夹的话，打开指定文件夹，返回文件目录的资源变量<br>3.使用readdir读取一次目录中的文件，目录指针向后偏移一次<br>4.使用readdir读取到最后，没有可读的文件返回false<br>5.关闭文件目录</p>
<p>opendir    打开文件夹，返回操作资源<br>readdir    读取文件夹资源<br>is_dir    判断是否是文件夹<br>closedir    关闭文件夹操作资源<br>filetype    显示是文件夹还是文件，文件显示file，文件夹显示dir<br>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">//设置打开的目录是D盘</div><div class="line">$dir = &quot;d:/&quot;;</div><div class="line"></div><div class="line">//判断是否是文件夹，是文件夹</div><div class="line">if (is_dir($dir)) &#123;</div><div class="line">   if ($dh = opendir($dir)) &#123;</div><div class="line"></div><div class="line">      //读取一次向后移动一次文件夹指针</div><div class="line">      echo readdir($dh).&apos;&lt;br /&gt;&apos;;</div><div class="line">      echo readdir($dh).&apos;&lt;br /&gt;&apos;;</div><div class="line">      echo readdir($dh).&apos;&lt;br /&gt;&apos;;</div><div class="line">      echo readdir($dh).&apos;&lt;br /&gt;&apos;;</div><div class="line"></div><div class="line">      //读取到最后返回false</div><div class="line"></div><div class="line">      //关闭文件夹资源</div><div class="line">       closedir($dh);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h1 id="文件权限设置"><a href="#文件权限设置" class="headerlink" title="文件权限设置"></a>文件权限设置</h1><p>函数用法与linux的权限操作的用法一样。<br>函数    功能说明<br>chmod    修改读取模式<br>chgrp    修改用户组<br>chown    修改权限</p>
<h1 id="文件路径函数"><a href="#文件路径函数" class="headerlink" title="文件路径函数"></a>文件路径函数</h1><p>array pathinfo ( string $路径)<br>功能：传入文件路径返回文件的各个组成部份<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$path_parts = pathinfo(&apos;d:/www/index.inc.php&apos;);</div><div class="line"></div><div class="line">echo &apos;文件目录名：&apos;.$path_parts[&apos;dirname&apos;].&quot;&lt;br /&gt;&quot;;//d:/www</div><div class="line">echo &apos;文件全名：&apos;.$path_parts[&apos;basename&apos;].&quot;&lt;br /&gt;&quot;;//index.inc.php</div><div class="line">echo &apos;文件扩展名：&apos;.$path_parts[&apos;extension&apos;].&quot;&lt;br /&gt;&quot;;//php</div><div class="line">echo &apos;不包含扩展的文件名：&apos;.$path_parts[&apos;filename&apos;].&quot;&lt;br /&gt;&quot;; //index.inc</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>string basename ( string $路径[, string $suffix ])<br>功能：传入路径返回文件名<br>第一个参数传入路径。<br>第二个参数，指定我文件名到了指定字符停止。</p>
<p>dirname(string $路径)<br>功能：返回文件路径的文件目录部份</p>
<p>mixed parse_url ( string $路径 )<br>功能：将网址拆解成各个部份</p>
<p>string http_build_query ( mixed $需要处理的数据)<br>功能：生成url 中的query字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//定义一个关联数组</div><div class="line">$data = [</div><div class="line">       &apos;username&apos;=&gt;&apos;php&apos;,</div><div class="line">       &apos;area&apos;=&gt;&apos;hubei&apos;</div><div class="line">        ];</div><div class="line"></div><div class="line">//生成query内容</div><div class="line">echo http_build_query($data);//username=php&amp;area=hubei</div></pre></td></tr></table></figure></p>
<p>http_build_url()<br>功能： 生成一个url</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;读&quot;&gt;&lt;a href=&quot;#读&quot; class=&quot;headerlink&quot; title=&quot;读&quot;&gt;&lt;/a&gt;读&lt;/h1&gt;&lt;p&gt;readfile 传入一个文件路径，输出一个文件&lt;br&gt;int readfile ( string $文件名)&lt;/p&gt;
&lt;p&gt;file_get_co
    
    </summary>
    
    
      <category term="php" scheme="http://yoohannah.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoohannah.github.io/post/php/php_reg.html"/>
    <id>http://yoohannah.github.io/post/php/php_reg.html</id>
    <published>2017-04-30T12:04:37.000Z</published>
    <updated>2017-05-01T00:39:55.648Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达示主要用在以下一些地方：<br>1.匹配邮箱、手机号码、验证码<br>2.替换敏感的关键词。例如：涉及政治和骂人的话<br>3.文章采集。<br>4.早期的表情替换技术,ubb文件编码、markdown编辑器替换等<br>5.以后自己写模板引擎也需要用到正则表达示</p>
<h1 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h1><p>定界符，就是定一个边界，边界已内的就是正则表达示<br>定界符，不能用a-zA-Z0-9\ 其他的都可以用。必须成对出现，有开始就有结束。<br>/中间写正则/    正确<br>$中间写正则$    正确<br>%中间写正则%    正确<br>^中间写正则^    正确<br>@中间写正则@    正确<br>(中间写正则)    错误<br>A中间写正则A    错误</p>
<h1 id="匹配函数和原子"><a href="#匹配函数和原子" class="headerlink" title="匹配函数和原子"></a>匹配函数和原子</h1><p>preg_matc 函数：根据$正则变量，匹配$字符串变量。如果存在则返回匹配的个数，把匹配到的结果放到$结果变量里。如果没有匹配到结果返回0。<br>int preg_match ( string $正则 , string $字符串 [, array &amp;$结果] )</p>
<p>原子：需要匹配的内容，我们见到的空格、回车、换行、0-9、A-Za-z、中文、标点符号、特殊符号全为原子<br>特殊标志的原子：<br>原子    说明<br>\d    匹配一个0-9<br>\D    除了0-9以外的所有字符<br>\w    a-zA-Z0-9<em><br>\W    除了0-9A-Za-z</em>以外的所有字符<br>\s    匹配所有空白字符\n \t \r 空格<br>\S    匹配所有非空白字符<br>[ ]    指定范围的原子</p>
<p>[^ 字符] 不匹配指定区间的字符^ 抑扬符在中括号里面的作用是不准以中括号里面的字符进行匹配。</p>
<p>使用原子的时候，只能够匹配一个字符</p>
<h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p>元字符来修饰原子，实现更多次匹配<br>元字符    功能说明</p>
<ul>
<li>是代表匹配前面的一个原子，匹配0次或者任意多次前面的字符。</li>
</ul>
<ul>
<li>匹配最少1次前面的字符<br>?    前面的一个字符可有可无【可选】 有或没有<br>.    更标准一些应该把点算作原子。匹配除了\n以外的所有字符<br>|    或者。注：它的优先级最低了。<br>^    必须要以抑扬符之后的字符串开始<br>$    必须要以$之前的字符结尾<br>{m}    有且只能出现m次<br>{n,m}    可以出现n到m次<br>{m,}    至少m次，最大次数不限制<br>()    改变优先级或者将某个字符串视为一个整体，匹配到的数据取出来也可以使用它</li>
</ul>
<p>1.正则表达示是有边界的，这个边界是定界符的开始和结尾是正则的边界。<br>2.this是一个英文单词，后面加上一个空格，意味着这个词结束了，到达了这个词的边界<br>\b词边界，就是指匹配的字符必须要在最前或者最后。<br>\B非边界，就是匹配的字符不能在一个正则表达示的最前或者最后</p>
<h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>模式匹配符的用法如下：<br>/ 正则表达式/模式匹配符</p>
<p>模式匹配符    功能<br>i    模式中的字符将同时匹配大小写字母.</p>
<p>m    当设定了此修正符，“行起始”和“行结束”除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前。<br>    如果要匹配的字符串中没有“\n”字符或者模式中没有 ^ 或 $，则设定此修正符没有任何效果</p>
<p>s    将字符串视为单行,换行符\n作为普通字符.<br>    如果设定了此修正符，模式中的圆点元字符（.）匹配所有的字符，包括换行符。</p>
<p>x    将模式中的空白忽略.<br>    1.如果设定了此修正符，模式中的空白字符除了被转义的或在字符类中的以外完全被忽略。<br>    2.未转义的字符类外部的#字符和下一个换行符之间的字符也被忽略。</p>
<p>A    强制仅从目标字符串的开头开始匹配.<br>D    模式中的美元元字符仅匹配目标字符串的结尾.<br>U    匹配最近的字符串.</p>
<p>e 将匹配项找出来，进行替换<br>e模式也叫逆向引用。主要的功能是将正则表达式括号里的内容取出来，放到替换项里面替换原字符串。<br>使用这个模式匹配符前必须要使用到preg_replace()。<br>preg_replace的功能：使用$正则匹配项，找到$查找字符串变量。然后用$替换项变量进行替换<br>mixed preg_replace ( mixed $正则匹配项 , mixed $替换项 , mixed $查找字符串)</p>
<h1 id="常用正则函数"><a href="#常用正则函数" class="headerlink" title="常用正则函数"></a>常用正则函数</h1><p>函数名    功能<br>preg_filter    执行一个正则表达式搜索和替换<br>preg_grep    返回匹配模式的数组条目<br>preg_match    执行一个正则表达式匹配<br>preg_match_all    执行一个全局正则表达式匹配<br>preg_replace_callback_array    传入数组，执行一个正则表达式搜索和替换使用回调<br>preg_replace_callback    执行一个正则表达式搜索并且使用一个回调进行替换<br>preg_replace    执行一个正则表达式的搜索和替换<br>preg_split    通过一个正则表达式分隔字符串</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达示主要用在以下一些地方：&lt;br&gt;1.匹配邮箱、手机号码、验证码&lt;br&gt;2.替换敏感的关键词。例如：涉及政治和骂人的话&lt;br&gt;3.文章采集。&lt;br&gt;4.早期的表情替换技术,ubb文件编码、markdown编辑器替换等&lt;br&gt;5.以后自己写模板引擎也需要用到正则表达示&lt;
    
    </summary>
    
    
      <category term="php" scheme="http://yoohannah.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://yoohannah.github.io/post/php/php_array.html"/>
    <id>http://yoohannah.github.io/post/php/php_array.html</id>
    <published>2017-04-30T12:03:37.000Z</published>
    <updated>2017-04-30T12:03:21.112Z</updated>
    
    <content type="html"><![CDATA[<p>数组可以存入多个不同类型的数据，是一个复合数据类型</p>
<h1 id="索引数组"><a href="#索引数组" class="headerlink" title="索引数组"></a>索引数组</h1><p>下标全为整型的数组<br>1.索引数组若不强制声明他的下标，他的下标是从0开始的。<br>2.如果指定过下标他的下标就为我指定的值。下标重复，后面的值会将前面的值覆盖，下标可以不按顺序指定<br>3.若某个值，强制指定了下标（下标为10）。在它后面加上的值，不指定下标的话。他们的下标增长规律为最大值+1。</p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>1.向索引数组中增加元素用: 数组变量名[]、数组变量名[键值]这两种方式来增加元素，每次增加的值都在数组最后一个位置<br>2.键值的增长规则与之前的规则一样。都是最大值加1的原则。</p>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p> 1.使用unset删除变量的方式来删除数组里面的值。<br> 2.删除了中间的值，并不会让后面的下标向前自动移动。而是原来的值为多少就为多少<br> 3.删除掉其中的某个值，新加入的值不会替换掉原来的位置，下标依然遵循最大值加1的原则。</p>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>用变量名[键] = 新值。就把数组中的值定的值修改了</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>1.用变量名后面接中括号的方式声明数组。数组名[] = ‘xxx’;<br>2.数组名 = [‘aaaa’,’bbbb’,’ccccc’]<br>3.数组名 = array(‘aa’,’bb’,’cc’)</p>
<h1 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h1><p>下标可以为字符串的数组<br>1.声明关联数组是 键名 =&gt; 值<br>2.在关联数组可以有索引数组的元素<br>3.关联数组中的索引数组的元素后再声明了无下标的元素，依然是最大值+1原则<br>增删改声明同索引数组</p>
<h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>数组里面元素为数组，有几层称为几维数组，元素的访问只要一层一层下标挨着写下去即可<br>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$area = array(</div><div class="line">       &apos;china&apos; =&gt; array(</div><div class="line">           &apos;上海&apos;,</div><div class="line">           &apos;湖北&apos;,</div><div class="line">           &apos;天津&apos;,</div><div class="line">           &apos;北京&apos; =&gt; array(</div><div class="line">               &apos;hd&apos; =&gt; &apos;海淀&apos;,</div><div class="line">               &apos;朝阳&apos;,</div><div class="line">               &apos;房山&apos;,</div><div class="line">               &apos;cp&apos; =&gt; &apos;昌平&apos;,</div><div class="line">           ),//注意逗号</div><div class="line">           &apos;广东&apos; =&gt; array(</div><div class="line">               &apos;深圳&apos;,</div><div class="line">               &apos;广州&apos;,</div><div class="line">               &apos;佛山&apos;,</div><div class="line">               &apos;dg&apos; =&gt; &apos;东莞&apos;,</div><div class="line"></div><div class="line">           )</div><div class="line">       )</div><div class="line">       )</div><div class="line">访问 昌平，即$area[china][&apos;北京&apos;][&apos;cp&apos;]</div><div class="line">`</div></pre></td></tr></table></figure></p>
<h1 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h1><h2 id="统计数组长度-count"><a href="#统计数组长度-count" class="headerlink" title="统计数组长度 count"></a>统计数组长度 count</h2><p>int count ( mixed $变量)<br>$a[0] = 1;<br>$a[1] = 3;<br>$a[2] = 5;<br>$result = count($a);//3<br>如果是一个多维数组，这个函数只会统计当前的这一个维度的数组元素个数</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>1.下标连续的索引数组<br>for($i = 0 ; $i &lt; count($num) ; $i++){<br>   echo $num[$i].’<br>‘;<br>}<br>2.下标不连续索引数组、关联数组<br>foreach( 要循环的数组变量 as [键变量 =&gt;] 值变量){<br>//循环的结构体<br>}<br>键变量可写可不写，不写每次只读取键值对的值到值变量<br>例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$data = [</div><div class="line">       &apos;nh&apos; =&gt; &apos;你好&apos;,</div><div class="line">       &apos;xx&apos; =&gt; &apos;谢谢&apos;,</div><div class="line">   ];</div><div class="line">foreach($data  as $key =&gt; $value)&#123;</div><div class="line">       echo $key . &apos;-------&apos; . $value . &apos;&lt;br /&gt;&apos;;</div><div class="line">&#125;</div><div class="line">foreach($data  as  $value)&#123;</div><div class="line">      echo  $value . &apos;&lt;br /&gt;&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.多维数组<br>  多层循环套嵌即可</p>
<ol>
<li>list each函数<br>list:从左到右，将索引数组下标为0的元素对应变量1，下标1的元素对应变量2，依此类推。<br>list ( mixed $变量1 [, mixed $变量n ] )<br>list($one , $two , $three) = array(‘张三’ ,’李四’ ,’王五’);<br>如果list变量找到对应下标值，变量就没有对应值，<br>数组长度大于list变量数，多余的数组元素会被直接舍弃，没有变量对应</li>
</ol>
<p>each：传入一个数组。它会将其中的一个元素拆为一个新数组，元素的下标做新数组下标为0和下标为’key’的值，元素的值做新数组下标为1和下标为’value’的元素的值。每次执行这样操作一个元素。执行一次先后移动一次，同样的方式操作下一个数组元素。执行到最后，返回false。<br>array each ( array &amp;$array )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//定义一个变量叫$temp</div><div class="line">$temp=[</div><div class="line">   &apos;11&apos;=&gt;&apos;dddddd&apos;,</div><div class="line">   &apos;111&apos;=&gt;&apos;gggggg&apos;,</div><div class="line">   ];</div><div class="line"></div><div class="line">//第一次each</div><div class="line">$data = each($temp);//对&apos;11&apos;=&gt;&apos;dddddd&apos;,拆分，返回数组给$data</div><div class="line">$data = each($temp);//对&apos;111&apos;=&gt;&apos;gggggg&apos;,拆分，返回数组给$data</div><div class="line">$data = each($temp);//此时，后面已没有可操作的元素了，返回false</div></pre></td></tr></table></figure></p>
<p>结合list和each访问数组元素<br>while(list($key,$value) = each($temp)){<br>   echo $key. ‘—–’ .$value .’<br>‘;<br>}<br>$key回去寻找下标0的元素值，$value回去寻找下标1的元素值</p>
<h2 id="常用操作函数"><a href="#常用操作函数" class="headerlink" title="常用操作函数"></a>常用操作函数</h2><p>函数名(数组名)<br>函数    功能<br>array_shift    弹出数组中的第一个元素，后面元素往前移动，返回一个元素值<br>array_unshift    向指数组的开始处压入一个或多个元素，返回的是总个数<br>array_push    向指数组末尾处压入一个或多个元素，返回的是总个数<br>array_pop    弹出数组末尾的最后一个元素<br>current    读出指针当前位置的值<br>key    读出指针当前位置的键<br>next    指针向下移<br>prev    向上移<br>reset    指针到开始处<br>end    指针到结束处</p>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>函数名    功能<br>array_combine()    生成一个数组,用一个数组的值作为键名,另一个数组值作为值<br>range()    创建并返回一个包含指定范围的元素的数组。<br>compact()    创建一个由参数所带变量组成的数组<br>array_fill()    用给定的值生成数组<br>array_chunk()    把一个数组分割为新的数组块<br>array_merge()    把两个或多个数组合并为一个数组<br>array_slice()    在数组中根据条件取出一段值，并返回<br>array_diff()    返回两个数组的差集数组<br>array_search()    在数组中搜索给定的值，如果成功则返回相应的键名<br>array_splice()    把数组中的一部分去掉并用其它值取代<br>array_sum()    计算数组中所有值的和<br>in_array()    检查数组中是否存在某个值<br>array_key_exists()    检查给定的键名或索引是否存在于数组中<br>shuffle()    将数组打乱,保留键值<br>count()    计算数组中的单元数目或对象中的属性个数<br>array_flip()    返回一个键值反转后的数组<br>array_keys()    返回数组所有的键,组成一个数组<br>array_values()    返回数组中所有值，组成一个数组<br>array_reverse()    返回一个元素顺序相反的数组<br>array_count_values()    统计数组中所有的值出现的次数<br>array_rand()    从数组中随机抽取一个或多个元素,注意是键名<br>array_unique()    删除重复值，返回剩余数组<br>sort()    按升序对给定数组的值排序,不保留键名<br>rsort()    对数组逆向排序,不保留键名<br>asort()    对数组排序,保持索引关系<br>arsort()    对数组逆向排序,保持索引关系<br>ksort()    按键名对数组排序<br>krsort()    将数组按照键逆向排序<br>natsort()    用自然顺序算法对数组中的元素排序<br>natcasesort()    自然排序,不区分大小写<br>array_filter()    去掉数组中的空元素或者预定元素<br>extract    将键变为变量名，将值变为变量值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组可以存入多个不同类型的数据，是一个复合数据类型&lt;/p&gt;
&lt;h1 id=&quot;索引数组&quot;&gt;&lt;a href=&quot;#索引数组&quot; class=&quot;headerlink&quot; title=&quot;索引数组&quot;&gt;&lt;/a&gt;索引数组&lt;/h1&gt;&lt;p&gt;下标全为整型的数组&lt;br&gt;1.索引数组若不强制声明他的下标
    
    </summary>
    
    
      <category term="php" scheme="http://yoohannah.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>基础知识</title>
    <link href="http://yoohannah.github.io/post/php/php_basic.html"/>
    <id>http://yoohannah.github.io/post/php/php_basic.html</id>
    <published>2017-04-30T12:02:37.000Z</published>
    <updated>2017-05-02T14:25:02.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量-数据类型"><a href="#变量-数据类型" class="headerlink" title="变量/数据类型"></a>变量/数据类型</h1><p>1.必须要以$开始。如变量x必须要写成$x<br>2.变量的首字母不能以数字开始<br>3.变量的名字区分大小写<br>4.变量不要用特殊符号、中文，_不算特殊符号<br>5.变量命名要有意义（别写xxx，aaa，ccc这种 变量名）</p>
<p>echo 显示命令<br>/<em><br>多行注释 这里是注释区域代码
 </em>/<br> //   表示单行注释</p>
<p>1.整型<br> 8进制声明： 以0开始，后面跟0-7的整数 $bajingzhi =  033145;<br> 16进制声明： 以0x开始，后面跟0-f的，0x的abcdef不区分大小写。$shiliu = 0x6ff;<br>2.布尔类型<br> true/false<br> 布尔值=false  ．<br> 整数值=0<br> 浮点数=0.0<br> 空字符串<br> 空数组<br>3.字符串<br> 用单引号声明 $zhifu = ‘曾经有操蛋的爱情摆在我面前’;<br> 用双引号声明 $str = “如果非要在滚犊子前面加上一个时间的话我愿意是马上。”;<br> 字界符声明<br>  1).在变量后面的等号写三个小于号（&lt;&lt;&lt;）。<br>  2).然后在&lt;&lt;&lt;后面写上字符（建议英文大写字符）。如下例中的：ABC<br>  3).然后换行写上任意想写的字符<br>  4).写完后，顶行。在行最开始处，再写上&lt;&lt;&lt;后面的字符和分号。如下例中的：ABC;<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$dingjie = &lt;&lt;&lt;ABC</div><div class="line">  如果</div><div class="line">       非要在这个滚犊子</div><div class="line">   前</div><div class="line">       面&lt;br /&gt;</div><div class="line">      加上一段</div><div class="line">   &lt;i&gt;距离的话&lt;/i&gt;</div><div class="line">   我想说：&lt;h1&gt;思想有多远，你就跟我滚多远&lt;/h1&gt;</div><div class="line">ABC;</div></pre></td></tr></table></figure></p>
<p>  换行在显示时显示空格，<br>表示显示换行</p>
<pre><code>1.双引号解析变量，但是单引号不解析变量。

2.在双引号里面插入变量，变量后面如果有英文或中文字符，它会把这个字符和变量拼接起来，视为一整个变量。要在变          量后面接上特殊字符，要用空格等分开。

3.如果在双引号里面插变量的时候，后面不想有空格，可以拿大括号将变量包起来。

4.双引号解析转义字符，单引号不解析转义字符。但，单引号能解析\&apos; 和\

5.单引号效率高于双引号，尽可能使用单引号

6.双号和单引号可以互插！！！双引号当中插入单引号，单引号当中插入变量，这个变量会被解析。
$legend = &apos;猛虎&apos;;
$NoAlike = &quot;心有&apos;$legend&apos;,细嗅蔷薇&quot;;
echo $NoAlike;//心有&apos;猛虎&apos;,细嗅蔷薇

7.神奇的字符串拼接胶水——（.）点，用来拼接字符串。
&lt;?php
  $php = &apos;PHP中文网&apos;;
  //中间加了空格哟
  $str = $php . &apos;aaaa&apos;;
  echo $str;//PHP中文网aaaa
  ?&gt;

8.定界符声明字符串可以解析变量，加入单双引号同样会以单双引号形式显示出来，引号中间是变量的话，同样会被解析出来。
</code></pre><p>4.浮点型<br>  小数<br>  var_dump() 是一个函数。向括号()中间插入变量。这个函数，会打印出来数据类型，还会对应显示变量的长度和值。<br>  例<br>  $f1 = 1;<br>  var_dump($f1);//int(1)<br>  $f1 = 1.2;<br>  var_dump($f1);//float(1.2)<br>  两个浮点型数据不能作比较，因为实际比较值不确定<br>5.null<br>  主要有以下三空情况会产生空（null）类型：</p>
<pre><code>1.通过变量赋值明确指定为变量的值为NULL

2.一个变量没有给任何值

3.使用函数unset()将变量销毁掉
empty()可以向括号中间传入一个变量。这个变量的值如果为false或者为null的话，返回true。
isset()可以向括号中间传入一个或者多个变量，变量与变量间用逗号分开。只要有有一个变量为null，则返回false。否则，则返回true。
  $jia = false;
  $result = isset($jia);
  var_dump($result);//bool(true)
unset()这个函数的功能是毁掉变量。unset(变量)括号中间插入想要毁掉的变量名，这个变量就会被毁掉。
  $iphone = &apos;手机&apos;;
  unset($iphone);
  var_dump($iphone);//null
</code></pre><p>6.数组<br>  一个或者多个值<br>  一个或者多个值用逗号分开<br>  $shu = array(1,2,3);<br>7.资源类型<br>  资源就提操作我们可见和不可见的文件、网络和数据</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>gettype(传入一个变量) 返回变量的类型。$type = gettype($float);<br>数据类型判断<br>is_int 是否为整型<br>is_bool 是否为布尔<br>is_float 是否是浮点<br>is_string 是否是字符串<br>is_array 是否是数组<br>is_object 是否是对象<br>is_null 是否为空<br>is_resource 是否为资源<br>is_scalar 是否为标量<br>is_numeric 是否为数值类型<br>is_callable 是否为函数</p>
<p>布尔值判断时的自动类型转换：<br>1，整型的0为假，其他整型值全为真<br>2, 浮点的0.0，布尔值的假。小数点后只要有一个非零的数值即为真。<br>3，空字符串为假，只要里面有一个空格都算真。<br>4，字符串的0，也将其看作是假。其他的都为真<br>5，空数组也将其视为假，只要里面有一个值，就为真。<br>6，空也为假<br>7, 未声明成功的资源也为假</p>
<p>运算自动类型转换:<br>布尔型：整型、浮点型<br>字符串：整型、浮点型</p>
<p>强制类型转换有三种方式：<br>    1.用后面的三个函数可以完成类型转换，intval()、floatval()、strval()<br>    2.变量前加上()里面写上类型，将它转换后赋值给其他变量<br>    3.settype(变量，类型) 直接改变量本身</p>
<pre><code>1.空转为整型会为整型的0
2.空转为浮点会为浮点的0
3.空转为字符串会为空字符串‘’
4.浮点的123.0转为字符串会为字符串123
5.浮点的123.2转为字符串会为字符串的123.2
6.浮点即使小数点再大，它都会被干掉，会舍掉小数点后面的值
7.如果字符串转为整型的时候，如果数值在前面，会将前面的数值拿出来做为整型的转换值。
8.settype(变量,&apos;null&apos;); 等价于 unset()一个变量
9.$目标变量 = (类型)$操作变量 只会改变目标变量的类型，不会改变原变量的类型，Settype是改变原值
</code></pre><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>define(常量名，常量值) 定义常量<br>注：<br>    1.常量值只能为上一章中我们讲到的标量。<br>    2.常量名可以小写，但是通常大写<br>    3.常量名可以不加引号，但是通常加上引号。<br>    4.在字符串中调用常量的时候，必须在引号外面<br>    5.常量名建议只用字母和下划线</p>
<h2 id="内置常量"><a href="#内置常量" class="headerlink" title="内置常量"></a>内置常量</h2><p>LINE  当前所在的行<br>FILE  当前文件在服务器的路径<br>FUNCTIOIN 当前函数名<br>CLASS 当前类名<br>METHOD  当前成员方法名<br>PHP_OS  PHP运行的操作系统<br>PHP_VERSION 当前PHP的版本<br>TRAIT Trait 的名字,php5.4新加<br>DIR 文件所在的目录<br>NAMESPACE 当前命名空间的名称（区分大小写）</p>
<h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p>已声明的变量前，再加上变量符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//定义了一个变量叫作 $shu 将$shu这个变量的值设为字符串的biao</div><div class="line">$shu = &apos;biao&apos;;</div><div class="line">//定义了一个【变量】$biao。将他的值设置为鼠标</div><div class="line">$biao = &apos;鼠标&apos;;</div><div class="line">//$$shu 就是可变变量：在已声明的变量$shu前又加上了一个变量符</div><div class="line">echo $$shu;//&apos;鼠标&apos;</div></pre></td></tr></table></figure></p>
<p>即$shu 是biao,$biao是’鼠标’<br>还可以加多个$即一层层替换过去就行</p>
<h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><p>$_GET 将得到get方法传值的数据 参数会显示在URL(网址栏)上。 $u = $_GET[‘username’];<br>$_POST 将得到post方法传值的数据 通过浏览器的请求头文件传递的数据，不会显示在url上。 $u = $_POST[‘username’];<br>$_REQUEST即可以接收get传值也可以接收post传值。 $u = $_REQUEST[‘username’];<br>$_COOKIE  得到会话控制中cookie传值<br>$_SESSION 得到会话控制中session的值<br>$_FILES 得到文件上传的结果<br>以上这些变量全是超全局的。在任何环境都能用</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>$_SERVER<br>$_SERVER[“REQUEST_METHOD”]  请求当前PHP页面的方法<br>$_SERVER[“REQUEST_URI”] 请求的URI<br>$_SERVER[“SERVER_SOFTWARE”] 用的是哪一种服务器<br>$_SERVER[“REMOTE_ADDR”] 客户的IP地址<br>$_SERVER[“SERVER_ADDR”] 当前服务器的IP地址<br>$_SERVER[“SCRIPT_FILENAME”] 主前请求文件的路径<br>$_SERVER[“HTTP_USER_AGENT”] 当前访问这个网址的电脑和浏览器的情况<br>$_SERVER[“HTTP_REFERER”]  上级来源（用户从哪个地址进入当前网页的）<br>$_SERVER[“REQUEST_TIME”]  当前的时间<br>URI 和URL都是网址，但是URL带有了主机地址部份，而URI不带主机地址部份，例如：<br><a href="http://www.php.cn/abc.php?username=php" target="_blank" rel="external">http://www.php.cn/abc.php?username=php</a> 是一个URL（统一资源定位符），<br>而URI是不带主机和(<a href="http://)协议的部份：abc.php?username=php" target="_blank" rel="external">http://)协议的部份：abc.php?username=php</a></p>
<h2 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h2><p>情况1：<br>$fo = 5;<br>//$fo的值为5，将5赋值<br>$bar = $fo;<br>//$bar的值原来为5，现在将值改为6<br>$bar = 6;<br>//$bar的结果为6<br>echo $bar.’<br>‘;<br>//$fo的结果为5<br>echo $fo.’<br>‘;<br>情况2：<br>$fo = 5;<br>//注意，加上了一个&amp;符哟<br>$bar = &amp;$fo;<br>$bar = 6;<br>//$bar的结果为6<br>echo $bar.’<br>‘;<br>//$fo的结果为6<br>echo $fo.’<br>‘;</p>
<h2 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h2><ul>
<li>加号  $x + $y</li>
</ul>
<ul>
<li>减号  $x - $y</li>
</ul>
<ul>
<li>乘号,乘以 $x * $y<br>/ 除号,除以 $x / $y<br>% 取余也叫取模、求模 $x % $y<br>优先级：先乘除，后加减<br>改变优先级，那就用()，将想要优先的值给括起来</li>
</ul>
<h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><p>符号  举例       等价式<br>+＝  $x +＝ $y  $x ＝ $x + $y<br>-＝  $x -＝ $y  $x ＝ $x - $y<br><em>＝  $x </em>＝ $y  $x ＝ $x * $y<br>/＝  $x /＝ $y  $x ＝ $x / $y<br>%＝  $x %＝ $y  $x ＝ $x % $y<br>.＝  $x .＝ $y  $x ＝ $x . $y</p>
<p>例.<br>$x = 5;<br>$y = 8;<br>$x .= $y;<br>echo $x; //58</p>
<h2 id="自加自减"><a href="#自加自减" class="headerlink" title="自加自减"></a>自加自减</h2><p>$x++  先赋值后加<br>$x–  先赋值后减<br>++$x  先加后赋值<br>–$x  先减后赋值</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>大于  &gt;<br>小于  &lt;<br>大于等于  &gt;=<br>小于等于  &lt;=<br>不等于  !=<br>等于  ==（赋值是=号，所以＝＝规定为等于）5==‘5’ =》true<br>全等（判断类型等于）  ===<br>全不等（判断类型不等于）  !==</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>x and $y  逻辑与（并且关系） $x 和$y 为真则返回真<br>$x &amp;&amp; $y  同上  同上<br>$x or $y  逻辑或 $x,$y均为false时为假，其他情况全为真<br>$a||$b  同上  同上<br>!$x 逻辑非 取反，即true变为false，false变为true<br>$x xor $y 逻辑异或  相同取false，相异为true<br>短路<br>逻辑与：如果前面第一个条件为false了，后面就可以不用执行了。<br>逻辑或：前面第一个条件为true了，后面就不用执行了<br>但是注意<br>1.<br>$x = false;<br>$y = 2;<br>if($x &amp; $y++){<br>   echo ‘真’;<br>}else{<br>   echo ‘假’;<br>}<br>echo $y; //假3<br>2.<br>$x = true;<br>$y = 2;<br>if($x | $y++){<br>   echo ‘真’;<br>}else{<br>   echo ‘假’;<br>}<br>echo $y; //真3</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>$a &amp; $b And（按位与）  将把 $a 和 $b 中都为 1 的位设为 1。<br>$a | $b Or（按位或） 将把 $a 和 $b 中任何一个为 1 的位设为 1。<br>$a ^ $b Xor（按位异或） 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。<br>~ $a  Not（按位取反） 将 $a 中为 0 的位设为 1，反之亦然。<br>$a &lt;&lt; $b  左移  将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。<br>$a &gt;&gt; $b  右移  将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。</p>
<h2 id="三元运算符和其他运算符"><a href="#三元运算符和其他运算符" class="headerlink" title="三元运算符和其他运算符"></a>三元运算符和其他运算符</h2><p>$x? 真代码段:假代码段 判断是否为真假 ? 真情况 : 假情况;<br>``（反引号） 反引号中间插代命令，执行系统命令，等价于shell_exec函数<br>@ 单行抑制错误，把这一行的错误不让它显示出来了，效率低不建议使用<br>=&gt;  数组下标访问符<br>-&gt;  对象访问符<br>instanceof  判断某个对象是否来自某个类，如果是的返回true，如果不是返回false</p>
<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if、else-语法"><a href="#if、else-语法" class="headerlink" title="if、else 语法"></a>if、else 语法</h2><p>1.<br>&lt;?php<br>if(布尔条件)<br>   布尔值为真(true)时执行，只能写一行代码;<br>?&gt;<br>2.<br>&lt;?php<br>if(布尔条件)<br>   布尔值为真(true)时执行，只能写一行代码;<br>else<br>   布尔值为假(false)时执行，只能写一行代码;<br>?&gt;<br>&lt;?php<br>if(布尔条件){<br>   布尔值为真(true)时执行，多行代码;<br>   }<br>else{<br>  布尔值为假(false)时执行，多行代码;<br>}<br>?&gt;<br>3.<br>&lt;?php<br>if（判断语句1）{<br>    执行语句体1<br>}elseif(判断语句2){<br>    执行语句体2<br>}else if(判断语句n){<br>        执行语句体n<br>}else{<br>        最后的else语句可选<br>}<br>//后续代码<br>?&gt;<br>4.<br>&lt;?php<br>if(判断1){<br>    if(判断2){<br>            代码段 1<br>    }else{<br>            代码段2<br>        }<br>}else{<br>    if(判断3){<br>            代码段3<br>        }else{<br>            代码段4<br>        }<br>}<br>?&gt;</p>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>&lt;?php<br>switch(变量){    //字符串，整型<br>       case 具体值:<br>               执行代码;<br>               break;<br>       case 具体值2：<br>               执行代码2;<br>               break;<br>       case 具体值3：<br>               执行代码3;<br>               break;<br>       default:<br>}<br>?&gt;</p>
<h2 id="循环结构和相关关键字语句"><a href="#循环结构和相关关键字语句" class="headerlink" title="循环结构和相关关键字语句"></a>循环结构和相关关键字语句</h2><p>1.<br>while(条件){<br>  代码<br>}<br>2.<br>do {<br>   //代码块<br>} while (判断);<br>3.<br>for (表达示1; 表达示2; 表达示3){<br>        需要执行的代码段<br>}<br>4.<br>exit  从当前处停止后续执行<br>break 跳出循环或者跳出结构体执行后续代码<br>continue  跳出此次循环，下次循环继续<br>5.<br>goto 操作符可以用来跳转到程序中的另一位置。<br>该目标位置可以用目标名称加上冒号来标记，而跳转指令是 goto 之后接上目标位置的标记。<br>PHP 中的 goto 有一定限制，目标位置只能位于同一个文件和作用域，也就是说无法跳出一个函数或类方法，也无法跳入到另一个函数。也无法跳入到任何循环或者 switch 结构中。可以跳出循环或者 switch，通常的用法是用 goto 代替多层的 break。<br>例<br>&lt;?php<br>goto wan;<br>echo ‘天王盖地虎’;<br>wan:<br>echo ‘小鸡炖蘑菇’;<br>?&gt;<br>仅输出 ‘小鸡炖蘑菇’</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>function 函数名([参数名1[=值1], 参数名2[=值2], 参数名n[=值n]])<br>{<br>       函数中的功能体<br>    [return 返回值]<br>}<br>1.函数以function开始<br>2.function后面接空格，空格后接函数名<br>3.函数名与变量命名规则基本一样，函数名只能是字母，数字，下划线的组合，并且之间不能包含空格，数字不能放在变量名首位，但是不同的是：函数名不区分大小写<br>4.所谓参数其实就是变量<br>5.函数名后接括号，括号内跟参数，参数全都有[]（中括号）括起来了，代表参数可填可不填<br>6.如果有参数的话，参数后可以接（＝）等号，等号接默认值。参数值也是用[]（中括号）括起来的，代表选填<br>7.函数后的参数变量，主要功能是把函数体外的变量值，传入函数体内来使用，函数体的变量和函数体外的变量通常是两个不         同的变量。<br>8.函数中的具体功能（功能体）用大括号括起来，代表这是一个函数的功能区间<br>9.函数可以有返回值也可以没有返回值，用[]（中括号）括起来的，代表选填。<br>10.return后接空格，空格后接返回值，若有return,return后的代码均不执行。<br>11.函数的执行没有顺序关系，可以在定义处之前的位置调用<br>12.函数不能被定义两次，即函数不能被重载</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数，就是在处理一个功能的时候，调用这个函数的时候，还可以传入一个函数配合、协助进行处理<br>例<br>function woziji($one,$two,$func){<br> //我规定：检查$func是否是函数，如果不是函数停止执行本段代码，返回false<br> if(!is_callable($func)){<br> return false;<br> }<br> //我把$one、$two相加，再把$one和$two传入$func这个函数中处理一次<br> //$func是一个变量函数，参见变量函数这一章<br> echo $one + $two + $func($one,$two);<br>}<br>//我们定义几个函数试试<br>function plusx2( $foo , $bar){<br> $result = ($foo+$bar)*2;<br> return $result;<br>}<br>function jian( $x , $y ){<br> $result = $x - $y;</p>
<p> return $result;<br>}<br>//调用一下函数，woziji，向里面传入参数试试<br>echo woziji(20,10,’plusx2’);<br>//将plusx2改成jian试试结果<br>echo woziji(20,10,’jian’);<br>?&gt;</p>
<h3 id="变量函数"><a href="#变量函数" class="headerlink" title="变量函数"></a>变量函数</h3><p>联系可变变量定义<br>例<br>&lt;?php<br>function demo(){<br>    echo ‘天王盖地虎’;<br>}<br>function test(){<br>    echo ‘小鸡炖蘑菇’;<br>}<br>$fu = ‘demo’;<br>//把$fu变为了demo,把demo后加上了一个括号，就执行函数了<br>$fu();<br>//把$fu的值改为test字符串再试试？<br>?&gt;</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>1.变量函数式的匿名函数<br>&lt;?php<br>$greet = function($name)<br>{<br> echo $name.’，你好’;<br>};<br>$greet(‘明天’);<br>$greet(‘PHP中文网’);<br>?&gt;<br>2.回调式的匿名函数<br>&lt;?php<br>function woziji($one,$two,$func){<br> //我规定：检查$func是否是函数，如果不是函数停止执行本段代码，返回false<br> if(!is_callable($func)){<br>         return false;<br> }</p>
<p> //我把$one、$two相加，再把$one和$two传入$func这个函数中处理一次<br> //$func是一个变量函数，参见变量函数这一章<br> echo $one + $two + $func($one,$two);<br>}<br>woziji(20,30,function( $foo , $bar){<br>   $result = ($foo+$bar)*2;<br>   return $result;<br>}<br>);<br>?&gt;</p>
<h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><p> 1.内部函数名，不能是已存在的函数名<br> 2.假设在函数a里面定义了一个内部函数，不能定用两次函数a。<br>例<br>&lt;?php<br>function foo()<br>{<br>   echo ‘我是函数foo哟，调一下我才会执行定义函数bar的过程<br>‘;<br>   function bar()<br>   {<br>        echo ‘在foo函数内部有个函数叫bar函数<br>‘;<br>   }<br>}<br>//现在还不能调用bar()函数，因为它还不存在<br>// bar();<br>foo();<br>//现在可以调用bar()函数了，因为foo()函数的执行使得bar()函数变为已定义的函数<br>bar();<br>//再调一次foo()会报错<br>foo();<br>?&gt;</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>1.通过$GLOBLAS来读取外部变量<br>&lt;?php<br>$one = 10;<br>function demo(){<br>   $two = 100;<br>   $result = $two + $GLOBALS[‘one’];<br>   return $result;<br>}<br>//你会发现结果变成了110<br>echo demo();<br>?&gt;</p>
<p>2.通过$GLOBLAS，在函数内修改外部变量<br>$hongniu = ‘我是一个兵，来自老百姓’;<br>function test(){<br>   echo ‘执行了函数test哟<br>‘;<br>   //调用test()函数，将通过$GLOBALS[‘hongniu’],把$hongniu的值改变掉<br>   $GLOBALS[‘hongniu’] = ‘帮助别人很快乐’;<br>}<br>test();<br>echo $hongniu;//帮助别人很快乐</p>
<p>3.通过$GLOBLAS，在函数内创建全局变量<br>function hello(){<br>   $GLOBALS[‘que’] = ‘提神喝茶更好哟’;<br>   echo ‘你调了一下函数hello<br>‘;<br>}<br>hello();<br>echo $que;</p>
<h3 id="参数引用"><a href="#参数引用" class="headerlink" title="参数引用"></a>参数引用</h3><p>同比变量引用，将形参和实参指向到同一个位置。如果形参在函数体内发生变化，那么实参的值也发生变化</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>1.代码是从上到下执行的，所有代码没有exit等停止符，函数必须执行完。<br>2.如果函数从函数A跳至函数B后，必须把函数B执行完成再执行函数A余下的代码。<br>3.递归函数必须要能执行完有结束条件，不然函数就会限入死循环。函数会永远的自我执行下去。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>声明一个静态变量，第二次调用函数的时候，静态变量不会再初始化变量，会在原值的基础上读取执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"><span class="comment">//--------------如何理解static静态变量-----------</span></div><div class="line"></div><div class="line"><span class="comment">/** 普通局部变量 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">local</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> $loc = <span class="number">0</span>; <span class="comment">//这样，如果直接不给初值0是错误的。</span></div><div class="line"> ++$loc;</div><div class="line"> echo $loc . <span class="string">'&lt;br&gt;'</span>;</div><div class="line">&#125;</div><div class="line">local(); <span class="comment">//1</span></div><div class="line">local(); <span class="comment">//1</span></div><div class="line">local(); <span class="comment">//1</span></div><div class="line">echo <span class="string">'===================================&lt;br/&gt;'</span>;</div><div class="line"></div><div class="line"><span class="comment">/** static静态局部变量 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">static_local</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">static</span> $local = <span class="number">0</span> ; <span class="comment">//此处可以不赋0值</span></div><div class="line"> $local++;</div><div class="line"> echo $local . <span class="string">'&lt;br&gt;'</span>;</div><div class="line">&#125;</div><div class="line">static_local(); <span class="comment">//1</span></div><div class="line">static_local(); <span class="comment">//2</span></div><div class="line">static_local(); <span class="comment">//3</span></div><div class="line"><span class="comment">//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。</span></div><div class="line">echo <span class="string">'=======================================&lt;br&gt;'</span>;</div><div class="line"></div><div class="line"><span class="comment">/** static静态全局变量(实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量) */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">static_global</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> global $glo; <span class="comment">//此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，但是不能想当然的写上"static"加以修饰，那样是错误的.</span></div><div class="line"> $glo++;</div><div class="line"> echo $glo . <span class="string">'&lt;br&gt;'</span>;</div><div class="line">&#125;</div><div class="line">static_global(); <span class="comment">//1</span></div><div class="line">static_global(); <span class="comment">//2</span></div><div class="line">static_global(); <span class="comment">//3</span></div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<h3 id="系统内置函数"><a href="#系统内置函数" class="headerlink" title="系统内置函数"></a>系统内置函数</h3><p>PHP手册中函数<br>使用函数的重点是三块：<br>  1.了解函数的功能，特别是常用函数的功能<br>  2.了解函数的参数<br>  3.了解函数的返回值<br>函数的基本用法的全部注意事项：<br>  1.直接返回布尔型，如bool copy ()<br>  2.带有MIXED参数的函数如何调用。Mixed表示任何类型的数据。如Array_unshift()<br>  3.参数中带有&amp;符的参数，一定要传一个变量做为参数。函数里面改变了他的值。<br>  4.带有[]的参数，表示可选项。<br>  5.带有…的参数，表示可以传任意多个参数。<br>  6.带有callback的参数，表示回调函数。需要传一个函数进来。Array_map()<br>  7.函数支持的版本你要了解</p>
<h3 id="包含函数"><a href="#包含函数" class="headerlink" title="包含函数"></a>包含函数</h3><p>可以引入其他文件的函数<br>函数    包含失败      特点<br>Inlcude 返回一条警告  文件继续向下执行。通常用于动态包含<br>Require 一个致命的错  代码就不会继续向下执行。通常包含极为重要的文件，整个代码甭想执行<br>Include_once  返回一条警告  除了原有include的功能以外，它还会做once检测，如果文件曾经已经被被包含过，不再包含<br>Require_once  一个致命的错  除了原有的Require功能一外，会做一次once检测，防止文件反复被包含</p>
<h3 id="数学常用函数"><a href="#数学常用函数" class="headerlink" title="数学常用函数"></a>数学常用函数</h3><p>函数名 描述  实例  输入  输出<br>abs() 求绝对值  $abs = abs(-4.2); //4.2 数字  绝对值数字<br>ceil()  进一法取整 echo ceil(9.999); // 10 浮点数 进一取整<br>floor() 舍去法取整 echo floor(9.999); // 9 浮点数 直接舍去小数部分<br>fmod()  浮点数取余 “$x = 5.7;$y = 1.3;$r = fmod($x, $y);// $r equals 0.5, because 4 *  1.3 + 0.5 = 5.7    “  两个浮点数,x&gt;y 浮点余数<br>pow() 返回数的n次方 echo pow(-1, 20); // 1  基础数 n次方 乘方值<br>round() 浮点数四舍五入 echo round(1.95583, 2);// 1.96  一个数值  保留小数点后多少位,默认为0 舍入后的结果<br>sqrt()  求平方根  echo sqrt(9); //3 被开方的数 平方根<br>max() 求最大值  “echo max(1, 3, 5, 6, 7);  // 7 echo max(array(2, 4, 5)); // 5” 多个数字或数组 返回其中的最大值<br>min() 求最小值  min 多个数字或数组 返回其中的最小值<br>mt_rand() 更好的随机数  echo mt_rand(0,9);//n 最小/最大,随机数 随机返回范围内的值<br>rand()  随机数 echo rand() 最小/最大,随机数 随机返回范围内的值<br>pi()  获取圆周率值  echo pi(); // 3.1415926535898 无 获取圆周率</p>
<h3 id="获取时间信息函数"><a href="#获取时间信息函数" class="headerlink" title="获取时间信息函数"></a>获取时间信息函数</h3><p>UNIX时间戳： 从Unix纪元（1970 年 1月1日零时）开始到一个时间经过的秒数</p>
<p>date_default_timezone_get() 取得一个脚本中所有日期时间函数所使用的默认时区<br>date_default_timezone_set(‘Asia/shanghai’) 设置所有日期时间函数的默认时区<br>例<br>date_default_timezone_set(‘Asia/shanghai’);<br>echo date_default_timezone_get (); //Asia/shanghai</p>
<p>time() 获取当前时间的 Unix 时间戳。</p>
<p>string date ( string $format [, int $tirnestamp] ) 将一个时间进行格式化输出，以方便时间的显示或存储，返回字符串<br>如果$timestamp没有输入值，则默认为当前的时间的时间戳。<br>$format是一个时间输出格式的字符串，需要使用规定的字符构造输出格式。<br>date函数的格式参数表：<br>字符  说明  返回值<br>d 月份中的第几天，有前导零的2 位数字  01 到31<br>D 英文星期几，3个字母  Mon到Sun<br>j 月份中的第几天，没有前导零 1 到31<br>l(字母) 英文星期几 Sunday到 Saturday<br>N 1格式数字表示的星期  1（表示星期一）到7（表示星期天)<br>S 每月天数后面的英文后缀，2个字符  st，nd，rd或者th。可以和jg一起用<br>w 星期中的第几天，数字表示  0（表示星期天）到 6（表示星期六）<br>z 一年中的第几天 0到366<br>W 年份中的第几周，每周从星期一开始  42（当年的第42周）<br>F 月份，完整的文本格式  January 到 December<br>m 数字表示月份，有前导零 01 到 12<br>M 3个字母缩写表示的月份 Jan 到Dec<br>n 数字表示月份，没有前导零  1 到 12<br>t 给定月份所应有的天数  28 到 31<br>L 是否为闰年 如果是闰年为1，否则为o<br>o 格式年份数字  例如2007<br>Y 4 位数字完整表示年份 例如1999或2008<br>y 2 位数字表示的年份  例如99或08<br>a 小写的上午和下午值 am或pm<br>A 大写的上午和下午值 AM或PM<br>g 小时，12小时格式，没有前导零 1到12<br>G 小时，24小时格式，没有前导零 0 到 23<br>i 有前导零的分钟数  00 到 59<br>s 秒数，有前导零 00到59<br>e 时区标识<br>U 从Unix纪元开始至今的秒数  长整型数字</p>
<p>例<br>date(‘Y-m-d H:i:s’);//2017-04-28 14:53:01</p>
<p>array getdate ([ int $timestamp = time()) 用来获取当前系统的时间，或者获得一个时间戳的具体含义<br>函数的返回值是一个根据timestamp得到的包含有时间信息的数组。如果没有参数，则会返回当前的时间。getdate返回的数组，键名包括时间和日期的完整信息<br>键名  说明  返回值<br>secnods 秒 数字0到 59<br>minutes 分钟  数字0到59<br>hours 小时  数字 0到 23<br>mday  月份中第几天  数字 1到 31<br>wday  星期中第几天  数字0（表示星期天）到6（表示星期六）<br>mon 月份  数字 1 到 12<br>year  年 4 位数字表示的完整年份<br>yday  一年中第几天  数字0到365<br>weekday 星期几的英文  Sunday到 Saturday<br>month 月份的英文 January 到 December<br>0 自从Unix纪元开始的秒数 长整型数字</p>
<p>print_r(数组名)可以输出一个数组中所有的键名与值。</p>
<p>bool checkdate(int $month,int $day,int $year) 可以判断一个输出的日期是否有效。返回布尔类型，例如验证用户输入的时间是否正确<br>例 var_dump(checkdate(2, 29, 2011)); //bool(false) 2011年2月没有29日</p>
<p>int mktime (int $hour [, int $minute [, int $second [, int $month [, int $day [. int$year [, int $.is_dstl.l } ] ] 31 )  可以对一个日期和时间获得一个本地化时间戳<br>函数的参数分别表示：时、分、秒、月、日、年、是否为夏令时。在使用这个函数时，需要注意所列的参数要与函数的参数含义相同。</p>
<p>int strtotime ( string $time [, int $now = time() ] )  将英文文本的日期时间描述解析为 Unix 时间戳<br>1.传入一个字符串的时间 2.可选参数为是否传入unix时间戳，如果不传则是当前的unix时间戳。<br>例<br>//now为现在的当前时间<br>echo strtotime(“now”).”<br>“;<br>//2000年9月10日<br>echo strtotime(“10 September 2000”).”<br>“;<br>//当前时间加一天<br>echo strtotime(“+1 day”).”<br>“;<br>//当前时间加一周<br>echo strtotime(“+1 week”).”<br>“;<br>//当前时间加一周2天4小时2秒<br>echo strtotime(“+1 week 2 days 4 hours 2 seconds”).”<br>“;<br>//下一个星期四<br>echo strtotime(“next Thursday”).”<br>“;<br>//上一个星期一<br>echo strtotime(“last Monday”).”<br>“;</p>
<p>mixed microtime ([ bool $get_as_float ] ) 能够返回当前 Unix 时间戳和微秒数可用于执行函数时间检测<br>如果你传入true的话，将会返回一个浮点类型的时间，这样方便参与运算。</p>
<h3 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h3><p>函数名  描述  实例<br>trim()  删除字符串两端的空格或其他预定义字符  “$str = “\r\nHello World!\r\n”; echo trim($str);<br>rtrim() 删除字符串右边的空格或其他预定义字符  “$str = “Hello World!\n\n”; echo rtrim($str);”<br>chop()  rtrim()的别名  同上<br>ltrim() 删除字符串左边的空格或其他预定义字符  “$str = “\r\nHello World!”; echo ltrim($str);”<br>dirname() 回路径中的目录部分（我们把它归在了字符串函数里了） echo dirname(“c:/testweb/home.php”);<br>str_pad() 把字符串填充为指定的长度  $str = “Hello World”; echo str_pad($str,20,”.”);<br>str_repeat()  重复使用指定字符串 echo str_repeat(“.”,13);<br>str_split() 把字符串分割到数组中  print_r(str_split(“Hello”));<br>strrev()  反转字符串 echo strrev(“Hello World!”);<br>wordwrap()  按照指定长度对字符串进行折行处理  “$str = “”An example on a long word is: Supercalifragulistic””; echo wordwrap($str,15);”<br>str_shuffle() 随机地打乱字符串中所有字符 echo str_shuffle(“Hello World”);<br>parse_str() 将字符串解析成变量 “parse_str(“id=23&amp;name=John%20Adams”,$myArray); print_r($myArray);”<br>number_format() 通过千位分组来格式化数字  “echo number_format(“1000000”); echo number_format(“1000000”,2); echo number_format(“1000000”,2,””,””,””.””);”<br>strtolower()  字符串转为小写 echo strtolower(“Hello WORLD!”);<br>strtoupper()  字符串转为大写 echo strtoupper(“Hello WORLD!”);<br>ucfirst() 字符串首字母大写  echo ucfirst(“hello world”);<br>ucwords() 字符串每个单词首字符转为大写  echo ucwords(“hello world”);<br>htmlentities()  把字符转为HTML实体 $str = “”John &amp; ‘Adams’””; echo htmlentities($str, ENT_COMPAT);<br>htmlspecialchars()  预定义字符转html编码<br>nl2br() \n转义为<br>标签  echo nl2br(“One line.\nAnother line.”);<br>strip_tags()  剥去 HTML、XML 以及 PHP 的标签  echo strip_tags(“Hello world!”);<br>addcslashes() 在指定的字符前添加反斜线转义字符串中字符  $str = “”Hello, my name is John Adams.” echo $str; echo addcslashes($str,’m’);”<br>stripcslashes() 删除由addcslashes()添加的反斜线  echo stripcslashes(“Hello, \my na\me is Kai Ji\m.”);<br>addslashes()  指定预定义字符前添加反斜线 $str = “Who’s John Adams?”;echo addslashes($str);<br>stripslashes()  删除由addslashes()添加的转义字符  echo stripslashes(“Who\’s John Adams?”);<br>quotemeta() 在字符串中某些预定义的字符前添加反斜线 $str = “Hello world. (can you hear me?)”; echo quotemeta($str);<br>chr() 从指定的 ASCII 值返回字符  echo chr(052);<br>ord() 返回字符串第一个字符的 ASCII值  echo ord(“hello”);<br>strcasecmp()  不区分大小写比较两字符串  echo strcasecmp(“Hello world!”,”HELLO WORLD!”);<br>strcmp()  区分大小写比较两字符串<br>strncmp() 比较字符串前n个字符,区分大小写<br>strncasecmp() 比较字符串前n个字符,不区分大小写 int strncasecmp ( string $str1 , string $str2 , int $len )<br>strnatcmp() 自然顺序法比较字符串长度,区分大小写  int strnatcmp ( string $str1 , string $str2 )<br>strnatcasecmp() 自然顺序法比较字符串长度,不区分大小写 int strnatcasecmp ( string $str1 , string $str2 )<br>chunk_split() 将字符串分成小块  str chunk_split(str $body[,int $len[,str $end]])<br>strtok()  切开字符串 str strtok(str $str,str $token)<br>explode() 使用一个字符串为标志分割另一个字符串  array explode(str $sep,str $str[,int $limit])<br>implode() 同join,将数组值用预订字符连接成字符串 string implode ( string $glue , array $pieces )<br>substr()  截取字符串 string substr ( string $string , int $start [, int $length ] )<br>str_replace() 字符串替换操作,区分大小写 mix str_replace(mix $search,,mix $replace,mix $subject[,int &amp;$num])<br>str_ireplace()  字符串替换操作,不区分大小写  mix str_ireplace ( mix $search , mix $replace , mix $subject [, int &amp;$count ] )<br>substr_count()  统计一个字符串,在另一个字符串中出现次数  int substr_count ( string $haystack , string $needle [, int $offset = 0 [, int $length ]] )<br>substr_replace()  替换字符串中某串为另一个字符串 mixed substr_replace ( mixed $string , string $replacement , int $start [, int $length ] )<br>similar_text()  返回两字符串相同字符的数量 int similar_text(str $str1,str $str2)<br>strchr()  返回一个字符串在另一个字符串中开始位置到结束的字符串  string strstr ( string $str, string $needle , bool $before_needle )<br>strrchr() 返回一个字符串在另一个字符串中最后一次出现位置开始到末尾的字符串  string strrchr ( string $haystack , mixed $needle )<br>stristr() 返回一个字符串在另一个字符串中开始位置到结束的字符串，不区分大小写 string stristr ( string $haystack , mixed $needle [, bool $before_needle = false ] )<br>strtr() 转换字符串中的某些字符 string strtr ( string $str , string $from , string $to )<br>strpos()  寻找字符串中某字符最先出现的位置  int strpos ( string $haystack , mixed $needle [, int $offset = 0 ] )<br>stripos() 寻找字符串中某字符最先出现的位置,不区分大小写 int stripos ( string $haystack , string $needle [, int $offset ] )<br>strrpos() 寻找某字符串中某字符最后出现的位置 int strrpos ( string $haystack , string $needle [, int $offset = 0 ] )<br>strripos()  寻找某字符串中某字符最后出现的位置,不区分大小写  int strripos ( string $haystack , string $needle [, int $offset ] )<br>strspn()  返回字符串中首次符合mask的子字符串长度 int strspn ( string $str1 , string $str2 [, int $start [, int $length ]] )<br>strcspn() 返回字符串中不符合mask的字符串的长度  int strcspn ( string $str1 , string $str2 [, int $start [, int $length ]] )<br>str_word_count()  统计字符串含有的单词数 mix str_word_count(str $str,[])<br>strlen()  统计字符串长度 int strlen(str $str)<br>count_chars() 统计字符串中所有字母出现次数(0..255)  mixed count_chars ( string $string [, int $mode ] )<br>md5() 字符串md5编码  $str = “Hello”; echo md5($str)<br>iconv</p>
<p>mb_substr 获取字符串的部分  string mb_substr ( string $str , int $start [, int $length = NULL [, string $encoding = mb_internal_encoding() ]] )<br>mb_http_output  设置/获取 HTTP 输出字符编码 mixed mb_http_output ([ string $encoding = mb_http_output() ] )<br>mb_strlen 获取字符串的长度  mixed mb_strlen ( string $str [, string $encoding = mb_internal_encoding() ] )<br>iconv 字符串按要求的字符编码来转换  string iconv ( string $in_charset , string $out_charset , string $str )<br>iconv_substr  截取字符串的部分<br>iconv_get_encoding  获取 iconv 扩展的内部配置变量<br>mb_substr_count 统计字符串出现的次数<br>mb_check_encoding 检查字符串在指定的编码里是否有效<br>mb_strrpos  查找字符串在一个字符串中最后出现的位置<br>mb_split  使用正则表达式分割多字节字符串<br>parse_url 解释URL成为一个数组</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;变量-数据类型&quot;&gt;&lt;a href=&quot;#变量-数据类型&quot; class=&quot;headerlink&quot; title=&quot;变量/数据类型&quot;&gt;&lt;/a&gt;变量/数据类型&lt;/h1&gt;&lt;p&gt;1.必须要以$开始。如变量x必须要写成$x&lt;br&gt;2.变量的首字母不能以数字开始&lt;br&gt;3.变量的名
    
    </summary>
    
    
      <category term="php" scheme="http://yoohannah.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://yoohannah.github.io/post/algorithm/sort.html"/>
    <id>http://yoohannah.github.io/post/algorithm/sort.html</id>
    <published>2017-04-14T14:18:37.000Z</published>
    <updated>2017-04-14T14:24:36.250Z</updated>
    
    <content type="html"><![CDATA[<p>记录：在排序问题中，通常将数据元素称为记录<br>–输入一个记录集合，排序后输出也是一个记录集合<br>–将排序看成是线性表的一种操作<br>排序依据关键字之间的大小关系，那么对同一记录集合，针对不同的关键字进行排序，可以得到不同的序列</p>
<h1 id="排序稳定性"><a href="#排序稳定性" class="headerlink" title="排序稳定性"></a>排序稳定性</h1><p>假设Ki=Kj(1&lt;=i&lt;=n,1&lt;=j&lt;=n,i!=j),且在排序前的序列中ri领先于rj(即i&lt;j)<br>–如果排序后ri仍领先于rj,则称所用排序方法是稳定的<br>–反之，若排序后rj仍领先于ri,则称所用排序方法是不稳定的<br>即原来值相同的两个值A和B,排序前A在B前面，排序后位置不变则说排序算法是稳定的，否则是不稳定的</p>
<h1 id="影响排序算法性能的几个要素"><a href="#影响排序算法性能的几个要素" class="headerlink" title="影响排序算法性能的几个要素"></a>影响排序算法性能的几个要素</h1><p>时间性能(比较，移动)<br>辅助空间(存放临时变量)<br>算法的复杂性</p>
<h1 id="冒泡排序算法n-2"><a href="#冒泡排序算法n-2" class="headerlink" title="冒泡排序算法n^2"></a>冒泡排序算法n^2</h1><p>两两相邻记录的关键字，如果反序则交换，直到没有反序记录为止<br>注意点：<br>– 每次比较相邻两个元素<br>– 如果有n个元素,比较n-1次，每次减少1次比较<br>– 从下往上比较，即从后往前比较<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/bubblesort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="选择排序法n-2"><a href="#选择排序法n-2" class="headerlink" title="选择排序法n^2"></a>选择排序法n^2</h1><p>通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1=&lt;i&lt;=n)个记录交换<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/SelectSort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="直接插入排序n-2"><a href="#直接插入排序n-2" class="headerlink" title="直接插入排序n^2"></a>直接插入排序n^2</h1><p>连续两个值比较若后面的比前面的小，就将后面的值移到比它大的值的前面<br>适用于记录本身就是有序的,记录数少<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/InsertSort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="希尔排序n-logn"><a href="#希尔排序n-logn" class="headerlink" title="希尔排序n*logn"></a>希尔排序n*logn</h1><p>将所有元素按一定间隔f取出n/f个进行比较，再按顺序放回对应的位置，直到所有元素参与完比较之后，算完成一轮比较，<br>再改变间隔进行下一轮比较，直到间隔为1<br>可以将该处理方法套进冒泡、选择和直接插入的方法中<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/shellsort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="堆排序n-logn"><a href="#堆排序n-logn" class="headerlink" title="堆排序n*logn"></a>堆排序n*logn</h1><p>大顶堆；每个结点大于等于其左右孩子的完全二叉树<br>小顶堆：每个结点小于等于其左右孩子的完全二叉树<br>各结点一定是堆中所有结点的最大或最小者，如果按照层序遍历方式给结点从1开始编号，则结点之间满足如下关系<br>大顶堆：Ki&gt;=K2i &amp;&amp; Ki&gt;=K2i+1<br>大顶堆：Ki&lt;=K2i &amp;&amp; Ki&lt;=K2i+1<br>其中(1&lt;=i&lt;=n/2取下限)<br>下标i与2i和2i+1是双亲和子女关系<br>堆排序：利用堆进行排序<br>– 将待排序的序列构造成一个大顶堆(从小到大)(或小顶堆(从大到小))<br>– 此时整个序列的最大值就是堆顶的根结点。将它移走(就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)<br>– 然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的此最大值<br>– 如此反复执行，便能得到一个有序序列了<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/HeapSort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>将待排序数组每次一份为2，直到每一份的数组长度为1，<br>对拆分的两份结果排序合成一个新数组，参与下次下一次比较排序合并<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/MergeSort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>每趟排序指定一个基准点，把比基准点小的元素放在基准点左边，比基准点大的元素放在基准点右边<br>再以基准点为界，把前面的数据(都比基准点小)和后面的数据(都比基准点大)按两部分的最小下标为基准准进行移动,<br>优化<br>选取基准点<br>不必要的交换<br>小数组时的排序方案(使用直接插入排序)<br>递归操作<br>尾递归：函数递归形式的调用出现在函数末尾，可以大大缩减栈空间<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/QuickSort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="/image/qsort.png" alt="qsort"><br>插入排序类:直接插入排序、希尔排序<br>选择排序类：选择排序、堆排序<br>交换排序类：冒泡排序、快速排序<br>归并排序类：归并排序<br><img src="/image/sort.png" alt="sort"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录：在排序问题中，通常将数据元素称为记录&lt;br&gt;–输入一个记录集合，排序后输出也是一个记录集合&lt;br&gt;–将排序看成是线性表的一种操作&lt;br&gt;排序依据关键字之间的大小关系，那么对同一记录集合，针对不同的关键字进行排序，可以得到不同的序列&lt;/p&gt;
&lt;h1 id=&quot;排序稳定性&quot;
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>散列表(哈希表)</title>
    <link href="http://yoohannah.github.io/post/algorithm/hash.html"/>
    <id>http://yoohannah.github.io/post/algorithm/hash.html</id>
    <published>2017-04-09T10:21:37.000Z</published>
    <updated>2017-04-09T14:02:16.070Z</updated>
    
    <content type="html"><![CDATA[<p>记录的存储位置 = f(关键字)<br>散列技术是在存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key)<br>对应关系函数f称为散列函数(哈希函数)<br>采用三列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表(哈希表)</p>
<h1 id="查找步骤"><a href="#查找步骤" class="headerlink" title="查找步骤"></a>查找步骤</h1><p>当存储记录时，通过散列函数计算出记录的散列地址<br>当查找记录时，通过散列函数计算记录的散列地址，并按此散列地址访问该记录<br>各记录之间没有任何关系<br>散列表适合1对1查找，不适合查找范围，也不适合关键字对应多个结果的查找<br>散列函数通过不同的关键字，计算出了相同地址，称之为冲突</p>
<h1 id="构建散列函数"><a href="#构建散列函数" class="headerlink" title="构建散列函数"></a>构建散列函数</h1><p>散列函数原则=计算简单+分布均匀(散列地址)<br>直接定址法<br>取关键字的某个线性函数值为散列地址：f(key)=a*key+b<br>适合查找表小，key比较连续的情况，不常用<br>数字分析法<br>适合处理关键字位数比较大的情况<br>抽取关键字的某几位作为散列地址<br>平方取中法<br>平方取中法是将关键字平方之后取中间若干位数字作为散列地址<br>适合不知道关键字的分布，关键字位数不是很大的情况<br>折叠法<br>将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长取后几位作为散列地址<br>除留余数法<br>f(key) = key mod p(p &lt;= m)<br>m为表长<br>这个方法不仅可以对关键字直接取模，也可以通过折叠、平方取中后再取模<br>p的取值是关键，最好接近m的最小质数<br>随机数法<br>选择一个随机数，取关键字的随机函数值为它的散列地址<br>f(key) = random(key)<br>random为随机函数，适合关键字长度不等的情况<br>选取方法时要考虑的因素：<br>计算散列地址所需时间<br>关键字长度<br>散列表大小<br>关键字分布情况<br>记录查找频率</p>
<h1 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h1><p>开放定址法<br>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入<br>1.线性探测法<br>fi(key) = (f(key)+di) mod m<br>其中di = 1,2,…,m-1<br>意思是，散列函数计算的地址已经被其他记录占据，就将散列函数计算的地址每次次加1到m-1的一个数,<br>再mod表长，将每次计算的结果当做新地址去探测有没有记录，如果没有就将该地址做为记录的地址<br>2.二次探测法<br>修改一次探测法di的取值<br>另di = 1^2,-1^2,2^2,-2^2,q^2,-q^2,其中q&lt;=m/2<br>3.随机探测法<br>对di采用随机函数计算得到<br>再散列函数法<br>fi(key) = RHi(key)(i=1,2,3,…k)<br>就是用第一个散列函数计算的地址发生冲突就换第二个散列函数，如果第二个也发生冲突，则换第三个，以此类推<br>链地址法<br>地址处不存放单一记录，而是存放记录的链表，记录1指向记录2，计算得到地址相同，就继续指下去<br>公共溢出区法<br>不发生冲突的关键字放在基本表，将发生冲突的记录依次存放在溢出表，<br>查找时基本表找不到时就去查溢出表，溢出表找不到再宣告失败</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录的存储位置 = f(关键字)&lt;br&gt;散列技术是在存储位置和它的关键字之间建立一个确定的对应关系f,使得每个关键字key对应一个存储位置f(key)&lt;br&gt;对应关系函数f称为散列函数(哈希函数)&lt;br&gt;采用三列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>多路查找树</title>
    <link href="http://yoohannah.github.io/post/algorithm/multliwaysearchtree.html"/>
    <id>http://yoohannah.github.io/post/algorithm/multliwaysearchtree.html</id>
    <published>2017-04-08T12:59:37.000Z</published>
    <updated>2017-04-09T10:18:15.011Z</updated>
    
    <content type="html"><![CDATA[<p>特点：<br>每个结点的孩子可以多于两个，且每一个结点处可以存储多个元素<br>所有元素之间存在某种特定的排序关系<br>2-3树：每一个结点都具有两个或者三个孩子的多路查找树，所有叶子结点都在同一层次上<br>2结点：拥有两个孩子和一个元素，左子树包含元素小于结点元素，右子树则大于，要么有两个孩子，要么一个孩子也没有<br>3结点：拥有三个孩子两个元素，孩子和结点元素呈一定顺序，要么有三个孩子，要么一个孩子也没有<br>2-3-4树：每一个结点都具有两个或者三个孩子或四个孩子的多路查找树，所有叶子结点都在同一层次上<br>4结点：拥有四个个孩子三个元素，孩子和结点元素呈一定顺序，要么有四个孩子，要么一个孩子也没有</p>
<h1 id="2-3树插入原理"><a href="#2-3树插入原理" class="headerlink" title="2-3树插入原理"></a>2-3树插入原理</h1><p>1.如果是一个空树，直接插入形成一个2结点，即根结点<br>2.插入到一个结构为2结点的叶子上，直接将该2结点转为3结点<br>3.插入到一个结构为3结点的叶子结点，而该叶子结点双亲为2结点，则将该双亲2结点扩展为3结点，将元素插进去<br>4.插入到一个结构为3结点的叶子结点，而其双亲也为3结点，则继续往上找其双亲的双亲是否为2结点，若是，则将该2结点扩展为3结点，将双亲的一个元素挪上去，将3结点的元素挪到双亲，然后插入元素<br>5.插入到一个结构为3结点的叶子结点，往上追溯到根结点也为3结点，则说明该子树已满，需要增加树的高度，即将树每个结点拆都分成2结点，从而保证，所有叶结点在统一层次</p>
<h1 id="2-3树删除原理"><a href="#2-3树删除原理" class="headerlink" title="2-3树删除原理"></a>2-3树删除原理</h1><p>1.删除的元素位于结构为3结点的叶子上，直接删掉就好，3结点变2结点<br>2.删除元素位于结构为2结点的叶子上，<br>若双亲也为2结点结构，且双亲另一个孩子为3结点，则将元素删除后，左旋或右旋，将原来双亲移下来做孩子，将原来3结点一个元素移上去做双亲，另一个不动继续做孩子<br>若双亲为2结点结构，且双亲另一个孩子也为2结点,假设删除的是左子树的元素，则寻找双亲的双亲的直接后继元素来填充双亲的双亲的元素位置，将双亲的双亲的元素做双亲元素的孩子，将双亲元素移下来做孩子，将双亲原来的孩子移上去做双亲<br>若双亲是一个3结点结构，则将双亲一个元素移下来，3结点变2结点<br>若删除时，整颗树是一个满2叉树状态，则将树的深度变小，2结点变3结点<br>3.删除元素位于结构为2结点的双亲位置，若其右孩子为3结点则将其直接后继结点顶上去，3结点孩子变2结点<br>4.删除元素位于结构为3结点的双亲位置，若其直接前驱位于3结点结构，则将前驱顶上去，3结点变2结点<br>若其直接前驱位于2结点结构，则将前驱与直接后继合并为3结点，双亲变2结点</p>
<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例<br>把结点最大的孩子树数目称为B树的阶，因此2-3树是3阶B树，2-3-4树是4阶B树<br>一个m阶的B树有如下属性<br>如果根结点不是叶结点，则其至少有两颗子树<br>每一个非根的分支节点都有K-1个元素和K个孩子，其中K满足：m/2向上取整 &lt;= K &lt;= m<br>所有叶子结点都位于同一层次<br>每个分支结点包含元素个数，该结点各元素及其孩子的信息</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特点：&lt;br&gt;每个结点的孩子可以多于两个，且每一个结点处可以存储多个元素&lt;br&gt;所有元素之间存在某种特定的排序关系&lt;br&gt;2-3树：每一个结点都具有两个或者三个孩子的多路查找树，所有叶子结点都在同一层次上&lt;br&gt;2结点：拥有两个孩子和一个元素，左子树包含元素小于结点元素，右
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉排序树</title>
    <link href="http://yoohannah.github.io/post/algorithm/balancesortbtree.html"/>
    <id>http://yoohannah.github.io/post/algorithm/balancesortbtree.html</id>
    <published>2017-04-08T06:51:37.000Z</published>
    <updated>2017-04-08T09:04:19.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><p>首先得是一颗二叉排序树<br>左子树与右子树都是平衡二叉树<br>每个结点左子树与右子树的深度差的绝对值不能大于1<br>结点左子树深度减右子树深度的差叫做平衡因子BF，即|BF|&lt;=1，BF=-1/1/0<br>平衡二叉树就是一颗二叉树上所有结点的平衡因子的绝对值小于等于1 的树</p>
<h1 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h1><p>左子树bf大于右子树bf，右旋<br>左子树bf小于右子树bf，左旋<br>左旋的子树的右子树若存在左子树，将该左子树做左旋子树根结点的右子树，左旋子树根结点做其右子树的左子树<br>右旋的子树的左子树若存在右子树，将该右子树做右旋子树根结点的左结点，右旋子树根结点做其左子树的右子树</p>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>现用以下数据构建平衡二叉树<br>3,2,1,4,5,6,7,10,9,8<br><img src="/image/balancebtree.png" alt="balance"><br>按照大于父节点做右子树小于父结点做左子树原则,将3,2,1构建树，当1进入树之后3的左子树深度2减右子树深度0大于1，以2为中心进行右旋，如图1<br>继续添加4和5，当5进入树之后，3的左右子树深度差为-2，断开2,3链接，将3,4,5,以4为中心左旋，再与2相连，如图2<br>继续添加6，当6进入树之后,这时2的bf为-2，以2的右子树根结点为中心左旋，此时1,2和3均为4的左子树，则将4的原左子树做新左子树的右子树，如图3<br>添加7,当7进入树之后,5的bf为-2，断开4,5链接，以6为中心左旋，再与4相连，如图4<br>添加10、9,当9进入树之后,6的bf为-2,断开6、7，因为10有左结点，先将9、10关系转换，让10做9孩子结点，然后以9为中心左旋，再与6相连,如图5<br>添加8,4、6的bf又变为-2,断开4、6,9的bf为1，因为将来要对6左旋，所以先将9右旋，使9的bf变成0或负值，再对6以7为中心左旋，如图6<br>最终结果如图7<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/balancebtree.js" target="_blank" rel="external">代码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;特征&quot;&gt;&lt;a href=&quot;#特征&quot; class=&quot;headerlink&quot; title=&quot;特征&quot;&gt;&lt;/a&gt;特征&lt;/h1&gt;&lt;p&gt;首先得是一颗二叉排序树&lt;br&gt;左子树与右子树都是平衡二叉树&lt;br&gt;每个结点左子树与右子树的深度差的绝对值不能大于1&lt;br&gt;结点左子树深度减右
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>二叉排序树</title>
    <link href="http://yoohannah.github.io/post/algorithm/sortbtree.html"/>
    <id>http://yoohannah.github.io/post/algorithm/sortbtree.html</id>
    <published>2017-04-03T08:51:37.000Z</published>
    <updated>2017-04-08T06:20:02.969Z</updated>
    
    <content type="html"><![CDATA[<p>将无序的数组，把首项当做根结点开始，按照比双亲结点小的做左子树，比双亲结点大的做右子树的规则<br>建立一颗二叉树，对二叉树进行中序遍历，即得到无序数组从小到大的排序<br>二叉排序树特点<br>—- 若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值<br>—- 若它的右子树不为空，则右子树上所有结点的值均大于它的根结构的值<br>—- 它的左右子树也分别为二叉排序树(递归)<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/SortingBtree.js" target="_blank" rel="external">代码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将无序的数组，把首项当做根结点开始，按照比双亲结点小的做左子树，比双亲结点大的做右子树的规则&lt;br&gt;建立一颗二叉树，对二叉树进行中序遍历，即得到无序数组从小到大的排序&lt;br&gt;二叉排序树特点&lt;br&gt;—- 若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值&lt;br&gt;—
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>线性索引查找</title>
    <link href="http://yoohannah.github.io/post/algorithm/indexsearch.html"/>
    <id>http://yoohannah.github.io/post/algorithm/indexsearch.html</id>
    <published>2017-04-03T08:38:37.000Z</published>
    <updated>2017-04-03T08:38:46.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h1><p><img src="/image/index1.png" alt="index1"><br>索引表与数据表一对一，索引表的关键码是对应目标数据的提取，索引表有序，数据表无序</p>
<h1 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h1><p><img src="/image/index2.png" alt="index2"><br>将整个数据表分块，取每块数据中最大值建立索引表，块间有序，块内无序</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;稠密索引&quot;&gt;&lt;a href=&quot;#稠密索引&quot; class=&quot;headerlink&quot; title=&quot;稠密索引&quot;&gt;&lt;/a&gt;稠密索引&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/image/index1.png&quot; alt=&quot;index1&quot;&gt;&lt;br&gt;索引表与数据表一对一，索引表的关
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="http://yoohannah.github.io/post/algorithm/search.html"/>
    <id>http://yoohannah.github.io/post/algorithm/search.html</id>
    <published>2017-04-02T11:24:37.000Z</published>
    <updated>2017-04-03T08:10:05.111Z</updated>
    
    <content type="html"><![CDATA[<p>静态查找: 数据集合稳定，不需要添加，删除元素的查找操作<br>– 组织数据宜用线性表结构<br>– 如果要对关键字排序，折半查找算法或斐波那契查找算法<br>动态查找：数据集合在查找过程中需要同时添加或删除元素的查找操作<br>– 二叉排序树，散列表结构</p>
<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><p>顺序查找/线性查找:从第一个(或者最后一个)记录开始，逐个进行记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功。<br>—如果查找了所有的记录仍然找不到与给定值相等的关键字，则查找不成功<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方式一</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">array,key</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> i;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;= array.length;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(a[i] == key)&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//方式二</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">array,key</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> i= array.length;</div><div class="line">	a[<span class="number">0</span>] = key;</div><div class="line">	<span class="keyword">while</span>(a[i] != key)&#123;</div><div class="line">	  i--</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="插值查找-按比例查找"><a href="#插值查找-按比例查找" class="headerlink" title="插值查找(按比例查找)"></a>插值查找(按比例查找)</h1><p>查找方法类似于折半查找，只不过mid的值不再取low和high的中间值，<br>而是根据查找值在low和hight中间的大概位置确定mid<br>var mid = low +(high-low)*(num-list[low])/(list[high]-list[low]);<br>因此插值查找适用于有一定顺序规律的数组<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/Interpolationsearch.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="斐波那契查找-黄金查找"><a href="#斐波那契查找-黄金查找" class="headerlink" title="斐波那契查找(黄金查找)"></a>斐波那契查找(黄金查找)</h1><p>同样适用于有一定顺序规律的数组<br>在折半查找的基础上根据斐波那契数列进行分割。<br>在斐波那契数列找一个等于略大于查找表中元素个数的数F[k]，<br>将原查找表扩展为长度为F[k]-1(如果要补充元素，则补充重复最后一个元素，直到满足F[k]-1个元素)<br>进行斐波那契分割，即F[k]-1个元素分割为前半部分F[k-1]-1个元素，后半部分F[n-2]-1个元素，剩一个做mid<br>找出要查找的元素在那一部分并递归，直到找到。<br><img src="/image/fiobsearch.png" alt="fiobsearch"><br><a href="https://github.com/YooHannah/algorithm/blob/master/js/FibonacciSearch.js" target="_blank" rel="external">代码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态查找: 数据集合稳定，不需要添加，删除元素的查找操作&lt;br&gt;– 组织数据宜用线性表结构&lt;br&gt;– 如果要对关键字排序，折半查找算法或斐波那契查找算法&lt;br&gt;动态查找：数据集合在查找过程中需要同时添加或删除元素的查找操作&lt;br&gt;– 二叉排序树，散列表结构&lt;/p&gt;
&lt;h1 
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关键路径</title>
    <link href="http://yoohannah.github.io/post/algorithm/keypath.html"/>
    <id>http://yoohannah.github.io/post/algorithm/keypath.html</id>
    <published>2017-04-02T11:15:37.000Z</published>
    <updated>2017-04-02T11:16:00.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p>AOE网：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，<br>这种有向图的边表示活动的网，我们称之为AOE网(Activity On Edge Network)<br>始点/源点:AOE网中没有入边的顶点<br>终点/汇点:AOE网中没有出边的顶点<br><img src="/image/keypath.png" alt="keypath"><br>etv:时间最早发生时间,顶点的最早发生时间<br>ltv:事件最晚发生时间，每个顶点对应事件最晚需要开始的时间，如果超出此时间将会延误着整个工期<br>ete:活动最早开工时间，弧的最早发生时间<br>lte:活动最晚发生时间，不推迟工期的最晚开工时间<br>关键路径的目的是在规划工程各项活动执行的顺序时，找出关键的活动，保证工程不延期<br><img src="/image/keypath1.png" alt="keypath1"><br><img src="/image/keypath2.png" alt="keypath2"><br><a href="https://github.com/YooHannah/algorithm/blob/master/js/CriticalPath.js" target="_blank" rel="external">代码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关键路径&quot;&gt;&lt;a href=&quot;#关键路径&quot; class=&quot;headerlink&quot; title=&quot;关键路径&quot;&gt;&lt;/a&gt;关键路径&lt;/h1&gt;&lt;p&gt;AOE网：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，&lt;br&gt;这种有向图
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://yoohannah.github.io/post/algorithm/TopologySorting.html"/>
    <id>http://yoohannah.github.io/post/algorithm/TopologySorting.html</id>
    <published>2017-04-02T11:14:37.000Z</published>
    <updated>2017-04-02T11:14:47.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>DAG(Directed Acyclic)图/无环图：无环的有向图<br>‘活动’：所有的工程或者某种流程都可以分为的若干个小的工程或者阶段<br>AOV(Active On Vertex Network)网：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系<br>这样的有向图为顶点表示活动的网即AOV网<br>拓扑序列：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1，V2，……Vn满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必在顶点Vj之前,我们称这样的顶点序列为一个拓扑序列,<br>拓扑排序：所谓的拓扑排序，其实就是对一个有向图构造拓扑序列的过程,保证活动是按一定顺序进行<br><img src="/image/tuopu1.png" alt="tuopu1"></p>
<h1 id="对AOV网进行拓扑排序的方法和步骤"><a href="#对AOV网进行拓扑排序的方法和步骤" class="headerlink" title="对AOV网进行拓扑排序的方法和步骤"></a>对AOV网进行拓扑排序的方法和步骤</h1><p>——从AOV网中选择一个没有前驱的顶点(入度为0的顶点),并且输出它；<br>——从网中删去该顶点，并且删去从该顶点发出的全部有向边(将有向边终点入度减一)<br>——重复上述两步，直到剩余网中不再没有前驱的顶点为止。<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/TopologicalSort.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><p>对一个具有n个顶点，e条边的网来说，初始建立入度为0的顶点栈，要检查所有顶点一次，执行时间为O(n);<br>排序中，若AOV网无回路，则每个顶点入、出栈各一次，每个表结点被检查一次，因而执行时间是O(n+e);<br>因此整个算法时间复杂度是O(n+e)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;DAG(Directed Acyclic)图/无环图：无环的有向图&lt;br&gt;‘活动’：所有的工程或者某种流程都可以分为的若干个小的工程或者阶段
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="http://yoohannah.github.io/post/algorithm/shortestpath.html"/>
    <id>http://yoohannah.github.io/post/algorithm/shortestpath.html</id>
    <published>2017-04-02T11:12:37.000Z</published>
    <updated>2017-04-02T11:12:41.152Z</updated>
    
    <content type="html"><![CDATA[<p>网图：两个顶点经过的边上权值之和最少的路径<br>非网图：两个顶点之间经过的边数最少的路径<br>源点：路径起始的第一个顶点<br>终点：最后一个顶点<br><img src="/image/shortestpath1.png" alt="shortestpath1"></p>
<h1 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h1><p>一个顶点到所有顶点的最短路径<br>主要思路：一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径<br>编程思路：类似于最小生成树普里姆算法<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/ShortestPath_Dijkstra.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="佛洛依德-Floyd-算法"><a href="#佛洛依德-Floyd-算法" class="headerlink" title="佛洛依德(Floyd)算法"></a>佛洛依德(Floyd)算法</h1><p>扩展版迪杰斯特拉(Dijkstra)算法，求图中所有结点到所有结点的最大路径，结果由二维数组展现<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/ShortestPath_Floyd.js" target="_blank" rel="external">代码链接</a><br><img src="/image/shortestpath2.png" alt="shortestpath2"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网图：两个顶点经过的边上权值之和最少的路径&lt;br&gt;非网图：两个顶点之间经过的边数最少的路径&lt;br&gt;源点：路径起始的第一个顶点&lt;br&gt;终点：最后一个顶点&lt;br&gt;&lt;img src=&quot;/image/shortestpath1.png&quot; alt=&quot;shortestpath1&quot;&gt;&lt;/
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://yoohannah.github.io/post/algorithm/MinimumTree.html"/>
    <id>http://yoohannah.github.io/post/algorithm/MinimumTree.html</id>
    <published>2017-03-30T13:10:37.000Z</published>
    <updated>2017-03-30T14:16:44.892Z</updated>
    
    <content type="html"><![CDATA[<p>图的各结点连线间存在权值，寻找一种访问路径,使得访问各结点最终的路径的权值和最小，<br>最终访问路径和结点形成树的结构，即最小生成树</p>
<h1 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h1><p><img src="/image/plim.png" alt="plim"><br>主要思路：研究对象为结点，以某顶点为起点，逐步找各个顶点上最小权值的边来构建最小生成树<br>编程思路：新建一数组，初始化为起点(最小生成树的根结点)在邻接矩阵所在行的权值<br>找到该组权值最小值,最小权值下标即要选择路径的终点，同时也是接下来要比较的邻接矩阵权值行的行号，<br>将该最小权值置0，然后将新建数组与矩阵权值行比较，<br>相同位置，矩阵行若小于新建数组值，就将新建数组值替换为矩阵行的值，<br>再次寻找新建数组中的最小权值，重复以上步骤<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/MinimumTreeofPlim.js" target="_blank" rel="external">代码链接</a></p>
<h1 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h1><p><img src="/image/kluse.png" alt="kluse"><br>主要思路：研究对象为边，将边集数组从小到大排序，依次取边集数组的元素，判断边与边是否形成环路，不会形成则选择该边构建最小树<br><a href="https://github.com/YooHannah/algorithm/blob/master/js/MinimumTreeofKruskal.js" target="_blank" rel="external">代码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图的各结点连线间存在权值，寻找一种访问路径,使得访问各结点最终的路径的权值和最小，&lt;br&gt;最终访问路径和结点形成树的结构，即最小生成树&lt;/p&gt;
&lt;h1 id=&quot;普里姆算法&quot;&gt;&lt;a href=&quot;#普里姆算法&quot; class=&quot;headerlink&quot; title=&quot;普里姆算法&quot;&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于commonjs、MVC、模板引擎</title>
    <link href="http://yoohannah.github.io/post/knowledge/commonjs.html"/>
    <id>http://yoohannah.github.io/post/knowledge/commonjs.html</id>
    <published>2017-03-21T14:16:37.000Z</published>
    <updated>2017-03-21T14:16:41.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="commonjs理解"><a href="#commonjs理解" class="headerlink" title="commonjs理解"></a>commonjs理解</h1><p>是一种编写API的标准，根据该标准写的API可以在任何支持JavaScript的环境中使用，尤其是可以满足服务端的应用<br>四个个关键词<br>modules：模块，外部用 JavaScript 封装，具有对外接口并有一定功能作用的一个文件<br>packages：包，多个module的集合，相当于提供了一些固定接口的函数库，提供更高层的的抽象<br>exports：模块对外的接口对象，在模块文件中编写的功能函数作为它的属性函数，不同写法，使用规则不一样<br>require：当我们要使用某个模块时，用来获取/加载模块接口的对象,获取模块的 exports 对象。</p>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MODEL-VIEW-CONTROLL，模型-视图-控制器，是一种软件的设计模式<br>模型:对象及其数据结构的实现，通常包含数据库的操作<br>视图：表示用户界面，在网站中通常就是HTML的组织结构<br>控制器：用于处理用户请求和数据流，复杂模型，将输出传递给视图<br><img src="/image/noun2.png" alt="noun2"></p>
<h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><p>是一个生成HTML的工具<br>其功能是将页面模板和要显示的数据结合起来生成HTML页面<br>既可以运行在服务端又可以运行在客户端，<br>大多数时候它都在服务器端直接被解析为HTML，解析完后再传输给客户端<br>有时候也可以运行在客户端，即浏览器中<br>MVC架构中，模板引擎包含在服务器端，流程如下：<br>控制器得到用户请求后，从模型(原来页面)获取数据，调用模板引擎<br>模板引擎以数据(经过后台处理，要传递给客户端的)和页面模板为输入，生成HTML页面<br>返回给控制器，由控制器交会回给客户端<br><img src="/image/noun1.png" alt="noun1"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;commonjs理解&quot;&gt;&lt;a href=&quot;#commonjs理解&quot; class=&quot;headerlink&quot; title=&quot;commonjs理解&quot;&gt;&lt;/a&gt;commonjs理解&lt;/h1&gt;&lt;p&gt;是一种编写API的标准，根据该标准写的API可以在任何支持JavaScrip
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoohannah.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>mongoDB使用</title>
    <link href="http://yoohannah.github.io/post/knowledge/mongoDB.html"/>
    <id>http://yoohannah.github.io/post/knowledge/mongoDB.html</id>
    <published>2017-03-19T13:45:37.000Z</published>
    <updated>2017-03-20T14:02:52.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>cmd到mongoDB的bin文件夹,执行<br>mongod –dbpath data文件夹路径（例：D:\MongoDB\data）//运行<br>再打开一个cmd,同样切目录到bin文件夹下,执行<br>mongo //连接到数据库</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>use dbname    //名为dbname的数据库若存在就将当前数据库切换到该数据库，若不存在，则新建该数据库并切换至该数据库<br>db   //查看当前数据库<br>show dbs    //查看所有数据库,新建的库，在插入数据后才会显示<br>db.dropDatabase() //删除当前数据库,但用db查看当前库，还是被删的这个库<br>db.tablename.drop() //删除数据库中名为tablename的集合<br>db.tablename.insert({“key”:”value”}) //创建名为objectname的表(对象),并插入数据,批量操作时可以直接在shell里面写for循环<br>show tables //查看该库中所有表(对象)<br>db.tablename.find() //在仓库中查找名为tablename的表，如果有就会将表中内容打印出来<br>db.tablename.find({“key”:”value”}) //在tablename表中查找具体数据，注意格式<br><img src="/image/mongodb1.png" alt="mongodb1"><br>db.tablename.update({查找值},{替换值}) //将查找值所在的集合替换为替换值<br><img src="/image/mongodb2.png" alt="mongodb2"><br>db.tablename.remove({查找值}) //删除查找值所在对象的全部数据，若为空，则将整表清空<br><img src="/image/mongodb3.png" alt="mongodb3"></p>
<h2 id="条件查找"><a href="#条件查找" class="headerlink" title="条件查找"></a>条件查找</h2><p>1.比较查询<br>将查找条件放在value部分，用{}括起来<br>下图查询条件为age大于”$gt”22, 大于等于”$gte”22, 小于”$lt”22, 小于等于”$lte”22, 不等于”$ne”20,等于20的查询格式<br><img src="/image/mongodb4.png" alt="mongodb4"><br>使用正则表达式匹配时同样将正则表达式放在value的位置，而且不用{}或者””包括，直接/开始/结束<br>2.逻辑查询<br>下图查询条件分别为且，或者$or,在氛围内$in,不在范围内$nin<br><img src="/image/mongodb5.png" alt="mongodb5"></p>
<h2 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h2><p>$inc 属性不存在就创建并赋值，如果存在，就在原来的基础上增加要修改的值<br>$set 仅修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; db.person.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;58ccdcb002efa48d7589f2ae&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;age&quot; : 20 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;58ccdcb502efa48d7589f2af&quot;), &quot;name&quot; : &quot;joe&quot;, &quot;age&quot; : 25 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;58ccdcd302efa48d7589f2b0&quot;), &quot;name&quot; : &quot;mark&quot;, &quot;age&quot; : 15 &#125;</div><div class="line">&gt; db.person.update(&#123;&quot;name&quot;:&quot;jack&quot;&#125;,&#123;$inc:&#123;&quot;age&quot;:10&#125;&#125;)</div><div class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</div><div class="line">&gt; db.person.update(&#123;&quot;name&quot;:&quot;mark&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:10&#125;&#125;)</div><div class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</div><div class="line">&gt; db.person.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;58ccdcb002efa48d7589f2ae&quot;), &quot;name&quot; : &quot;jack&quot;, &quot;age&quot; : 30 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;58ccdcb502efa48d7589f2af&quot;), &quot;name&quot; : &quot;joe&quot;, &quot;age&quot; : 25 &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;58ccdcd302efa48d7589f2b0&quot;), &quot;name&quot; : &quot;mark&quot;, &quot;age&quot; : 10 &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></p>
<p>特殊情况：update的第一个参数不存在，即查找值不在person中，可以如下设置，将其新增<br>db.person.update({“name”:”jackson”},{$inc:{“age”:10}},true)<br>注意：update默认仅更新匹配得到的第一个集合，如果想更新全部匹配得到的结果，<br>可以将第四个参数设为true</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>1.计数<br>db.person.count()  //获取person中数据条数<br>db.person.count({“age”:20}) // 获取person中age等于20的数据条数<br>2.统计<br>db.person.distinct(“age”) //获取person中所有age的值，重复的值只取一次<br>3.分组<br>db.person.group({<br>    “key”:{“age”:true},//按age分组，age相同的分一组<br>    “initial”:{“person”:[]}, //分组内容<br>    “$reduce”:function(cur,prev){ //符合分组条件，将该条数据放入该组集合中，cur指当前处理的该条数据，prev指上次函数的累计对象，第一次为initial的值。<br>        prev.person.push(cur.name);<br>    },<br>  “finalize”:function(out){//将一条数据划分到一组后执行的处理<br>  out.count = out.person.length;<br>  },<br>  “condition”:{“age”:{$lt:25}}//分组条件，对什么样的数据进行分组<br>})<br>4.映射<br>通过map对集合进行分组，通过reduce对分组结果进行处理，理解为复杂的重组处理，最后会生成一个全新的集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var map = function()&#123;</div><div class="line">	emit(this.name,&#123;count:1&#125;);  //集合按照name分组，分组内容均为&#123;count：1&#125;</div><div class="line">&#125;</div><div class="line">var reduce = function(key,value)&#123;  //对分组结果进行处理</div><div class="line">	var result = &#123;count:0&#125;;</div><div class="line">	for(var i = 0;i&lt;value.length;i++)&#123;</div><div class="line">		result.count +=value[i].count;</div><div class="line">	&#125;</div><div class="line">	return result;</div><div class="line">&#125;</div><div class="line">db.person.mapReduce(map,reduce,&#123;&quot;out&quot;:&quot;collection&quot;&#125;)</div><div class="line">db.collection.find()</div></pre></td></tr></table></figure></p>
<p>5.循环处理<br>可以将集合赋值给一个变量然后进行循环处理，<br>var list = db.person.find();<br>list.forEach(function(x){<br>    print(x.name):<br>})</p>
<p>6.可以多操作查询<br>对person集合数据按name排序然后分页<br>var single=db.person.find().sort({“name”,1}).skip(2).limit(2);</p>
<p>7.索引查询<br>建立索引：<br>db.person.ensureIndex({“name”:1}) //建立按照name进行排序的索引，1为升序，-1为降序<br>db.person.ensureIndex({“name”:1},{“unique”:true}) //建立唯一索引，集合中不能出现重复键值对<br>db.person.ensureIndex({“name”:1,”birthday”:1}) //组合索引<br>查询优化器做出的选择往往是最优的，因为我们做查询时，查询优化器会使用我们建立的这些索引来创建查询方案，<br>如果某一个先执行完则其他查询方案被close掉，这种方案会被mongodb保存起来，当然如果非要用自己指定的查询方案，这也是可以的，在mongodb中给我们提供了hint方法让我们可以暴力执行。<br>db.person.find({“name”:”jack”,”birthday”:”1998-3-2”}).hint({“name”:1,”birthday”:1})</p>
<p>删除索引：<br>db.person.dropIndexes(“name_1”)</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p>将数据库数据复制到多台服务器上，防止因为一台服务器死机而导致数据无法使用的问题出现<br>将安装文件复制到其他磁盘上，模拟不同的服务器<br>启动H盘上的mongodb，把该数据库指定为主数据库<br>H:\mongoDB\bin&gt;mongod –dbpath H:\mongoDB\data –master<br>启动D盘上的mongodb，把该数据库指定为从属数据库<br>D:\mongoDB\bin&gt;mongod –dbpath D:\mongoDB\data –port 8888 –slave –source=127.0.0.1:27017<br>更换端口为8888，source表示主数据库地址<br>2017-03-20T10:12:17.424+0800 I REPL     [replslave] syncing from host:127.0.0.1:<br>27017<br>然后分别打开主shell(mongo 127.0.0.1:27017)和从shell(mongo 127.0.0.1:8888)查看所有集合<br>show dbs<br>因为从服务器上的数据库是不允许进行读写操作,所以从shell中会报错<br><img src="/image/mongodb7.png" alt="mongodb7"><br>解决，先执行：rs.slaveOk()<br>现在主shell中更改数据，在从shell中查看，看是否进行了同步<br>但有可能因为服务连接状态问题导致数据内容不同<br><img src="/image/mongodb8.png" alt="mongodb8"></p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>不设定特定主数据库，如果哪个数据库死机了，集群就会推选一个从属数据库作为主数据库顶上，实现自动修复的效果<br>1.建立集群，命名集群名为shopex,replSet让服务器知道shopex下有端口为3333的另一个数据库服务器<br>新打开cmd<br>H:\mongoDB\bin&gt;mongod –dbpath H:\mongoDB\data –port 2222 –replSet shopex/127.0.0.1:3333<br>2.打开端口为3333的另一个数据库服务器<br>新打开cmd<br>D:\mongoDB\bin&gt;mongod –dbpath D:\mongoDB\data –port 3333 –replSet shopex/127.0.0.1:2222<br>3.在admin集合中初始化“副本集”<br>新打开cmd,开启shell<br>H:\mongoDB\bin&gt;mongo 127.0.0.1:2222/admin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; db.runCommand(&#123;&quot;replSetInitiate&quot;:&#123;</div><div class="line">... &quot;_id&quot;:&quot;shopex&quot;,</div><div class="line">... &quot;members&quot;:[</div><div class="line">... &#123;</div><div class="line">... &quot;_id&quot;:1,</div><div class="line">... &quot;host&quot;:&quot;127.0.0.1:2222&quot;</div><div class="line">... &#125;,</div><div class="line">... &#123;</div><div class="line">... &quot;_id&quot;:2,</div><div class="line">... &quot;host&quot;:&quot;127.0.0.1:3333&quot;</div><div class="line">... &#125;</div><div class="line">... ]&#125;&#125;)</div><div class="line">&#123; &quot;ok&quot; : 1 &#125;</div></pre></td></tr></table></figure></p>
<p>4.设置仲裁服务器<br>新打开cmd,开启服务<br>D:\mongoDB\bin&gt;mongod –dbpath F:\mongoDB\data –port 4444 –replSet shopex/127.0.0.1:2222<br>开启shell,设置及产看结果<br>H:\mongoDB\bin&gt;mongo 127.0.0.1:2222/admin<br>shopex:PRIMARY&gt; rs.addArb(“127.0.0.1:4444”)<br>{ “ok” : 1 }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">shopex:PRIMARY&gt; rs.status()</div><div class="line">&#123;</div><div class="line">        &quot;set&quot; : &quot;shopex&quot;,</div><div class="line">        &quot;date&quot; : ISODate(&quot;2017-03-20T05:55:12.742Z&quot;),</div><div class="line">        &quot;myState&quot; : 1,</div><div class="line">        &quot;term&quot; : NumberLong(1),</div><div class="line">        &quot;heartbeatIntervalMillis&quot; : NumberLong(2000),</div><div class="line">        &quot;optimes&quot; : &#123;</div><div class="line">                &quot;lastCommittedOpTime&quot; : &#123;</div><div class="line">                        &quot;ts&quot; : Timestamp(1489989307, 1),</div><div class="line">                        &quot;t&quot; : NumberLong(1)</div><div class="line">                &#125;,</div><div class="line">                &quot;appliedOpTime&quot; : &#123;</div><div class="line">                        &quot;ts&quot; : Timestamp(1489989307, 1),</div><div class="line">                        &quot;t&quot; : NumberLong(1)</div><div class="line">                &#125;,</div><div class="line">                &quot;durableOpTime&quot; : &#123;</div><div class="line">                        &quot;ts&quot; : Timestamp(1489989307, 1),</div><div class="line">                        &quot;t&quot; : NumberLong(1)</div><div class="line">                &#125;</div><div class="line">        &#125;,</div><div class="line">        &quot;members&quot; : [</div><div class="line">                &#123;</div><div class="line">                        &quot;_id&quot; : 1,</div><div class="line">                        &quot;name&quot; : &quot;127.0.0.1:2222&quot;,</div><div class="line">                        &quot;health&quot; : 1,</div><div class="line">                        &quot;state&quot; : 1,</div><div class="line">                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,</div><div class="line">                        &quot;uptime&quot; : 596,</div><div class="line">                        &quot;optime&quot; : &#123;</div><div class="line">                                &quot;ts&quot; : Timestamp(1489989307, 1),</div><div class="line">                                &quot;t&quot; : NumberLong(1)</div><div class="line">                        &#125;,</div><div class="line">                        &quot;optimeDate&quot; : ISODate(&quot;2017-03-20T05:55:07Z&quot;),</div><div class="line">                        &quot;electionTime&quot; : Timestamp(1489989026, 1),</div><div class="line">                        &quot;electionDate&quot; : ISODate(&quot;2017-03-20T05:50:26Z&quot;),</div><div class="line">                        &quot;configVersion&quot; : 2,</div><div class="line">                        &quot;self&quot; : true</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                        &quot;_id&quot; : 2,</div><div class="line">                        &quot;name&quot; : &quot;127.0.0.1:3333&quot;,</div><div class="line">                        &quot;health&quot; : 1,</div><div class="line">                        &quot;state&quot; : 2,</div><div class="line">                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,</div><div class="line">                        &quot;uptime&quot; : 296,</div><div class="line">                        &quot;optime&quot; : &#123;</div><div class="line">                                &quot;ts&quot; : Timestamp(1489989307, 1),</div><div class="line">                                &quot;t&quot; : NumberLong(1)</div><div class="line">                        &#125;,</div><div class="line">                        &quot;optimeDurable&quot; : &#123;</div><div class="line">                                &quot;ts&quot; : Timestamp(1489989307, 1),</div><div class="line">                                &quot;t&quot; : NumberLong(1)</div><div class="line">                        &#125;,</div><div class="line">                        &quot;optimeDate&quot; : ISODate(&quot;2017-03-20T05:55:07Z&quot;),</div><div class="line">                        &quot;optimeDurableDate&quot; : ISODate(&quot;2017-03-20T05:55:07Z&quot;),</div><div class="line">                        &quot;lastHeartbeat&quot; : ISODate(&quot;2017-03-20T05:55:11.766Z&quot;),</div><div class="line">                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-03-20T05:55:10.786Z&quot;</div><div class="line">),</div><div class="line">                        &quot;pingMs&quot; : NumberLong(0),</div><div class="line">                        &quot;syncingTo&quot; : &quot;127.0.0.1:2222&quot;,</div><div class="line">                        &quot;configVersion&quot; : 2</div><div class="line">                &#125;,</div><div class="line">                &#123;</div><div class="line">                        &quot;_id&quot; : 3,</div><div class="line">                        &quot;name&quot; : &quot;127.0.0.1:4444&quot;,</div><div class="line">                        &quot;health&quot; : 1,</div><div class="line">                        &quot;state&quot; : 7,</div><div class="line">                        &quot;stateStr&quot; : &quot;ARBITER&quot;,</div><div class="line">                        &quot;uptime&quot; : 44,</div><div class="line">                        &quot;lastHeartbeat&quot; : ISODate(&quot;2017-03-20T05:55:11.765Z&quot;),</div><div class="line">                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-03-20T05:55:07.948Z&quot;</div><div class="line">),</div><div class="line">                        &quot;pingMs&quot; : NumberLong(0),</div><div class="line">                        &quot;configVersion&quot; : 2</div><div class="line">                &#125;</div><div class="line">        ],</div><div class="line">        &quot;ok&quot; : 1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在如果关掉2222端口服务器，再打开，在执行rs.status(),可以看到2222的“stateStr”变成”SECONDARY”<br>“3333”的变成”PRIMARY”<br><a href="http://www.cnblogs.com/huangxincheng/archive/2012/02/29/2372699.html" target="_blank" rel="external">相关链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h1&gt;&lt;p&gt;cmd到mongoDB的bin文件夹,执行&lt;br&gt;mongod –dbpath data文件夹路径（例：D:\MongoDB\data）//
    
    </summary>
    
    
      <category term="nodejs" scheme="http://yoohannah.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>开发小结</title>
    <link href="http://yoohannah.github.io/post/knowledge/prehensive.html"/>
    <id>http://yoohannah.github.io/post/knowledge/prehensive.html</id>
    <published>2017-03-15T13:42:51.000Z</published>
    <updated>2017-03-15T13:50:19.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对于路由的理解"><a href="#对于路由的理解" class="headerlink" title="对于路由的理解"></a>对于路由的理解</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">官方定义：</div><div class="line">路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。</div><div class="line">路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback...], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。</div></pre></td></tr></table></figure>
<p>当浏览器向服务器发过来一个http请求时，会携带请求路径和请求方法,服务器根据发过来的路径和请求方法进行匹配,二者都匹配的话，就执行对应的回调函数<br>请求的目的在客户端看来可能多种多样，比如单纯的访问页面，重新获取页面数据，向后台传递数据，但是在服务端看来都是一样的处理方法，匹配路径和方法，进行回调函数，<br>即通过匹配执行相应的动作，比如<br>客户端想访问一个页面，回调函数就执行渲染页面的操作<br>客户端要传递数据给数据库，回调函数就获取传递的数据然后给到数据库<br>作用就像一个指南针，根据客户端不同的请求，执行不同的操作<br>但涉及到的具体操作（数据处理）可能会通过其他文件的处理函数来实现<br><a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="external">官方文档</a></p>
<h1 id="对于中间件的理解"><a href="#对于中间件的理解" class="headerlink" title="对于中间件的理解"></a>对于中间件的理解</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">官方定义</div><div class="line">中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。</div><div class="line">中间件的功能包括：</div><div class="line">执行任何代码。</div><div class="line">修改请求和响应对象。</div><div class="line">终结请求-响应循环。</div><div class="line">调用堆栈中的下一个中间件。</div><div class="line">如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。</div></pre></td></tr></table></figure>
<p>粗浅的理解为功能处理函数，比如路由匹配里的回调函数，根据功能和使用方式不同分成多种<br>1.应用级中间件， app.use() 和 app.METHOD()的回调函数<br>2.路由级中间件，var router = express.Router()， router.use() 或 router.VERB() 的回调函数<br>3.错误处理中间件，进行错误处理的的函数，参数与其他不同<br>4.内置中间件, express.static<br>5.第三方中间件,通过npm安装的模块，即我们使用的模块也算是中间件<br><a href="http://www.expressjs.com.cn/guide/using-middleware.html#middleware.application" target="_blank" rel="external">官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对于路由的理解&quot;&gt;&lt;a href=&quot;#对于路由的理解&quot; class=&quot;headerlink&quot; title=&quot;对于路由的理解&quot;&gt;&lt;/a&gt;对于路由的理解&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
</feed>
