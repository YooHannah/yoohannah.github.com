<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Little World</title>
  <subtitle>learn and share</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoohannah.github.io/"/>
  <updated>2019-03-03T14:23:43.892Z</updated>
  <id>http://yoohannah.github.io/</id>
  
  <author>
    <name>YooHannah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack配置</title>
    <link href="http://yoohannah.github.io/post/performance/webpackdetail.html"/>
    <id>http://yoohannah.github.io/post/performance/webpackdetail.html</id>
    <published>2019-03-03T08:21:02.000Z</published>
    <updated>2019-03-03T14:23:43.892Z</updated>
    
    <content type="html"><![CDATA[<p>webpack在启动后会从Entry里配置的Moudule开始，递归解析Entry依赖的所有Module，每找到一个module,就会根据配置的loader去找对应的转换规则，<br>对Module进行转换后，在解析当前Module依赖的Module。这些模块会以Entry为单位进行分组，一个Entry及其所有依赖Module被分到一个组，也就是一个Chunk<br>最后，webpack会将所有Chunk转换成文件输出。webpack会在恰当的时机执行Plugin里定义的逻辑</p>
<h1 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h1><p>入口，webpack执行构建的第一步将从Entry开始，可抽象成输入<br>配置：<br>方式1： 直接一个文件路径字符串：’./app/entry1’<br>方式2： 文件路径字符串数组：[‘./app/entry1’,’./app/entry2’]<br>方式3： 文件路径字符串对象：{A：’./app/entryA’,B:’./app/entryB’}<br>方式4： 函数，动态导出以上三种形式<br>方式1,2最后只会有一个文件会被导出，即导出一个Chunk,名为main<br>方式3导出多个Chunk,名称分别对应对象KEY值</p>
<h1 id="output"><a href="#output" class="headerlink" title="output"></a>output</h1><p>输出结果，在webpack经过一系列处理并得到最终想要的代码后输出结果<br>配置：</p>
<h2 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h2><p>输出文件名<br>方式1：静态，名字写死，如bundle.js，适用于只有一个导出Chunk，一个输出文件<br>方式2：利用Chunk内置变量，动态拼接生成文件名，例如’[name].js’<br>Chunk内置变量有：id,name,hash(name的hash,可指定长度，例如[hash:8]),chunkhash(chunk内容的hash)<br>相关：ExtractTextWebpackPlugin使用contenthash表示文件内容hash,但提取的内容为代码本身，不是一组模块组成的chunck内容</p>
<h2 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h2><p>无具体入口的chunk输出的文件名<br>例如通过commonChunkPlugin生成的文件，或者使用import动态加载生成的文件等<br>因为都是chunk输出文件，所以内置变量同filename的chunk</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>输出文件的存放目录<br>配置：绝对路径的字符串<br>内置变量：仅有一个，hash,代表一次编译操作的hash值</p>
<h2 id="publishPath"><a href="#publishPath" class="headerlink" title="publishPath"></a>publishPath</h2><p>配置发布到线上资源的URL前缀<br>配置：字符串<br>内置变量：仅有一个，hash,代表一次编译操作的hash值</p>
<h2 id="crossOriginloading"><a href="#crossOriginloading" class="headerlink" title="crossOriginloading"></a>crossOriginloading</h2><p>配置异步插入的script标签的crossorign值<br>配置：<br>anonymous，默认，不带cookie<br>use-credentials,加载时，带cookie</p>
<h2 id="library"><a href="#library" class="headerlink" title="library"></a>library</h2><p>导出库的名称,与libraryTarget配合使用<br>配置：字符串</p>
<h2 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h2><p>以何种方式导出库<br>配置：以下字符串<br>‘var’|’commonjs’|’commonjs2’|’this’|’window’|’global’</p>
<h2 id="libraryExport"><a href="#libraryExport" class="headerlink" title="libraryExport"></a>libraryExport</h2><p>在libraryTarget配置’commonjs’|’commonjs2’时，配置导出模块中哪些子模块被导出</p>
<h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><p>模块处理规则</p>
<h2 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h2><p>数组，每一项是处理同一类文件的相关配置对象</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>处理哪些文件，文件名命中规则，<br>配置：字符串</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>在什么目录范围内匹配<br>配置：字符串/字符串数组（每一项是或的关系，只要满足一个条件就会命中）</p>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p>排除哪些目录范围，再匹配<br>配置：字符串/字符串数组（每一项是或的关系，只要满足一个条件就会命中）</p>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>配置loader<br>loader可以看作具有文件转换功能的翻译员，告诉webpack在遇到哪些文件时使用哪些loader去加载和转换<br>配置：数组，每一项可以是是字符串，或者对象<br>默认执行顺序为数组倒序执行，即最末尾先执行<br>字符串：loader名称<br>对象：对于该loader的一些相关配置</p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p>配置：字符串，loader名</p>
<h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>配置：对象，给loader处理函数传入的参数</p>
<h4 id="enforce"><a href="#enforce" class="headerlink" title="enforce"></a>enforce</h4><p>更改loader执行顺序<br>配置：<br>pre: 放在执行顺序最前面<br>post:放在执行顺序最后</p>
<h2 id="noparse"><a href="#noparse" class="headerlink" title="noparse"></a>noparse</h2><p>功能类似于exclude,排除不需要进行接续处理的文件，<br>此类文件中不能采用模块化方式编写，即不应包含import,require,define等语句，<br>否则导致无法在浏览器下执行<br>配置：字符串，文件路径</p>
<h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>更细粒度地配置哪些语法被解析，哪些不被解析，精确到语法层面<br>{cmd:false,commonjs:false….}</p>
<h1 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h1><p>配置如何寻找模块对应的文件</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>通过将路径前缀指定别名，进行映射<br>配置：对象，key为别名，值为实际路径<br>例：{components：’./src/components’,…}</p>
<h2 id="mainFields"><a href="#mainFields" class="headerlink" title="mainFields"></a>mainFields</h2><p>决定优先使用第三方模块的哪份代码，按数组顺序查找，使用找到的第一份文件<br>配置：第三方模块导出文件的关键字<br>例：[‘jsnext:main’,’brower’,’main’]</p>
<h2 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h2><p>导入语句没有带文件后缀时，尝试寻找的后缀代表<br>配置：后缀字符串数组<br>例：[‘.ts’,’.js’,’json’]</p>
<h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>去哪些目录下寻找第三方模块，默认node_modules<br>配置：字符串数组<br>例：[‘.src/components’,’node_modules’],<br>可以直接在页面中import ‘.src/components’里面的模块，不用再写相对路径</p>
<h2 id="descriptionFiles"><a href="#descriptionFiles" class="headerlink" title="descriptionFiles"></a>descriptionFiles</h2><p>配置第三方模块名<br>配置：字符串数组</p>
<h2 id="enforceExtension"><a href="#enforceExtension" class="headerlink" title="enforceExtension"></a>enforceExtension</h2><p>是否强制导入语句中必须带后缀<br>true:必须带<br>false:不用必须带</p>
<h2 id="enforceModuleExtension"><a href="#enforceModuleExtension" class="headerlink" title="enforceModuleExtension"></a>enforceModuleExtension</h2><p>只对node_module文件夹下模块生效<br>通常设置false，与enforceExtension：true配合，兼容第三方模块，使用时不加后缀</p>
<h1 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h1><p>扩展插件，在webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果或者做一些自定义的操作<br>比如将css文件单独打包，或者抽离公共模块<br>不使用plugin处理css文件的原理大概是将CSS内容用JS字符串存储起来，在网页执行JS时，通过DOM操作，动态向HTML head标签里插入HTML style标签<br>使用plugin将css抽离，是从打包好的js文件再提取出来<br>配置：plugin实例数组，使用new操作符调用构造函数，同时将参数传递进去<br>例：[new commonsChunkPlugin({name:’common’})]</p>
<h1 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h1><p>配置针对使用webpack-dev-server启动webpack时的一些配置，相当于配置webpack-dev-server<br>devServer 会启动一个http服务器，用于服务网页请求，<br>同时会启动webpack,将webpack构建的文件保存在内存中，在要访问输出的文件时，必须通过HTTP服务访问，<br>同时会开启webpack的监听模式，devServer会让webpack在构建出的js代码里注入一个代理客户端用于控制网页，<br>网页和devServer之间通过webSocket协议通信，以方便devServer主动向客户端发送命令，<br>devServer在收到来自webpack的文件变化通知时，通过注入的客户端控制自动刷新网页，做到实时预览。<br>1.由于devServer不会理会配置的output.path属性，所以获取打包文件时，应该依据HTTP获取，不再依据output.path获取<br>因此要注意使用devServer之后打包文件的获取路径要进行更改。<br>2.index.html因为脱离js模块化系统，webpack不知道它的存在，故，更改index.html，不会被监听到<br>3.除了通过重新刷新整个网页来实现预览，devServer还有一种被称作模块热替换的刷新技术。<br>模块热替换能做到在不重新加载整个网页的情况下，通过将已更新的模块替换老模块，再重新执行一次来实现实时预览。<br>模块热替换相对于默认的刷新机制能提供更快的响应速度和更好的开发体验。<br>可以在执行devServer时加上 –hot开启<br>4.启动webpack时，加上–devtool source-map 可生成souce-map，方便在浏览器中调试源代码</p>
<p>配置<br>hot是否开启热加载<br>inline<br>开启实现实时预览，自动刷新；<br>不开启，使用iframe方式运行开发的网页，需要去localhost:8080/webpack-dev-pack实时预览<br>historyApiFallback:用于H5History API单页应用开发<br>contentBase:devServer HTTP服务器文件根目录<br>headers:在HTTP响应中注入HTTP响应头<br>host:监听地址<br>port:监听端口<br>allowedHosts:只有HTTP请求的HOST在列表中才正常返回<br>disabledHostCheck:是否关闭用于DNS重新绑定的HTTP请求的HOST检查<br>https:是否运行在https上<br>clientloglevel:配置客户端日志等级</p>
<h1 id="target"><a href="#target" class="headerlink" title="target"></a>target</h1><p>构建不同运行环境的代码</p>
<h1 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h1><p>配置：’source-map’,生成source,方便调试</p>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>是否开启监听文件变动模式</p>
<h1 id="watchOption"><a href="#watchOption" class="headerlink" title="watchOption"></a>watchOption</h1><p>配置监听规则</p>
<p>#externals<br>配置哪些模块不用被打包</p>
<h1 id="resolveloader"><a href="#resolveloader" class="headerlink" title="resolveloader"></a>resolveloader</h1><p>配置如何去寻找loader</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack在启动后会从Entry里配置的Moudule开始，递归解析Entry依赖的所有Module，每找到一个module,就会根据配置的loader去找对应的转换规则，&lt;br&gt;对Module进行转换后，在解析当前Module依赖的Module。这些模块会以Entry
    
    </summary>
    
    
      <category term="performance" scheme="http://yoohannah.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>react Native 环境配置</title>
    <link href="http://yoohannah.github.io/post/knowledge/reactNativeCreat.html"/>
    <id>http://yoohannah.github.io/post/knowledge/reactNativeCreat.html</id>
    <published>2019-03-03T03:16:37.000Z</published>
    <updated>2019-03-03T03:54:33.572Z</updated>
    
    <content type="html"><![CDATA[<p>其实按照官网一步一步来就好了，也不用翻墙，基本上，就是耗时间<br>我配置的是window android环境<br><a href="https://reactnative.cn/docs/getting-started.html" target="_blank" rel="external">中文文档</a><br>1.安装node<br>可以直接使用nvm安装，但版本必须是8.<em>或者10.</em><br>带来的问题是，nvm切换版本后，npm可能找不到，可以直接用全局安装的yarn代替<br><a href="http://yuanhehe.cn/2017/06/11/npm-%E4%B8%8E-Yarn-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/" target="_blank" rel="external">npm 与 Yarn 常用命令对比</a><br>或者直接将npm文件夹从能用的版本移到不能用的版本</p>
<p>2.python2<br>官网说不支持Python3.X,因为很早之前安装的python没管，今天一看是3.*，能跑起来</p>
<p>3.JDK<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">下载地址</a><br>我下载的这个<br><img src="/image/native1.png" alt="native1"><br>安装过程注意，jdk和jre使用不同文件夹<br><a href="https://jingyan.baidu.com/article/6dad5075d1dc40a123e36ea3.html" target="_blank" rel="external">安装与环境配置</a><br>4.Android Studio<br>按文档步骤安装好后，需要先创建项目再创建虚拟机<br>构建虚拟机过程文档应该需要翻墙，但其实可以直接百度<br><a href="https://jingyan.baidu.com/article/3aed632edf252e701080911f.html" target="_blank" rel="external">构建虚拟机</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实按照官网一步一步来就好了，也不用翻墙，基本上，就是耗时间&lt;br&gt;我配置的是window android环境&lt;br&gt;&lt;a href=&quot;https://reactnative.cn/docs/getting-started.html&quot; target=&quot;_blank&quot; rel
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>多请求loading处理</title>
    <link href="http://yoohannah.github.io/post/knowledge/loadingcount.html"/>
    <id>http://yoohannah.github.io/post/knowledge/loadingcount.html</id>
    <published>2019-03-03T01:53:37.000Z</published>
    <updated>2019-03-03T03:06:45.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目中所有http请求走同一个全局公共函数，函数参数为：请求方法，url, 请求参数，回调函数以及是否需要加loading的一个布尔值</p>
<p>一般情况下都需要加loading，所以第5个参数一般不填，默认为true,需要加loading<br>不加loading的情况也有，例如下载一个文件的过程，如果是由前端来组装文件流，这个时候是不加loading的</p>
<p>loading效果的添加是通过jquery判断有没有loading效果对应的DOM，有的话就先remove再append<br>loading效果的消失通过jquery remove掉相关DOM元素</p>
<p>即在全局公共函数发出http请求前，根据第5个参数，添加loading，请求结束后取消loading</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一个配置页面，跳转过来时需要加载多项数据进行初始化，而且数据之间有一定关联<br>比如，异步请求A,B,C,D四个数据，请求完D之后，在回调函数中，需要根据D数据发出请求E，再根据E返回数据请求F<br>导致的现象是，ABCD数据回来比较快，然后loading消失，发出E时loading重现，消失和重现时间距离较短，<br>造成页面闪烁</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>加载ABCDEF请求loading仅显示一次，消失一次</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>1.其实本身发出ABCD四个异步请求时也会发生loading问题，即，如果A请求回来的比其他三个早很多，loading会提前结束<br>2.从D返回的数据可能为空这时就不需要去请求E，F请求也就不用发出，同样如果E没数据，也就不要请求F，这时候loading在哪结束需要判断</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>1.在加载loading和消失loading时，添加一层计数，加载loading，计数count加1，消失loading计数count减1，当count减为0时，loading再消失<br>这样就可以解决异步请求loading提前消失<br>2.D请求完才会发出E请求，这时如果ABC请求早已结束，count已经被减为0 ，会重新开始计数，loading会重现造成闪烁，还是不能解决直接问题，<br>解决办法就是,在请求回来时，利用settimeout包裹计数减1,loading消失过程，先执行回调函数再减1，<br>这样，如果D有数据，count会因为要发请求E先加1，然后执行settimeout减1，这样loading就不会因为减到1而消失<br>如果    D没数据不发出请求E，同步执行完回调函数后，执行settimeout减1，count减到0，loading消失</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>回调函数中，有同事代码编写存在BUG，比如没有判断对象是否存在直接去使用其身上的属性值，这样的error会在请求的catch中被捕捉到，<br>因为请求发生错误，状态码非200都会被捕捉到catch中，这时也需要将loading关闭，<br>这样就会造成在回调函数发生错误时，count被减了两次，第一次是请求正常回来时，第二次是回调函数发生错误在catch中被减1，<br>这样count就被减成了小于0，之前的判断以及count等于0，loading消失不再适用，<br>因此将判断界限定为小于1即loading消失，进行容错处理</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目中所有http请求走同一个全局公共函数，函数参数为：请求方法，url, 请求参数，回调函数以及是否需要加loading的一个布尔值&lt;/p
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS3样式的一点小结</title>
    <link href="http://yoohannah.github.io/post/knowledge/css3.html"/>
    <id>http://yoohannah.github.io/post/knowledge/css3.html</id>
    <published>2019-02-21T14:27:58.000Z</published>
    <updated>2019-02-27T00:10:28.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h1><p>会覆盖border属性设置的边框样式<br>原理依据border-image-slice将图片切成九宫格<br><img src="/image/borderOri.jpg" alt="borderOri"><br>EFGH位于边框四角，不参与拉伸或重复<br>ABCD分别在各自所在边上进行拉伸或者重复<br>I不参加修饰</p>
<h2 id="border-image-source"><a href="#border-image-source" class="headerlink" title="border-image-source"></a>border-image-source</h2><p>图片地址<br>格式url(imgurl) </p>
<h2 id="border-image-slice"><a href="#border-image-slice" class="headerlink" title="border-image-slice"></a>border-image-slice</h2><p>从距离top，right,bottom,left边多少切割图片，切4刀，形成9宫格<br>可为数字(图像的像素（位图图像）或向量的坐标（如果图像是矢量图像）)/百分数(水平/垂直偏移图像宽度的百分之多少)<br>不设置时，图片整体位于边框四角。<br>一个值时表示4个距离一致；两个值表示垂直方向两刀和水平两刀距离相同，四个值表示距离四个边各自的距离<br>特殊情况，<br>如果距上下边的长度等于高的一半，即在图片水平中线来一刀，则BD两个切片不会被切出来，左右边框会因为没有切片覆盖显示background-color<br>同理，距左右边的长度等于宽的一半，在图片垂直中线来一刀，则AC两个切片不会被切出来，上下边框会因为没有切片覆盖显示background-color<br>所以如果仅装饰边框4个角，可以采用距离边等于宽高一半的方法切割图片</p>
<h2 id="border-image-repeat"><a href="#border-image-repeat" class="headerlink" title="border-image-repeat"></a>border-image-repeat</h2><p>水平边要不要repeat 垂直边要不要repeat 默认拉伸<br>可取值：stretch 默认拉伸；repeat 重复切片；round;重复切片，但会适当调整大小，避免出现半截图片<br><img src="/image/borderimg.jpg" alt="borderimg"><br><img src="/image/borderimg1.jpg" alt="borderimg1"></p>
<h1 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h1><p>设置边框外圆半径<br>5px ———— 4个角都设半径为5px的圆形圆角<br>5px/10px  ———— 4个角都设水平半径为5px，垂直半径为10px的椭圆形圆角<br>5px 10px  左上和右下角半径5px圆形，右上和左下半径10px的圆形圆角<br>5px 10px 20px  左上角半径5px圆形，右上和左下半径10px的圆形,右下角半径20px圆形圆角<br>5px 10px 20px 15px 左上角半径5px圆形，右上半径10px的圆形,右下角半径20px圆形,左下15p圆形圆角<br>5px 10px 20px 15px/10px 15px 25px 20px 四个角同时设置椭圆型圆角</p>
<p>当半径值小于等于边框border宽度时，border内部不会具有圆角效果，内圆半径=外圆半径-边框宽度<br>若相邻边宽不同，则角会从宽边平滑到窄边<br>表格table设置圆角时，只有将border-collapse:separate时才正常显示<br>如果想取消原有圆角设置，可以将对应值设置为0<br>特殊应用：直接通过设置容器长宽和border-radius绘制圆形，半圆，扇形，椭圆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">width:300px</div><div class="line">height:300px</div><div class="line">border-radius:150px;//圆形</div><div class="line">border-radius: 0 300px 0px 0px;//扇形</div><div class="line"></div><div class="line">width:600px</div><div class="line">height:300px</div><div class="line">border-radius:150px;//椭圆形</div><div class="line">border-radius: 300px 300px 0px 0px;//半圆</div></pre></td></tr></table></figure></p>
<h1 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h1><p>content-box  ———— 元素width代表内容宽度<br>border-box   ————  元素width = border+padding + 内容宽度</p>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>容器能否拖拽以及拖拽方式<br>none | both | horizontal | vertial | inherit</p>
<h2 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h2><p>相当于border,但不占文档流，不破坏布局<br>颜色 样式 宽度 偏移</p>
<h2 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h2><p>边框阴影，由多个值配置<br>insert ？ 水平方向偏移（正右负左）垂直偏移（正下负上）模糊半径 伸缩半径(相当于阴影宽度)<br>设置insert时，设置内阴影，不设时，设置外阴影<br>内阴影用在img标签上无效<br>实例应用<br>1.单边阴影<br>box-shadow:red 0px -5px 5px -3px,给top边设置了阴影，通过设置伸缩半径-3px防止其他边模糊半径5px效果<br>2.四边阴影<br>box-shadow:0 0 10px red;//10px为模糊半径<br>box-shadow:0 0 0 10px red;//10px为伸缩半径,此效果相当于设置了一个宽10px的红边，但不占文档流<br>层级关系：外阴影—&gt;背景色—&gt;背景图—&gt;内阴影—&gt;边框<br>3.多层阴影<br>每组用逗号隔开，靠前的设置面积（伸缩半径）太大的话会遮盖之后的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//彩虹色</div><div class="line">box-shadow: red 0px 0px 10px 10px, inset orange 0px 0px 10px 15px, inset yellow 0px 0px 10px 30px, inset green 0px 0px 10px 45px, inset blue 0px 0px 10px 60px, inset purple 0px 0px 10px 75px;</div></pre></td></tr></table></figure></p>
<h1 id="text-shadow"><a href="#text-shadow" class="headerlink" title="text-shadow"></a>text-shadow</h1><p>水平方向偏移(正右负左) 垂直偏移(正下负上) 模糊半径 颜色(位置随意)</p>
<h2 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a>text-overflow</h2><p>超出容器是否显示省略号<br>使用条件<br>width：500px;容器有具体宽度<br>overflow: hidden;超出隐藏<br>white-space: nowrap;//禁止换行</p>
<h2 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h2><p>长单词url换行<br>normal 默认，半角空格/连字符地方换行,长文本UrL会伸到容器外<br>break-word 在边界换行，不截断英文单词</p>
<h2 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h2><p>自动换行处理方法<br>normal 默认，整字，英文单词整个换行<br>break-all 可截断单词换行<br>keep-all 不允许断开换行，chrome，safari不支持</p>
<h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><p>页面显示与html文本书写格式处理<br>normal 根据容器宽度换行，连续空格合并成一个<br>pre 空白换行跟html书写格式一致，行为类似pre标签<br>nowrap 不换行，连续空格合并成一个，超出容器尺寸按容器overflow处理<br>pre-line 换行跟html书写格式一致，续空格合并成一个<br>pre-wrap  保留空白，正常换行，与pre区别在于pre标签对一些符号上的支持和规范</p>
<h2 id="文本换行"><a href="#文本换行" class="headerlink" title="文本换行"></a>文本换行</h2><p>1.pre标签自动换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pre&#123;</div><div class="line">    white-space:pre;</div><div class="line">    word-wrap:break-word</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.td自动换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">table&#123;</div><div class="line">    table-layout:fixed;</div><div class="line">    width:***px;</div><div class="line">&#125;</div><div class="line">table td&#123;</div><div class="line">    overflow:hidden;</div><div class="line">    word-wrap:break-word;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.除以上两种标签自动换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">element&#123;</div><div class="line">    overflow:hidden;</div><div class="line">    word-wrap:break-word;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.标签内容强制不换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">element&#123;</div><div class="line">    white-space:nowrap;</div><div class="line">    word-break:keep-all;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h1><p>背景图是否随页面滚动条滚动，始终不会随容器滚动条滚动<br>scroll ———— 滚动<br>fixed ———— 不滚动</p>
<h1 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h1><p>1.起始位置<br>background-color始终从border与margin交界线的左上角(用A表示)开始<br>background-image默认从padding与border交界线的左上角(用B表示)开始,但是可以通过设置background-position决定起始点<br>2.在Z轴上，覆盖顺序<br>background-color ——&gt; background-image ——&gt; border,conten的背景色<br>background-repeat值为repeat和no-repeat时,对覆盖有不同影响</p>
<h2 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h2><p>图片比容器小时，重复方式<br>no-repeat ———— 仅从B点开始铺一次,background-image不会填充border部分的background-color,图片不够大时会显示background-color<br><img src="/image/bgimg2.png" alt="bgimg2"><br>repeat ———— 从B点开始,先垂直重复，再整体水平重复，background-image会覆盖border部分的background-color,图片起点还是B,然后垂直重复,整体水平重复<br><img src="/image/bgimg1.png" alt="bgimg1"><br>repeat-x ———— 从B点开始，仅水平重复，不再整体垂直重复，覆盖border<br>repeat-y ———— 从B点开始，仅垂直重复，不再整体水平重复,覆盖border</p>
<h2 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h2><p>背景图片开始位置在padding与border交界线什么地方<br>两个值为长度或者百分数时，第一个值表示容器水平方向的位置，相对于left边位置；第二个值表示容器垂直方向的位置，相对于TOP边位置，可以混用<br>但只设一个值时，表示距离left位置，垂直方向默认为居中<br>两个值为关键字时，left,right,center表示水平位置，top,bottom,center表示垂直位置，<br>前后位置可随意，left bottom 等于 bottom left<br>仅设置一个值时，另一个方向默认center,例left 相当于left center,背景图位于左边垂直中间位置；center，即水平垂直居中<br><img src="/image/bgimg3.png" alt="bgimg3"></p>
<h2 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h2><p>同样可以重置图片开始位置，指定居于哪条线，<br>同时指定background-position时，先根据background-origin确定线，依线根据background-position确定位置<br>border-box ———— margin与border交界线<br>padding-box ———— border与padding交界线,默认值<br>content-box ———— padding与内容块交界线</p>
<h2 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h2><p>设置背景色background-color铺设范围<br>border-box ———— 从margin与border交界线开始铺<br>padding-box ———— 从border与padding交界线开始铺<br>content-box ———— 从padding与内容块交界线开始铺</p>
<h2 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h2><p>以background-origin设置的值为容器,设置图片大小<br>auto 原始尺寸<br>具体长度值1个或2个<br>百分数1个或2个 相对容器的百分之多少，不是图片大小<br>contain 放大，铺满容器<br>cover 按照图片宽高比例，缩放</p>
<h2 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h2><p>透明度：0-1的值，值越小越透明<br>表示颜色的rgba,hsla的第四位都表示透明度，取值同opacity</p>
<h2 id="linear-gradient"><a href="#linear-gradient" class="headerlink" title="linear-gradient"></a>linear-gradient</h2><p>线性渐变,用于background-image<br>到达方向，开始颜色，（中间过渡色，）结束颜色<br>到达方向：to left 从右到左；to top left 从右下到左上角；xx deg，使用角度正值顺时针，负值逆时针<br>颜色名后空格加百分数，百分数指色标，色标即颜色在整个距离上开始的位置</p>
<h2 id="radical-gradient"><a href="#radical-gradient" class="headerlink" title="radical-gradient"></a>radical-gradient</h2><p>径向渐变，用于background-image<br>半径 （形状）（at 圆心位置），开始颜色，（中间过渡色，）结束颜色<br>半径：两值相同即为圆形渐变，否则为椭圆渐变；<br>距离容器中心 closed-side 最近边| closed-corner 最近角| farthest-side 最远边| farthest-corner最远角距离<br>形状： circle | ellipse<br>圆心位置：left bottom |100px 200px |20% 15% 默认center</p>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><h2 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h2><p>重置变形函数作用起点，但translate()移动函数始终以元素中心点进行位移<br>left bottom | 20% 10%</p>
<h2 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h2><p>子元素以2D还是3D形式处理变换过程<br>flat :2D<br>present-3d: 3D<br>如果同时有设置overflow：hidden,那么设置present-3d不生效，相当于flat</p>
<h2 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h2><p>父元素是否呈现3d效果，这越小3D效果越明显，none不显示</p>
<h2 id="perspective-origin"><a href="#perspective-origin" class="headerlink" title="perspective-origin"></a>perspective-origin</h2><p>perspective 原点，从哪个点开始呈现3d效果</p>
<h2 id="perspective-1"><a href="#perspective-1" class="headerlink" title="perspective()"></a>perspective()</h2><p>用于子元素，参数大于0时，激活3d效果</p>
<h2 id="back-visibility"><a href="#back-visibility" class="headerlink" title="back-visibility"></a>back-visibility</h2><p>旋转180度，背面是否显示为正面的镜面效果，visible | hidden<br>3D表示是否透视</p>
<h2 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h2><p>可在transform中空格隔开同时使用多个<br>2D<br>位移<br>translate(<em> |X,Y) X正值为向右，Y正值为向下<br>translateX(</em>）<br>translateY(<em>）<br>放缩<br>scale(</em> |X,Y) 0-1缩小，大于1放大，取负值时，先翻转再放缩<br>scaleX(<em>）<br>scaleY(</em>）<br>旋转<br>rotate(<em>)角度值，顺时针正，逆时针负<br>倾斜<br>skew(</em> |X,Y) 水平 垂直方向倾斜<br>skewX(<em>)<br>skewY(</em>)</p>
<p>3D<br>位移<br>translate3d(X,Y,Z) X正值为向右，Y正值为向下<br>translateZ(<em>）<br>放缩<br>scale3d(</em> |X,Y,Z) 0-1缩小，大于1放大，取负值时，先翻转再放缩<br>scaleZ(<em>）<br>旋转<br>rotate3d(X,Y,Z,角度)X,Y,Z值为0-1，表示绕轴旋转的矢量值，角度值，顺时针正，逆时针负<br>rotateX(</em>)<br>rotateY(<em>)<br>rotateZ(</em>)</p>
<p>以上功能都能让矩阵函数表示<br>2d时使用matrix()<br>3d时使用matrix3d()</p>
<h1 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h1><p>过度属性(css样式)none/all，具备过渡效果的属性，color,阴影，渐变<br>过渡时间 s/ms 整个变化持续时间<br>过度函数 ease|linear|ease-in|ease-out|ease-in-out|step,以上函数表示以什么样的速度变化，都可以用三次贝塞尔曲线实现<br>延迟时间 s/ms 变化延迟多长时间再开始，赋值为负值时，立即开始，之前的变换被截断<br>配置多项时，每组配置逗号隔开<br>终状态一般定义于各种触发伪类：hover,active,focus,checked<br>或者根据媒体查询结果</p>
<h1 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h1><p>定义动画每一帧样式<br>@keyframes 取个名字apple{<br>   0%{动画第一帧样式}<br>   各种百分数{动画过渡帧样式}<br>   100%{动画最后一帧样式}<br>}</p>
<h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><p>animation各个子属性<br>animation-name:@keyframes声明的动画帧的名字，例如apple<br>animation-duration:播放一遍的时间<br>animation-timing-function:播放方式<br>animation-delay:延迟多长时间再播放<br>animation-iteration-count:播放次数<br>animation-direction:倒放还是正放动画normal正放alternate倒放<br>animation-play-state:播放状态running播放|paused暂停<br>animation-fill-mode:结束定格在哪一帧</p>
<h1 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h1><p>媒体查询<br>@media 10种媒体类型 and (13种设备特性) and (13种设备特性){样式}</p>
<h1 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h1><p>从服务器加载字体类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@font-face&#123;</div><div class="line">    font=family:xxx;</div><div class="line">    src:url()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;border-image&quot;&gt;&lt;a href=&quot;#border-image&quot; class=&quot;headerlink&quot; title=&quot;border-image&quot;&gt;&lt;/a&gt;border-image&lt;/h1&gt;&lt;p&gt;会覆盖border属性设置的边框样式&lt;br&gt;原理依据bord
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>探索flex布局</title>
    <link href="http://yoohannah.github.io/post/knowledge/css3flex.html"/>
    <id>http://yoohannah.github.io/post/knowledge/css3flex.html</id>
    <published>2019-01-31T23:54:58.000Z</published>
    <updated>2019-02-21T14:16:19.709Z</updated>
    
    <content type="html"><![CDATA[<p>flex布局<br>盒状弹性布局，盒子大小可以随容器大小变化</p>
<h1 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h1><p><b>display</b>  决定开始作为弹性容器</p>
<p>—— flex : 将容器设置为弹性伸缩容器<br>—— inline-flex :使弹性容器成为单个不可分的行内级元素<br>注意，columns属性此时在flex容器上不在有效果</p>
<p><b>flex-direction</b> 决定主轴方向<br>—— row:水平向右，子模块书写顺序横向排列，开头的放在最左端,子模块不设宽度情况下宽度由内容决定<br>—— row-reverse:水平向左，子模块书写顺序横向排列，开头的放在最右端，子模块不设宽度情况下宽度由内容决定<br>—— column:从上到下，子模块书写顺序纵向排列，开头的放在最上面，子模块不设高度情况下高度由内容决定<br>—— column-reverse:从下到上，子模块书写顺序纵向排列，开头的放在最下面，子模块不设高度情况下高度由内容决定<br><img src="/image/flex1.png" alt="flex1"></p>
<p><b>flex-wrap</b> 对于子模块是否超出最大宽度或高度时要不要换行/列，默认不换行/列,宽/高度自动按所有模块比例缩小<br>—— nowrap:默认值<br>—— wrap:换行,水平排列的子模块多出的部分沿column方向排第二行;纵向排列的子模块多出的部分沿row方向排第二列;<br>—— wrap-reverse:换行，水平排列的子模块多出的部分沿column-reverse方向排第二行；纵向排列的子模块多出的部分沿row-reverse方向排第二列;<br><img src="/image/flex2.png" alt="flex2.png"><br><img src="/image/flex3.png" alt="flex3.png"><br><img src="/image/flex4.png" alt="flex4.png"></p>
<p><b>flex-flow</b> :[flex-direction][flex-wrap]flex-direction和 flex-wrap的复合属性,<br>先按flex-direction排列，超出部分用flex-wrap决定<br><img src="/image/flex5.png" alt="flex5.png"></p>
<p><b>justify-content</b> 在剩余子模块允许换行或者有剩余宽度或者高度时相对主轴的对齐方式，超出但不换行时，按比例放缩<br>—— center：按实际间距位于主轴中心<br>—— flex-start:按实际间距位于主轴开始排列的位置，第一个贴边<br>—— flex-end :按实际间距和顺序向主轴方向排列，最后一个贴边<br>—— space-between ：第一个和最后一个挨着边框，其它间距相等<br>—— space-around：第一个和最后一个离边框距离为子模块间距的一半<br>处理主轴为侧轴的布局时,设置了具体高度才会生效<br><img src="/image/flex6.png" alt="flex6.png"></p>
<p><b>align-items</b> 子模块整体相对侧轴的位置,row和row-reverse侧轴为column,column和column-reverse侧轴为row<br>—— center：侧轴中心<br>—— flex-start:侧轴起点位置<br>—— flex-end :侧轴终点位置<br>—— stretch：侧轴方向属性值未设置时，拉伸子模块该属性为容器对应属性值，弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。<br>—— baseline:所有模块的内容第一行对齐<br><img src="/image/flex7.png" alt="flex7.png"></p>
<p><b>align-content</b> 决定多行或者多列在侧轴排列方式，row和row-reverse侧轴为column,column和column-reverse侧轴为row<br>—— center：整体在侧轴中心<br>—— flex-start:整体在侧轴起点位置<br>—— flex-end :整体在侧轴终点位置<br>—— stretch：侧轴方向属性值未设置时，拉伸子模块该属性填满容器对应属性值<br>—— space-between ：第一行/列和最后一行/列挨着边框，其它间距相等<br>—— space-around:第一行/列和最后一行/列离边框距离为子模块间距的一半<br><img src="/image/flex8.png" alt="flex8.png"></p>
<h1 id="模块属性"><a href="#模块属性" class="headerlink" title="模块属性"></a>模块属性</h1><p><b>align-self</b>  自己决定相对侧轴的位置<br>属性值同align-items,默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<p><b>order</b> 决定模块排列顺序，值越大，越最后被排列</p>
<p><b>flex-grow</b> 放大比例，当容器空间有剩余时按此比列分配内存空间，填满，比如<br>宽度1000px的容器，4个子模块一共占了800，剩200，4个模块该值分别设为2 ：1：1：1，<br>则200被分为5份，一份40，每个模块按比例 分别拿80，40，40，40 放大自己的面积</p>
<p><b>flex-shrink</b> 缩小比例，当容器空间有不足时按此比列分配缩小子模块，比如<br>容器宽800，5个模块需要占1000，差200，5个模块该值比为4：1：1：1：1，<br>则200被分为8份，一份25，，每个模块按比例分别减少100，25，25，25，25 缩小自己的面积</p>
<p><b>flex-basis</b> 在分配多余空间/缩小之前，项目占据的主轴空间，用于计算一共需要多少空间时放大还是缩小<br>auto 默认值，子模块本来大小</p>
<p><b>flex</b>  ：none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] 以上三项复合属性</p>
<p>一些特殊flex 值的表现情况<br>flex:auto | 1 1 auto;  空间充裕时，模块等比例分配多余空间进行扩展；空间不足时，模块等比例缩小<br>flex:none | 0 0 auto;  不论空间是否充裕，模块大小根据自身设置的尺寸不变，间距变化<br>flex:initial | 0 1 auto | 0 auto; 空间即使充裕也保持原始大小，但空间不足时，模块等比例缩小<br>flex:正值； 模块可根据空间大小收缩，同时多个模块设置时，以该值作为比例进行收缩，放大比等于缩小比</p>
<p>注意，float,clear和vertical-align在伸缩项目上没有效果<br><a href="https://yoohannah.github.io/post/knowledge/layouts.html">flex 实现 圣杯布局</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;flex布局&lt;br&gt;盒状弹性布局，盒子大小可以随容器大小变化&lt;/p&gt;
&lt;h1 id=&quot;容器属性&quot;&gt;&lt;a href=&quot;#容器属性&quot; class=&quot;headerlink&quot; title=&quot;容器属性&quot;&gt;&lt;/a&gt;容器属性&lt;/h1&gt;&lt;p&gt;&lt;b&gt;display&lt;/b&gt;  决定开始作为弹性
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Slot复用</title>
    <link href="http://yoohannah.github.io/post/vue/vueSlot.html"/>
    <id>http://yoohannah.github.io/post/vue/vueSlot.html</id>
    <published>2019-01-13T08:38:15.000Z</published>
    <updated>2019-01-13T06:18:17.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目列表组件需要实现点击自动增加一行,可展示自定义内容的可扩展内容<br>列表table组件被应用在page组件，page组件被应用在具体业务页面，slot的具体内容在业务页面传递进去<br><img src="/image/tableextend1.png" alt="tableextend1"><br>问题难点<br>1.多层组件slot传递<br>2.同一个slot在table组件中循环使用在多处时，不会被渲染</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>1.slot 只能一层一层传递，所以解决多层传递，就是在page层应用table时，增加slot接收业务页面传递进来的slot具体内容<br>2.同名slot不能在同一组件被重复渲染，即不允许有重名slot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">重名的 Slots 移除</div><div class="line">同一模板中的重名 &lt;slot&gt; 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用 prop 来传递。</div></pre></td></tr></table></figure></p>
<h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><h2 id="多层组件slot传递"><a href="#多层组件slot传递" class="headerlink" title="多层组件slot传递"></a>多层组件slot传递</h2><p>在page层使用table组件时将&lt;slot&gt;&lt;/slot&gt;放在table组件中，将slot内容当作table的slot传递给table<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">1.业务页面具体自定义内容传入</div><div class="line">&lt;PageComponent :pageConfig=&quot;pageConfig&quot; ref=&quot;child&quot;&gt;</div><div class="line">    &lt;div slot=&apos;tableExtend&apos;&gt;</div><div class="line">    &lt;extendTable :detailConfig=&quot;pageConfig.table.isExtend.detailConfig&quot;</div><div class="line">        v-if=&quot;pageConfig.table.isExtend.detailConfig[0].data.length&gt;0&quot;&gt;</div><div class="line">    &lt;/extendTable&gt;</div><div class="line">    &lt;div style=&quot;padding: 10px;&quot; v-if=&quot;pageConfig.table.isExtend.detailConfig[0].data.length === 0&quot;&gt;暂无数据&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/PageComponent&gt;</div><div class="line"></div><div class="line">2.page组件table部分</div><div class="line">&lt;section class=&quot;page-table&quot;&gt;</div><div class="line">    &lt;tableTemp :table=&quot;pageConfig.table&quot; :pageConfig=&quot;pageConfig&quot; @sendIds=&quot;receiveIds&quot; ref=&quot;refTest&quot;&gt;</div><div class="line">        &lt;slot :name=&apos;pageConfig.table.isExtend.slot&apos; v-if=&quot;pageConfig.table.isExtend&quot;&gt;&lt;/slot&gt; //将slot放在这里</div><div class="line">    &lt;/tableTemp&gt;</div><div class="line">&lt;/section&gt;</div><div class="line">3.table部分</div><div class="line"> 利用template实现列表行和扩展行一对一</div><div class="line"> &lt;template v-for=&quot;(value,index) in table.tableData&quot;&gt; </div><div class="line">    &lt;tr :key=&quot;index&quot;&gt;</div><div class="line">        &lt;td v-for=&quot;(val,i) in table.tableEle&quot; v-if=&quot;val.display&quot; :key=&quot;i&quot;&gt;</div><div class="line">            &lt;div class=&quot;extendStyle&quot; v-if=&apos;table.isExtend &amp;&amp; i==firstShow&apos;&gt;</div><div class="line">                &lt;a v-show=&quot;index != currentActive&quot; @click=&quot;loadDetail(value,index)&quot;&gt;&lt;i class=&quot;ivu-icon ivu-icon-ios-arrow-forward&quot;&gt;&lt;/i&gt;&lt;/a&gt; //loadDetail去调父组件函数获取详情数据</div><div class="line">                &lt;a v-show=&quot;index === currentActive&quot; @click=&quot;loadDetail(value,index)&quot; class=&quot;active&quot;&gt;&lt;i class=&quot;ivu-icon ivu-icon-ios-arrow-forward&quot;&gt;&lt;/i&gt;&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">            &lt;div v-if=&apos;!table.isExtend&apos;&gt;</div><div class="line">            ...</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">    //在组装行的时候增加备用扩展行，利用第三方变量控制扩展行显示隐藏</div><div class="line">    &lt;tr v-if=&quot;index === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt;  </div><div class="line">        &lt;td :colspan=&apos;tdNumber&apos; id=&apos;extend1&apos;&gt;//合并单元格</div><div class="line">            &lt;slot :name=&apos;table.isExtend.slot&apos;&gt;&lt;/slot&gt;//直接这样是不能渲染的，因为这样通过循环会出现多个同名slot</div><div class="line">        &lt;/td&gt;</div><div class="line">    &lt;/tr&gt;</div><div class="line">&lt;/template&gt; </div><div class="line">//去调父组件函数获取详情数据</div><div class="line">loadDetail(item, index) &#123;</div><div class="line">    this.currentActive = this.currentActive === index ? -1 : index</div><div class="line">    this.$store.commit(&apos;changeTableExtendActive&apos;,this.currentActive)</div><div class="line">    if(this.currentActive === -1)&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    let func = this.pageConfig.table.isExtend.func</div><div class="line">    this.$parent.$parent[func](item,index)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h2 id="slot重用"><a href="#slot重用" class="headerlink" title="slot重用"></a>slot重用</h2><h3 id="方法一-作用域插槽"><a href="#方法一-作用域插槽" class="headerlink" title="方法一 作用域插槽"></a>方法一 作用域插槽</h3><p>在子组件中将slot中用到的数据传递给slot标签的data属性,<br>父组件借助slot-scope属性,获取子组件中slot标签的data属性传递的数据<br>即可应用在slot模板中，另外slot模板中如果用到点击事件回调函数，可以直接在父组件中定义，直接调用</p>
<p>注意slot-scope绑定的变量在使用时,子组件传递的实际值被包含在一个data属性中，所以需要通过slotscope.data.xxxxx去获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">爷爷组件</div><div class="line">&lt;PageComponent :pageConfig=&quot;pageConfig&quot; ref=&quot;child&quot;&gt;</div><div class="line">    &lt;template slot-scope=&quot;isExtend&quot;&gt;</div><div class="line">        &lt;extendTable :detailConfig=&quot;isExtend.data.detailConfig&quot; //包含的data中</div><div class="line">            v-if=&quot;isExtend.data.detailConfig[0].data.length&gt;0&quot;&gt;</div><div class="line">        &lt;/extendTable&gt;</div><div class="line">        &lt;div style=&quot;padding: 10px;&quot; v-if=&quot;isExtend.data.detailConfig[0].data.length === 0&quot;&gt;暂无数据&lt;/div&gt;</div><div class="line">    &lt;/template&gt;</div><div class="line">&lt;/PageComponent&gt;</div><div class="line">父组件</div><div class="line">&lt;section class=&quot;page-table&quot;&gt;</div><div class="line">    &lt;tableTemp :table=&quot;pageConfig.table&quot; :pageConfig=&quot;pageConfig&quot; @sendIds=&quot;receiveIds&quot; ref=&quot;refTest&quot;&gt;</div><div class="line">        &lt;slot :data=&apos;pageConfig.table.isExtend&apos; v-if=&quot;pageConfig.table.isExtend&quot;&gt;&lt;/slot&gt;</div><div class="line">    &lt;/tableTemp&gt;</div><div class="line">&lt;/section&gt;</div><div class="line">子组件</div><div class="line">&lt;tr v-if=&quot;index === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt; </div><div class="line">    &lt;td :colspan=&apos;tdNumber&apos; id=&apos;extend1&apos;&gt;</div><div class="line">        &lt;slot :data=&apos;table.isExtend&apos;&gt;&lt;/slot&gt; //直接使用</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<h3 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h3><p>一个业务场景需要同时渲染多个table,即通过一次配置，可渲染多个table的组件，<br>一个同事将循环table的逻辑放在了table组件本身里面，造成table本身是一个可循环输出多个table的组件<br>这样如果一开始在爷爷组件放入多个具名slot,因为不能在子组件slot标签添加name属性（会循环出同名slot），<br>那所有的slot都会出现在每一个table组件中<br>因此有了方法二<br><img src="/image/tableextend2.png" alt="tableextend2"></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>利用page层传递slot到table组件思想，在table中使用slot时，将其包裹在一个新组件中，<br>利用新组件复用，实现slot组件复用，(相当于将slot传递到新组件——-&gt;待查原理)<br>而新组件通过render函数依据slot节点生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">子组件</div><div class="line"> &lt;tr v-if=&quot;(indexx+&apos;-&apos;+index) === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt;</div><div class="line">    &lt;td :colspan=&apos;itemConfig.config.length&apos;&gt;</div><div class="line">        &lt;!-- slot标签要放在tdslot标签充当slot,否则详情数据拉回来之后不会进行更新组件 --&gt;</div><div class="line">        &lt;tdSlot :name=&apos;itemConfig.isExtend.slot&apos;&gt; &lt;slot :name=&apos;itemConfig.isExtend.slot&apos;&gt;&lt;/slot&gt; &lt;/tdSlot&gt;</div><div class="line">        &lt;!-- tdslot在main.js中定义 --&gt;</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">loadDetail(item, indexx, index) &#123;</div><div class="line">    this.currentActive = this.currentActive === indexx+&apos;-&apos;+index ? -1 : indexx+&apos;-&apos;+index //通过多层key判断展开</div><div class="line">    if(this.currentActive === -1)&#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    let func = this.detailConfig[indexx].isExtend.func</div><div class="line">    this.$parent.$parent[func](item,indexx, index)</div><div class="line">&#125;</div><div class="line">新组件带着slot生成</div><div class="line">Vue.component(&apos;tdSlot&apos;, &#123;</div><div class="line"></div><div class="line">  render(createElement) &#123;</div><div class="line">    function deepClone(vnodes, createElement) &#123;</div><div class="line">      function cloneVNode (vnode) &#123;对slot节点进行深度复制</div><div class="line">        const clonedChildren = vnode.children &amp;&amp; vnode.children.map(vnode =&gt; cloneVNode(vnode))</div><div class="line">        const cloned = createElement(vnode.tag, vnode.data, clonedChildren)</div><div class="line">        cloned.text = vnode.text</div><div class="line">        cloned.isComment = vnode.isComment</div><div class="line">        cloned.componentOptions = vnode.componentOptions</div><div class="line">        cloned.elm = vnode.elm</div><div class="line">        cloned.context = vnode.context</div><div class="line">        cloned.ns = vnode.ns</div><div class="line">        cloned.isStatic = vnode.isStatic</div><div class="line">        cloned.key = vnode.key</div><div class="line"></div><div class="line">        return cloned</div><div class="line">      &#125;</div><div class="line">      const clonedVNodes = vnodes.map(vnode =&gt; cloneVNode(vnode))</div><div class="line">      return clonedVNodes</div><div class="line">    &#125;</div><div class="line">    var slots = this.$parent.$slots.default //从父组件拿到slot</div><div class="line">    var slot = null</div><div class="line">    for(let i=0;i&lt;slots.length;i++)&#123;</div><div class="line">      if(slots[i].data &amp;&amp; this.name === slots[i].data.slot)&#123; //多个slot，拿到自己table.isExtend配置的那一个</div><div class="line">        slot = slots[i]</div><div class="line">        break</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    return createElement(&apos;div&apos;,&#123;class:&apos;tdslot&apos;&#125;,deepClone([slot], createElement)) //做一下深度复制</div><div class="line">    &lt;!-- return createElement(&apos;div&apos;,&#123;class:&apos;tdslot&apos;&#125;,[slot]) --&gt; 这样也可以</div><div class="line">  &#125;,</div><div class="line">  props:&#123;</div><div class="line">    name:&#123;</div><div class="line">      type:String,</div><div class="line">      default:&apos;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">父组件</div><div class="line">&lt;detailsTable v-if=&quot;detailPageConfig.detailConfig&quot; :detailConfig=&quot;detailPageConfig.detailConfig&quot;&gt;</div><div class="line">    &lt;slot v-for=&apos;(item,index) in detailPageConfig.detailConfig&apos; v-if=&apos;item.isExtend&apos; :name=&apos;detailPageConfig.detailConfig[index].isExtend.slot&apos; &gt;&lt;/slot&gt;</div><div class="line">&lt;/detailsTable&gt;</div><div class="line">爷爷组件</div><div class="line">&lt;detailsPage :detailPageConfig=&quot;detailPageConfig&quot;&gt;</div><div class="line">    &lt;div slot=&apos;tableExtend-1&apos;&gt; //多个slot 并列写即可</div><div class="line">    &lt;detailsTable :detailConfig=&quot;detailPageConfig.detailConfig[1].isExtend.detailConfig&quot;</div><div class="line">        v-if=&quot;this.detailPageConfig.detailConfig[1].isExtend.detailConfig[0].data.length&gt;0&quot;&gt;</div><div class="line">    &lt;/detailsTable&gt;</div><div class="line">    &lt;div v-if=&quot;this.detailPageConfig.detailConfig[1].isExtend.detailConfig[0].data.length&lt;1&quot;&gt;暂无数据&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/detailsPage&gt;</div></pre></td></tr></table></figure></p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>其实之所以会出现重名slot是因为table的大循环逻辑放在了自己组件内，<br>其实输出多个table的逻辑放在page层即可，table还是独立的table，<br>这样插入slot时就不是同名slot，各自slot,插入各自table<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">父组件</div><div class="line">&lt;template v-for=&apos;(item,index) in detailPageConfig.detailConfig&apos;&gt;</div><div class="line">    &lt;detailsTable :detailConfig=&quot;item&quot; :key=&apos;index&apos;&gt;</div><div class="line">    &lt;slot v-if=&apos;item.isExtend&apos; :name=&apos;item.isExtend.slot&apos; &gt;&lt;/slot&gt;</div><div class="line">    &lt;/detailsTable&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">子组件</div><div class="line">&lt;tr v-if=&quot;index === currentActive&quot; :key=&quot;index+0.5&quot; class=&apos;bgc&apos;&gt;</div><div class="line">    &lt;td :colspan=&apos;detailConfig.config.length&apos;&gt;</div><div class="line">        &lt;slot&gt;&lt;/slot&gt;//只要将自己的slot放进来即可</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<p><a href="https://www.jianshu.com/p/c735cc612e63" target="_blank" rel="external">参考资料</a><br><a href="https://cnodejs.org/topic/58c0ad17d282728c0ec4029a" target="_blank" rel="external">参考资料</a><br><a href="https://segmentfault.com/a/1190000010913794" target="_blank" rel="external">参考资料</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目列表组件需要实现点击自动增加一行,可展示自定义内容的可扩展内容&lt;br&gt;列表table组件被应用在page组件，page组件被应用在具体业
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react 合成事件原理</title>
    <link href="http://yoohannah.github.io/post/react/SyntheticEvent.html"/>
    <id>http://yoohannah.github.io/post/react/SyntheticEvent.html</id>
    <published>2019-01-05T07:37:37.000Z</published>
    <updated>2019-02-11T13:45:57.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h1><h2 id="注册到document"><a href="#注册到document" class="headerlink" title="注册到document"></a>注册到document</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div></pre></td><td class="code"><pre><div class="line">1. reactDOMComponent.js</div><div class="line">export function setInitialProperties(</div><div class="line">  domElement: Element,</div><div class="line">  tag: string,</div><div class="line">  rawProps: Object,</div><div class="line">  rootContainerElement: Element | Document,</div><div class="line">): void &#123;</div><div class="line">  const isCustomComponentTag = isCustomComponent(tag, rawProps);</div><div class="line">  if (__DEV__) &#123; ... &#125;</div><div class="line">  let props: Object;</div><div class="line">  switch (tag) &#123;</div><div class="line">    case &apos;iframe&apos;:</div><div class="line">    case &apos;object&apos;:</div><div class="line">      trapBubbledEvent(TOP_LOAD, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;video&apos;:</div><div class="line">    case &apos;audio&apos;:</div><div class="line">      // Create listener for each media event</div><div class="line">      for (let i = 0; i &lt; mediaEventTypes.length; i++) &#123;</div><div class="line">        trapBubbledEvent(mediaEventTypes[i], domElement); //trapBubbledEvent</div><div class="line">      &#125;</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;source&apos;:</div><div class="line">      trapBubbledEvent(TOP_ERROR, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;img&apos;:</div><div class="line">    case &apos;image&apos;:</div><div class="line">    case &apos;link&apos;:</div><div class="line">      trapBubbledEvent(TOP_ERROR, domElement); //trapBubbledEvent</div><div class="line">      trapBubbledEvent(TOP_LOAD, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;form&apos;:</div><div class="line">      trapBubbledEvent(TOP_RESET, domElement);  //trapBubbledEvent</div><div class="line">      trapBubbledEvent(TOP_SUBMIT, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;details&apos;:</div><div class="line">      trapBubbledEvent(TOP_TOGGLE, domElement); //trapBubbledEvent</div><div class="line">      props = rawProps;</div><div class="line">      break;</div><div class="line">    case &apos;input&apos;:</div><div class="line">      ReactDOMInputInitWrapperState(domElement, rawProps);</div><div class="line">      props = ReactDOMInputGetHostProps(domElement, rawProps);</div><div class="line">      trapBubbledEvent(TOP_INVALID, domElement);  //trapBubbledEvent</div><div class="line">      // For controlled components we always need to ensure we&apos;re listening</div><div class="line">      // to onChange. Even if there is no listener.</div><div class="line">      ensureListeningTo(rootContainerElement, &apos;onChange&apos;); // ensureListeningTo</div><div class="line">      break;</div><div class="line">    case &apos;option&apos;:</div><div class="line">      ReactDOMOptionValidateProps(domElement, rawProps);</div><div class="line">      props = ReactDOMOptionGetHostProps(domElement, rawProps);</div><div class="line">      break;</div><div class="line">    case &apos;select&apos;:</div><div class="line">      ReactDOMSelectInitWrapperState(domElement, rawProps);</div><div class="line">      props = ReactDOMSelectGetHostProps(domElement, rawProps);</div><div class="line">      trapBubbledEvent(TOP_INVALID, domElement);    //trapBubbledEvent</div><div class="line">      // For controlled components we always need to ensure we&apos;re listening</div><div class="line">      // to onChange. Even if there is no listener.</div><div class="line">      ensureListeningTo(rootContainerElement, &apos;onChange&apos;);  // ensureListeningTo</div><div class="line">      break;</div><div class="line">    case &apos;textarea&apos;:</div><div class="line">      ReactDOMTextareaInitWrapperState(domElement, rawProps);</div><div class="line">      props = ReactDOMTextareaGetHostProps(domElement, rawProps);</div><div class="line">      trapBubbledEvent(TOP_INVALID, domElement);  //trapBubbledEvent</div><div class="line">      // For controlled components we always need to ensure we&apos;re listening</div><div class="line">      // to onChange. Even if there is no listener.</div><div class="line">      ensureListeningTo(rootContainerElement, &apos;onChange&apos;); // ensureListeningTo</div><div class="line">      break;</div><div class="line">    default:</div><div class="line">      props = rawProps;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  assertValidProps(tag, props);</div><div class="line"></div><div class="line">  setInitialDOMProperties(</div><div class="line">    tag,</div><div class="line">    domElement,</div><div class="line">    rootContainerElement,</div><div class="line">    props,</div><div class="line">    isCustomComponentTag,</div><div class="line">  );//这个函数中也会用到 ensureListeningTo</div><div class="line"></div><div class="line">  switch (tag) &#123;</div><div class="line">   //给一些DOM标签通过setAttribute赋值</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function setInitialDOMProperties(</div><div class="line">  tag: string,</div><div class="line">  domElement: Element,</div><div class="line">  rootContainerElement: Element | Document,</div><div class="line">  nextProps: Object,</div><div class="line">  isCustomComponentTag: boolean,</div><div class="line">): void &#123;</div><div class="line">    if(...)&#123;</div><div class="line">      ...</div><div class="line">    &#125; else if (registrationNameModules.hasOwnProperty(propKey)) &#123;</div><div class="line">      if (nextProp != null) &#123;</div><div class="line">        if (__DEV__ &amp;&amp; typeof nextProp !== &apos;function&apos;) &#123;</div><div class="line">          warnForInvalidEventListener(propKey, nextProp);</div><div class="line">        &#125;</div><div class="line">        ensureListeningTo(rootContainerElement, propKey); // ensureListeningTo</div><div class="line">      &#125;</div><div class="line">    &#125; else if (nextProp != null) &#123;</div><div class="line">      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function ensureListeningTo(rootContainerElement, registrationName) &#123;</div><div class="line">  const isDocumentOrFragment =</div><div class="line">    rootContainerElement.nodeType === DOCUMENT_NODE ||</div><div class="line">    rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;</div><div class="line">  const doc = isDocumentOrFragment</div><div class="line">    ? rootContainerElement</div><div class="line">    : rootContainerElement.ownerDocument;</div><div class="line">  listenTo(registrationName, doc);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2.ReactBrowerEventEmitter.js</div><div class="line"></div><div class="line">export function listenTo(</div><div class="line">  registrationName: string,</div><div class="line">  mountAt: Document | Element,</div><div class="line">) &#123;</div><div class="line">  const isListening = getListeningForDocument(mountAt);</div><div class="line">  const dependencies = registrationNameDependencies[registrationName];</div><div class="line"></div><div class="line">  for (let i = 0; i &lt; dependencies.length; i++) &#123;</div><div class="line">    const dependency = dependencies[i];</div><div class="line">    if (!(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])) &#123;</div><div class="line">      switch (dependency) &#123;</div><div class="line">        case TOP_SCROLL:</div><div class="line">          trapCapturedEvent(TOP_SCROLL, mountAt);</div><div class="line">          break;</div><div class="line">        case TOP_FOCUS:</div><div class="line">        case TOP_BLUR:</div><div class="line">          trapCapturedEvent(TOP_FOCUS, mountAt);</div><div class="line">          trapCapturedEvent(TOP_BLUR, mountAt);</div><div class="line">          // We set the flag for a single dependency later in this function,</div><div class="line">          // but this ensures we mark both as attached rather than just one.</div><div class="line">          isListening[TOP_BLUR] = true;</div><div class="line">          isListening[TOP_FOCUS] = true;</div><div class="line">          break;</div><div class="line">        case TOP_CANCEL:</div><div class="line">        case TOP_CLOSE:</div><div class="line">          if (isEventSupported(getRawEventName(dependency))) &#123;</div><div class="line">            trapCapturedEvent(dependency, mountAt);</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">        case TOP_INVALID:</div><div class="line">        case TOP_SUBMIT:</div><div class="line">        case TOP_RESET:</div><div class="line">          // We listen to them on the target DOM elements.</div><div class="line">          // Some of them bubble so we don&apos;t want them to fire twice.</div><div class="line">          break;</div><div class="line">        default:</div><div class="line">          // By default, listen on the top level to all non-media events.</div><div class="line">          // Media events don&apos;t bubble so adding the listener wouldn&apos;t do anything.</div><div class="line">          const isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;</div><div class="line">          if (!isMediaEvent) &#123;</div><div class="line">            trapBubbledEvent(dependency, mountAt);</div><div class="line">          &#125;</div><div class="line">          break;</div><div class="line">      &#125;</div><div class="line">      isListening[dependency] = true;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">3. ReactDOMEventListener.js</div><div class="line"></div><div class="line">export function trapBubbledEvent(</div><div class="line">  topLevelType: DOMTopLevelEventType,</div><div class="line">  element: Document | Element,</div><div class="line">) &#123;</div><div class="line">  if (!element) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  const dispatch = isInteractiveTopLevelEventType(topLevelType) </div><div class="line">    ? dispatchInteractiveEvent</div><div class="line">    : dispatchEvent;</div><div class="line"></div><div class="line">  addEventBubbleListener(</div><div class="line">    element,//document</div><div class="line">    getRawEventName(topLevelType),//事件类型</div><div class="line">    // Check if interactive and wrap in interactiveUpdates</div><div class="line">    dispatch.bind(null, topLevelType), //回调函数是分发函数 详见执行过程</div><div class="line">  );</div><div class="line">&#125;</div><div class="line">export function trapCapturedEvent(topLevelType, element)&#123;...&#125;</div><div class="line">export function dispatchEvent(topLevelType,nativeEvent) &#123;... &#125;</div><div class="line"></div><div class="line">4. EventListener.js</div><div class="line">export function addEventBubbleListener(</div><div class="line">  element: Document | Element,</div><div class="line">  eventType: string,</div><div class="line">  listener: Function,</div><div class="line">): void &#123;</div><div class="line">  element.addEventListener(eventType, listener, false);</div><div class="line">&#125;</div><div class="line">export function addEventCaptureListener()&#123;...&#125;</div></pre></td></tr></table></figure>
<p>在使用setInitialProperties对标签属性初始化的时候，<br>会根据不同标签自动绑定上冒泡事件或者监听事件<br>document事件回调函数是分发功能函数，不会对任何事件的直接回调函数进行处理，只会根据事件类型进行分发</p>
<h2 id="存储回调函数"><a href="#存储回调函数" class="headerlink" title="存储回调函数"></a>存储回调函数</h2><h1 id="事件执行"><a href="#事件执行" class="headerlink" title="事件执行"></a>事件执行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">//ReactDOMEventListener</div><div class="line">export function dispatchEvent(</div><div class="line">  topLevelType: DOMTopLevelEventType,</div><div class="line">  nativeEvent: AnyNativeEvent,</div><div class="line">) &#123;</div><div class="line">  if (!_enabled) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const nativeEventTarget = getEventTarget(nativeEvent);</div><div class="line">  let targetInst = getClosestInstanceFromNode(nativeEventTarget);</div><div class="line">  if (</div><div class="line">    targetInst !== null &amp;&amp;</div><div class="line">    typeof targetInst.tag === &apos;number&apos; &amp;&amp;</div><div class="line">    !isFiberMounted(targetInst)</div><div class="line">  ) &#123;</div><div class="line">    // If we get an event (ex: img onload) before committing that</div><div class="line">    // component&apos;s mount, ignore it for now (that is, treat it as if it was an</div><div class="line">    // event on a non-React tree). We might also consider queueing events and</div><div class="line">    // dispatching them after the mount.</div><div class="line">    targetInst = null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const bookKeeping = getTopLevelCallbackBookKeeping(</div><div class="line">    topLevelType,</div><div class="line">    nativeEvent,</div><div class="line">    targetInst,</div><div class="line">  );</div><div class="line"></div><div class="line">  try &#123;</div><div class="line">    // Event queue being processed in the same cycle allows</div><div class="line">    // `preventDefault`.</div><div class="line">    batchedUpdates(handleTopLevel, bookKeeping);</div><div class="line">  &#125; finally &#123;</div><div class="line">    releaseTopLevelCallbackBookKeeping(bookKeeping);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function handleTopLevel(bookKeeping) &#123;</div><div class="line">  let targetInst = bookKeeping.targetInst;</div><div class="line"></div><div class="line">  // Loop through the hierarchy, in case there&apos;s any nested components.</div><div class="line">  // It&apos;s important that we build the array of ancestors before calling any</div><div class="line">  // event handlers, because event handlers can modify the DOM, leading to</div><div class="line">  // inconsistencies with ReactMount&apos;s node cache. See #1105.</div><div class="line">  let ancestor = targetInst;</div><div class="line">  do &#123;</div><div class="line">    if (!ancestor) &#123;</div><div class="line">      bookKeeping.ancestors.push(ancestor);</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">    const root = findRootContainerNode(ancestor);</div><div class="line">    if (!root) &#123;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">    bookKeeping.ancestors.push(ancestor);</div><div class="line">    ancestor = getClosestInstanceFromNode(root);</div><div class="line">  &#125; while (ancestor);</div><div class="line"></div><div class="line">  for (let i = 0; i &lt; bookKeeping.ancestors.length; i++) &#123;</div><div class="line">    targetInst = bookKeeping.ancestors[i];</div><div class="line">    runExtractedEventsInBatch(</div><div class="line">      bookKeeping.topLevelType,</div><div class="line">      targetInst,</div><div class="line">      bookKeeping.nativeEvent,</div><div class="line">      getEventTarget(bookKeeping.nativeEvent),</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//ReactGenericBatching.js</div><div class="line">export function batchedUpdates(fn, bookkeeping) &#123;</div><div class="line">  if (isBatching) &#123;</div><div class="line">    // If we are currently inside another batch, we need to wait until it</div><div class="line">    // fully completes before restoring state.</div><div class="line">    return fn(bookkeeping);</div><div class="line">  &#125;</div><div class="line">  isBatching = true;</div><div class="line">  try &#123;</div><div class="line">    return _batchedUpdatesImpl(fn, bookkeeping);</div><div class="line">  &#125; finally &#123;</div><div class="line">    // Here we wait until all updates have propagated, which is important</div><div class="line">    // when using controlled components within layers:</div><div class="line">    // https://github.com/facebook/react/issues/1698</div><div class="line">    // Then we restore state of any controlled component.</div><div class="line">    isBatching = false;</div><div class="line">    const controlledComponentsHavePendingUpdates = needsStateRestore();</div><div class="line">    if (controlledComponentsHavePendingUpdates) &#123;</div><div class="line">      // If a controlled event was fired, we may need to restore the state of</div><div class="line">      // the DOM node back to the controlled value. This is necessary when React</div><div class="line">      // bails out of the update without touching the DOM.</div><div class="line">      _flushInteractiveUpdatesImpl();</div><div class="line">      restoreStateIfNeeded();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let _batchedUpdatesImpl = function(fn, bookkeeping) &#123;</div><div class="line">  return fn(bookkeeping);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//EventPluginHub</div><div class="line">export function runExtractedEventsInBatch(</div><div class="line">  topLevelType: TopLevelType,</div><div class="line">  targetInst: null | Fiber,</div><div class="line">  nativeEvent: AnyNativeEvent,</div><div class="line">  nativeEventTarget: EventTarget,</div><div class="line">) &#123;</div><div class="line">  const events = extractEvents(//生成合成事件</div><div class="line">    topLevelType,</div><div class="line">    targetInst,</div><div class="line">    nativeEvent,</div><div class="line">    nativeEventTarget,</div><div class="line">  );</div><div class="line">  runEventsInBatch(events); //批量更新</div><div class="line">&#125;</div><div class="line">export function runEventsInBatch(</div><div class="line">  events: Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null,</div><div class="line">) &#123;</div><div class="line">  if (events !== null) &#123;</div><div class="line">    eventQueue = accumulateInto(eventQueue, events);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Set `eventQueue` to null before processing it so that we can tell if more</div><div class="line">  // events get enqueued while processing.</div><div class="line">  const processingEventQueue = eventQueue;</div><div class="line">  eventQueue = null;</div><div class="line"></div><div class="line">  if (!processingEventQueue) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);//批量执行</div><div class="line">  invariant(</div><div class="line">    !eventQueue,</div><div class="line">    &apos;processEventQueue(): Additional events were enqueued while processing &apos; +</div><div class="line">      &apos;an event queue. Support for this has not yet been implemented.&apos;,</div><div class="line">  );</div><div class="line">  // This would be a good time to rethrow if any of the event handlers threw.</div><div class="line">  rethrowCaughtError();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="生成合成事件"><a href="#生成合成事件" class="headerlink" title="生成合成事件"></a>生成合成事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//EventPluginHub</div><div class="line">function extractEvents(</div><div class="line">  topLevelType: TopLevelType,</div><div class="line">  targetInst: null | Fiber,</div><div class="line">  nativeEvent: AnyNativeEvent,</div><div class="line">  nativeEventTarget: EventTarget,</div><div class="line">): Array&lt;ReactSyntheticEvent&gt; | ReactSyntheticEvent | null &#123;</div><div class="line">  let events = null;</div><div class="line">  for (let i = 0; i &lt; plugins.length; i++) &#123;</div><div class="line">    // Not every plugin in the ordering may be loaded at runtime.</div><div class="line">    const possiblePlugin: PluginModule&lt;AnyNativeEvent&gt; = plugins[i];</div><div class="line">    if (possiblePlugin) &#123;</div><div class="line">      const extractedEvents = possiblePlugin.extractEvents(</div><div class="line">        topLevelType,</div><div class="line">        targetInst,</div><div class="line">        nativeEvent,</div><div class="line">        nativeEventTarget,</div><div class="line">      );</div><div class="line">      if (extractedEvents) &#123;</div><div class="line">        events = accumulateInto(events, extractedEvents);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return events;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//DOMEventPluginOrder</div><div class="line">const DOMEventPluginOrder = [</div><div class="line">  &apos;ResponderEventPlugin&apos;,</div><div class="line">  &apos;SimpleEventPlugin&apos;,</div><div class="line">  &apos;EnterLeaveEventPlugin&apos;,</div><div class="line">  &apos;ChangeEventPlugin&apos;,</div><div class="line">  &apos;SelectEventPlugin&apos;,</div><div class="line">  &apos;BeforeInputEventPlugin&apos;,</div><div class="line">];</div><div class="line"></div><div class="line">export default DOMEventPluginOrder;</div></pre></td></tr></table></figure>
<h2 id="获取回调函数"><a href="#获取回调函数" class="headerlink" title="获取回调函数"></a>获取回调函数</h2><h2 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;事件注册&quot;&gt;&lt;a href=&quot;#事件注册&quot; class=&quot;headerlink&quot; title=&quot;事件注册&quot;&gt;&lt;/a&gt;事件注册&lt;/h1&gt;&lt;h2 id=&quot;注册到document&quot;&gt;&lt;a href=&quot;#注册到document&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
    
      <category term="react" scheme="http://yoohannah.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>VUE 数据绑定初探</title>
    <link href="http://yoohannah.github.io/post/vue/mvvm.html"/>
    <id>http://yoohannah.github.io/post/vue/mvvm.html</id>
    <published>2018-12-30T08:38:15.000Z</published>
    <updated>2018-12-30T08:52:26.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目中遇到一个需求是需要渲染一个列表，然后点击每一行展开按钮，显示该行一个详情<br><img src="/image/vuedata1.png" alt="vuedata1"><br>初步实现想法是在拿到列表数据时，给每一项添加属性show,初始值为false,点击按钮将show改为!show，从而控制详情显示隐藏<br>但发现不生效，详情没有按照预期显示<br>探究其原因是因为数据的改变没有引起界面的重新渲染<br>那么数据是怎么引发界面重新渲染的呢？什么样的数据改变才会引起界面重新渲染呢？</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>VUE 在进行数据双向绑定时，主要用到了两个思想：数据劫持和订阅发布模式</p>
<h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>vue 在拿到export default 的data中声明的变量后，会进行跟踪处理，<br>这个跟踪处理主要就是将变量的赋值和读取,参照对象属性的setter和getter进行使用Object.defineProperty重写成响应对象<br>即读取一个变量的数据时会通过调用getter方法return获取值，<br>重新赋值时会通过setter方法判断新值旧值是否相同，不同则进行更新，从而调用更新函数，进行视图更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Define a reactive property on an Object.</div><div class="line"> */</div><div class="line">export function defineReactive (</div><div class="line">  obj: Object,</div><div class="line">  key: string,</div><div class="line">  val: any,</div><div class="line">  customSetter?: ?Function,</div><div class="line">  shallow?: boolean</div><div class="line">) &#123;</div><div class="line">  const dep = new Dep()</div><div class="line"></div><div class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</div><div class="line">  if (property &amp;&amp; property.configurable === false) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // cater for pre-defined getter/setters</div><div class="line">  const getter = property &amp;&amp; property.get</div><div class="line">  if (!getter &amp;&amp; arguments.length === 2) &#123;</div><div class="line">    val = obj[key]</div><div class="line">  &#125;</div><div class="line">  const setter = property &amp;&amp; property.set</div><div class="line"></div><div class="line">  let childOb = !shallow &amp;&amp; observe(val)</div><div class="line">  Object.defineProperty(obj, key, &#123;</div><div class="line">    enumerable: true,</div><div class="line">    configurable: true,</div><div class="line">    /******/</div><div class="line">    get: function reactiveGetter () &#123;</div><div class="line">      const value = getter ? getter.call(obj) : val</div><div class="line">      if (Dep.target) &#123; </div><div class="line">        dep.depend()//获取这个值时，即将获取的这个地方当作订阅者放到订阅者列表中</div><div class="line">        if (childOb) &#123;</div><div class="line">          childOb.dep.depend()</div><div class="line">          if (Array.isArray(value)) &#123;</div><div class="line">            dependArray(value)</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      return value</div><div class="line">    &#125;,</div><div class="line">    /******/</div><div class="line">    /******/</div><div class="line">    set: function reactiveSetter (newVal) &#123;</div><div class="line">      const value = getter ? getter.call(obj) : val</div><div class="line">      /* eslint-disable no-self-compare */</div><div class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; //与旧值相同，直接return 不更新</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line">      /* eslint-enable no-self-compare */</div><div class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</div><div class="line">        customSetter()</div><div class="line">      &#125;</div><div class="line">      if (setter) &#123;</div><div class="line">        setter.call(obj, newVal)</div><div class="line">      &#125; else &#123;</div><div class="line">        val = newVal //与旧值不同，重新赋值</div><div class="line">      &#125;</div><div class="line">      childOb = !shallow &amp;&amp; observe(newVal)</div><div class="line">      dep.notify() //通知更新</div><div class="line">    &#125;</div><div class="line">    /******/</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h2><p>进行视图更新时,更新函数需要知道视图哪些地方需要更新，以及由于该变量发生变化可能引起的其他变量变化或者触发一定的功能函数，<br>所以我们需要对数据的变化进行监听，并告知用到变量的地方（即订阅者），变量发生了变化，需要执行依据此变化要做的事<br>因为订阅者很可能不止一个（即一个变量被多处用到,包括js和html模板）,所以我们需要一个地方存放订阅者，并批量通知订阅者进行更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">mport type Watcher from &apos;./watcher&apos; //或初始化watcher</div><div class="line">import &#123; remove &#125; from &apos;../util/index&apos;</div><div class="line"></div><div class="line">let uid = 0</div><div class="line"></div><div class="line">/**</div><div class="line"> * A dep is an observable that can have multiple</div><div class="line"> * directives subscribing to it.</div><div class="line"> */</div><div class="line">export default class Dep &#123;</div><div class="line">  static target: ?Watcher;</div><div class="line">  id: number;</div><div class="line">  subs: Array&lt;Watcher&gt;;</div><div class="line"></div><div class="line">  constructor () &#123;</div><div class="line">    this.id = uid++</div><div class="line">    this.subs = [] //订阅者集合</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  addSub (sub: Watcher) &#123;  //添加订阅者集合</div><div class="line">    this.subs.push(sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  removeSub (sub: Watcher) &#123;</div><div class="line">    remove(this.subs, sub)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  depend () &#123;</div><div class="line">    if (Dep.target) &#123;</div><div class="line">      Dep.target.addDep(this)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  notify () &#123; //批量更新</div><div class="line">    // stabilize the subscriber list first</div><div class="line">    const subs = this.subs.slice()</div><div class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</div><div class="line">      subs[i].update()</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// the current target watcher being evaluated.</div><div class="line">// this is globally unique because there could be only one</div><div class="line">// watcher being evaluated at any time.</div><div class="line">Dep.target = null</div><div class="line">const targetStack = []</div><div class="line"></div><div class="line">export function pushTarget (_target: ?Watcher) &#123;</div><div class="line">  if (Dep.target) targetStack.push(Dep.target)</div><div class="line">  Dep.target = _target  //将watcher缓存到Dep.target</div><div class="line">&#125;</div><div class="line"></div><div class="line">export function popTarget () &#123;</div><div class="line">  Dep.target = targetStack.pop()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义订阅者，订阅者需要自己将自己放到变量的订阅者列表中，采用的方法是将自己暂存在Dep.target上，<br>在初始化的时候调用一下变量，利用变量getter方法，将自己添加到订阅者列表，然后将Dep.target至空，取消暂存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">export default class Watcher &#123;</div><div class="line">  vm: Component;</div><div class="line">  expression: string;</div><div class="line">  cb: Function;</div><div class="line">  id: number;</div><div class="line">  deep: boolean;</div><div class="line">  user: boolean;</div><div class="line">  lazy: boolean;</div><div class="line">  sync: boolean;</div><div class="line">  dirty: boolean;</div><div class="line">  active: boolean;</div><div class="line">  deps: Array&lt;Dep&gt;;</div><div class="line">  newDeps: Array&lt;Dep&gt;;</div><div class="line">  depIds: SimpleSet;</div><div class="line">  newDepIds: SimpleSet;</div><div class="line">  getter: Function;</div><div class="line">  value: any;</div><div class="line"></div><div class="line">  constructor (</div><div class="line">    vm: Component,</div><div class="line">    expOrFn: string | Function,</div><div class="line">    cb: Function,</div><div class="line">    options?: ?Object,</div><div class="line">    isRenderWatcher?: boolean</div><div class="line">  ) &#123;</div><div class="line">    this.value = this.lazy</div><div class="line">      ? undefined</div><div class="line">      : this.get() //将watcher 自己装进变量的订阅者列表</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Evaluate the getter, and re-collect dependencies.</div><div class="line">   */</div><div class="line">  get () &#123;</div><div class="line">    pushTarget(this) //暂存到Dep.target</div><div class="line">    let value</div><div class="line">    const vm = this.vm</div><div class="line">    try &#123;</div><div class="line">      value = this.getter.call(vm, vm) //调用变量的getter函数，将自己装到订阅者列表</div><div class="line">    &#125; catch (e) &#123;</div><div class="line">      if (this.user) &#123;</div><div class="line">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</div><div class="line">      &#125; else &#123;</div><div class="line">        throw e</div><div class="line">      &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">      // &quot;touch&quot; every property so they are all tracked as</div><div class="line">      // dependencies for deep watching</div><div class="line">      if (this.deep) &#123;</div><div class="line">        traverse(value)</div><div class="line">      &#125;</div><div class="line">      popTarget()//取消watcher暂存，释放该watcher的绑定</div><div class="line">      this.cleanupDeps()</div><div class="line">    &#125;</div><div class="line">    return value</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  </div><div class="line">  /**</div><div class="line">   * Subscriber interface.</div><div class="line">   * Will be called when a dependency changes.</div><div class="line">   */</div><div class="line">  update () &#123; //dep批量更新调用</div><div class="line">    /* istanbul ignore else */</div><div class="line">    if (this.lazy) &#123;</div><div class="line">      this.dirty = true</div><div class="line">    &#125; else if (this.sync) &#123;</div><div class="line">      this.run()</div><div class="line">    &#125; else &#123;</div><div class="line">      queueWatcher(this)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Scheduler job interface.</div><div class="line">   * Will be called by the scheduler.</div><div class="line">   */</div><div class="line">  run () &#123;</div><div class="line">    if (this.active) &#123;</div><div class="line">      const value = this.get()</div><div class="line">      if (</div><div class="line">        value !== this.value ||</div><div class="line">        // Deep watchers and watchers on Object/Arrays should fire even</div><div class="line">        // when the value is the same, because the value may</div><div class="line">        // have mutated.</div><div class="line">        isObject(value) ||</div><div class="line">        this.deep</div><div class="line">      ) &#123;</div><div class="line">        // set new value</div><div class="line">        const oldValue = this.value</div><div class="line">        this.value = value</div><div class="line">        if (this.user) &#123;</div><div class="line">          try &#123;</div><div class="line">            this.cb.call(this.vm, value, oldValue) //执行更新回调</div><div class="line">          &#125; catch (e) &#123;</div><div class="line">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</div><div class="line">          &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">          this.cb.call(this.vm, value, oldValue) //执行更新回调</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解析模板"><a href="#解析模板" class="headerlink" title="解析模板"></a>解析模板</h2><p>在解析模板时遇到指令或者&#123;&#123;&#125;&#125;时，将变量值替换到dom节点中，然后生成一个订阅者(根据参数将自己添加到对应绑定变量的订阅者列表中)，将自己的更新订阅到变量的变化中，从而在变量变化时，更新视图，<br>每解析到一个地方用到同一个变量，就生成一个watcher,从而反应出需要使用订阅者列表进行批量更新</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综上，当变量在声明时会被劫持转成可响应对象，变量的读取更新，通过get和set完成，<br>在get时添加自己的订阅者，在set时告诉订阅者进行批量更新<br>订阅者管家由一个Dep对象负责，进行添加，触发更新等工作<br>订阅者对象需要表明自己是谁，能够将自己添加到订阅者列表，根据变量变化执行更新回调<br>页面上的变量会在编译时生成订阅器，将自己订阅到变量的订阅列表中，从而在变量变化时得到更新</p>
<p><img src="/image/vuedata2.png" alt="vuedata2"></p>
<h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>vue 在进行数据劫持时，会对对象进行递归处理，直到递归到的属性值是一个基本变量，即监听到基本变量变化，值监听<br>所以变量本身值是一个基本变量，则直接进行响应对象转化<br>但会根据变量是否是数组进行特殊处理，只是对数组每一项进行监听，除非值又是一个数组才会递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">export class Observer &#123;</div><div class="line">  value: any;</div><div class="line">  dep: Dep;</div><div class="line">  vmCount: number; // number of vms that has this object as root $data</div><div class="line"></div><div class="line">  constructor (value: any) &#123;</div><div class="line">    this.value = value</div><div class="line">    this.dep = new Dep()</div><div class="line">    this.vmCount = 0</div><div class="line">    def(value, &apos;__ob__&apos;, this)</div><div class="line">    if (Array.isArray(value)) &#123; //数组</div><div class="line">      const augment = hasProto</div><div class="line">        ? protoAugment</div><div class="line">        : copyAugment</div><div class="line">      augment(value, arrayMethods, arrayKeys)</div><div class="line">      this.observeArray(value)</div><div class="line">    &#125; else &#123;</div><div class="line">      this.walk(value)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Walk through each property and convert them into</div><div class="line">   * getter/setters. This method should only be called when</div><div class="line">   * value type is Object.</div><div class="line">   */</div><div class="line">  walk (obj: Object) &#123;</div><div class="line">    const keys = Object.keys(obj)</div><div class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</div><div class="line">      defineReactive(obj, keys[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * Observe a list of Array items.</div><div class="line">   */</div><div class="line">  observeArray (items: Array&lt;any&gt;) &#123;</div><div class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</div><div class="line">      observe(items[i]) //判断对数组值进行判断</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</div><div class="line">  if (!isObject(value) || value instanceof VNode) &#123;</div><div class="line">    return</div><div class="line">  &#125;</div><div class="line">  let ob: Observer | void</div><div class="line">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</div><div class="line">    ob = value.__ob__</div><div class="line">  &#125; else if (</div><div class="line">    shouldObserve &amp;&amp;</div><div class="line">    !isServerRendering() &amp;&amp;</div><div class="line">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp; //值又是数组</div><div class="line">    Object.isExtensible(value) &amp;&amp;</div><div class="line">    !value._isVue</div><div class="line">  ) &#123;</div><div class="line">    ob = new Observer(value) //递归转化</div><div class="line">  &#125;</div><div class="line">  if (asRootData &amp;&amp; ob) &#123;</div><div class="line">    ob.vmCount++</div><div class="line">  &#125;</div><div class="line">  return ob</div></pre></td></tr></table></figure>
<p>带来的缺陷就是<br>对于对象来说，初始化以后，对象新增的属性不会被纳入监听范围,属性的删除也不能被监听到<br>对于数组来说，如果是一个对象数组，则数组里每一个对象里的属性值的增删改均不会被监听到</p>
<p>解决办法<br>对于数组来说，通过使用代码规定的<br>  ‘push’,<br>  ‘pop’,<br>  ‘shift’,<br>  ‘unshift’,<br>  ‘splice’,<br>  ‘sort’,<br>  ‘reverse’<br>几种方法可触发更新，实现对数组的修改，<br>例如，这里的问题，使用this.data.splice(index,1,obj),将原来的数组项替换掉，<br>从而达到更新</p>
<p>对于对象来说,可以使用如下两中方法进行更新<br>this.$set(obj,keyStr,val)//新增属性<br>obj = Object.assign({},obj,newItemObj) //删除/更改</p>
<p>在本问题中，目前的解决办法是引入新变量存放点击的行数，根据该变量值是否等于当前行，<br>更改class值，从而控制展开关闭</p>
<p><a href="https://www.cnblogs.com/libin-1/p/6893712.html" target="_blank" rel="external">参照资料</a><br><a href="https://github.com/vuejs/vue/tree/dev/src/core/observer" target="_blank" rel="external">源码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;项目中遇到一个需求是需要渲染一个列表，然后点击每一行展开按钮，显示该行一个详情&lt;br&gt;&lt;img src=&quot;/image/vuedata1.p
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>结合VeeValidate实现对select校验</title>
    <link href="http://yoohannah.github.io/post/vue/VeeValidate&amp;select.html"/>
    <id>http://yoohannah.github.io/post/vue/VeeValidate&amp;select.html</id>
    <published>2018-12-22T04:32:15.000Z</published>
    <updated>2018-12-22T05:15:47.061Z</updated>
    
    <content type="html"><![CDATA[<p>1.对校验项进行手动触发校验</p>
<p>配置 VeeValidate 时，触发事件event设置为‘blur’,而表单在点击提交按钮时，没有对整个表单进行校验，用户如果点开配置表单，不做任何操作就提交的话，会导致页面上不会有任何反应，因此调用 VeeValidate手动触发函数this.$validator.validate()，进行整体校验</p>
<p>this.$validator.validate()会返回promise, resolve的回调函数的参数result 为false时校验不通过，true时校验通过</p>
<p>2.添加select 验证</p>
<p>因为 VeeValidate 只对 input 进行，所以当表单配置项以select呈现时，就算在标签上添加v-validate，也不会对其进行校验，反而还会导致之前配置的blur触发事件失效，所以手动添加对select的校验</p>
<p>之前调用this.$validator.validate()进行手动触发校验input ,返回的是promise,因此在校验完input之后先不管input的校验结果，直接对select 进行校验</p>
<p>select 出现在配置项中有两种情况，一种是通过配置表单时，配置过来的，另外一种是通过slot套嵌进来的，slot也属于配置对象config里面的一种type</p>
<p>之所以会出现需要通过slot 来添加select的情况,是因为这类的select一般需要绑定change事件,与其他配置项形成关联关系，如果以配置项的方式给select添加绑定change事件,会导致infinity loop错误，</p>
<p>导致出现这个错误的原因是渲染配置项的时候用的是一个v-for，一项一项把配置的input,select根据type渲染出来,这时，如果给select绑上change事件,而且change事件的内容是对v-for的对象的属性进行修改vue的机制就会认为触发了无限循环，开始死循环,因此不为配置的项添加change事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">父组件配置对象</div><div class="line">modelConfig: &#123;</div><div class="line">        title: &apos;授权&apos;,</div><div class="line">        modalId: &apos;modelConfig&apos;,</div><div class="line">        isAdd: true,</div><div class="line">        config: [</div><div class="line">          &#123;label: &apos;策略&apos;, value: &apos;v_policy_selected&apos;, option: &apos;v_policy_option&apos;, placeholder: &apos;&apos;, disabled: false, type: &apos;select&apos;,v_validate: &apos;required:true&apos;,isError: false&#125;,</div><div class="line">          &#123;name: &apos;selectAz&apos;, type: &apos;slot&apos;, v_validate:[</div><div class="line">            &#123;label: &apos;租户&apos;, value: &apos;v_tenant_selected&apos;, isError: &apos;v_tenant_isError&apos;, type: &apos;select&apos;&#125;,</div><div class="line">            &#123;label: &apos;项目&apos;, value: &apos;v_project_selected&apos;, isError: &apos;v_project_isError&apos;, type: &apos;select&apos;&#125;</div><div class="line">          ]&#125;],</div><div class="line">        addRow: &#123; // 其他配置项绑定的数据</div><div class="line">          </div><div class="line">        &#125;,</div><div class="line">        v_select_configs: &#123;</div><div class="line">          v_policy_selected: null, // 选中数据</div><div class="line">          v_policy_option: [], // 选择数据</div><div class="line">          v_project_selected: null, // 选中数据</div><div class="line">          v_project_option: [], // 选择数据</div><div class="line">          v_project_isError: false,</div><div class="line">          v_tenant_selected: null, // 选中数据</div><div class="line">          v_tenant_option: [], // 选择数据</div><div class="line">          v_tenant_isError: false</div><div class="line">        &#125;,</div><div class="line">        saveFunc: &apos;authSave&apos;</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>主要验证逻辑如下：</p>
<p>校验之前设置flag = true,标志select的校验结果，最后用于与input校验结果result共同决定校验结果</p>
<p>先判断该配置项是否显示在表单中，因为有时新增和编辑的配置项不同，如果不在就不对该项进行校验，continue</p>
<p>对通过配置项展示的select，进行校验,如配置了校验规则v_validate，而且值为未选状态,则显示校验错误提示,同时设置flag = false,否则，不显示校验错误提示</p>
<p>这种错误提示同input,其显示通过配置项对象里面的一个属性决定，因此效果就是，显示提示该属性就设为true,否则设为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;label v-show=&quot;errors.has(item.value) &amp;&amp; isHide(item.hide)&quot; class=&quot;col-md-7 help is-danger&quot;&gt;&#123;&#123;item.label&#125;&#125; &#123;&#123;errors.first(item.value)&#125;&#125;&lt;/label&gt;</div><div class="line">&lt;label v-if=&quot;item.type === &apos;select&apos; &amp;&amp; item.isError&quot; class=&quot;col-md-7 help is-danger&quot;&gt;&#123;&#123;item.label&#125;&#125; 不能为空&lt;/label&gt;</div></pre></td></tr></table></figure></p>
<p>对通过slot展示的select, 进行校验, 所有需要校验的配置放在v_validate属性中,遍历v_validate，判断select的值是否为未选，未选则显示提示，已选则不显示</p>
<p>错误提示放在slot的代码中,每一项配置自己的错误提示label,label的显示通过v_validate里面每一项配置的对应的错误提示属性的绑定值决定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div slot=&quot;selectAz&quot;&gt;</div><div class="line">&lt;v-select</div><div class="line">          v-model=&quot;modelConfig.v_select_configs.v_region_selected&quot;</div><div class="line">          label=&quot;name&quot;</div><div class="line">          class=&quot;col-md-7 v-selectss &quot;</div><div class="line">          :on-change=&quot;changeRegion&quot;</div><div class="line">          :options=&quot;modelConfig.v_select_configs.v_region_option&quot;&gt;</div><div class="line">&lt;/v-select&gt;</div><div class="line">&lt;label class=&quot;required-tip&quot;&gt;*&lt;/label&gt;</div><div class="line">&lt;label v-if=&quot;modelConfig.v_select_configs.v_region_isError&quot; class=&quot;col-md-7 help is-danger&quot;&gt;xxx 不能为空&lt;/label&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">具体代码</div><div class="line"> formValidate () &#123;</div><div class="line">        return this.$validator.validate().then(result =&gt; &#123;</div><div class="line">          //result 为false插件验证input没有填写完整,true为验证填写完整</div><div class="line">          /** 验证 select是否进行了选填 实例可参照 [manage][authorizations]user-authorized.vue **/</div><div class="line">          let flag = true</div><div class="line">          for(let i=0; i&lt; this.modelConfig.config.length; i++)&#123;</div><div class="line">            if(!this.isHide (this.modelConfig.config[i].hide))&#123;</div><div class="line">              continue</div><div class="line">            &#125;</div><div class="line">            /* ****** 配置里面的select ***** */</div><div class="line">            //配置规则为：在配置type:selcet时，如需校验则添加v_validate: &apos;required:true&apos;,isError: false==&gt;控制错误提示label显示</div><div class="line">            //如果无需校验，则不添加</div><div class="line">            if(this.modelConfig.config[i].type === &apos;select&apos; &amp;&amp; this.modelConfig.config[i].v_validate) &#123; </div><div class="line">              let obj = this.modelConfig.config[i]</div><div class="line">              if(!this.modelConfig.v_select_configs[obj.value])&#123;</div><div class="line">                this.modelConfig.config[i].isError = true</div><div class="line">                flag = false</div><div class="line">              &#125;else&#123;</div><div class="line">                this.modelConfig.config[i].isError = false</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">            /* ******  slot里面的select  ****** */</div><div class="line">            //配置规则为：在配置type:slot 时，添加 v_validate:[],数组里面存放需要校验的select的配置信息</div><div class="line">            //value:绑定值,isError:错误标签显示绑定值，type:select  ===&gt; 如果以后再校验其他类型，再增加判断逻辑</div><div class="line">            //&#123;name:&apos;xxxx&apos;,type:&apos;slot&apos;,v_validate:[&#123;value: &apos;v_xxx_selected&apos;, isError: &apos;v_xxx_isError&apos;, type: &apos;select&apos;&#125;]&#125;</div><div class="line">            //同时在this.modelConfig.v_select_configs里面定义v_xxx_isError：false</div><div class="line">            //slot里面错误提示label显示用 v-if=&quot;modelConfig.v_select_configs.v_xxx_isError&quot; 搭配其他具体规则进行组合</div><div class="line">            if(this.modelConfig.config[i].type === &apos;slot&apos;) &#123; </div><div class="line">              let arr = this.modelConfig.config[i].v_validate ? this.modelConfig.config[i].v_validate :[]</div><div class="line">              for(let j =0;j&lt;arr.length;j++)&#123;</div><div class="line">                let key = arr[j].isError</div><div class="line">                let value = arr[j].value</div><div class="line">                if(arr[j].type === &apos;select&apos; &amp;&amp; !this.modelConfig.v_select_configs[value]) &#123;</div><div class="line">                  this.modelConfig.v_select_configs[key] = true</div><div class="line">                  flag = false</div><div class="line">                &#125;else&#123;</div><div class="line">                  this.modelConfig.v_select_configs[key] = false</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          return result &amp;&amp; flag</div><div class="line">        &#125;)</div><div class="line">      &#125;,</div></pre></td></tr></table></figure>
<p>3.勾选选项后错误消失</p>
<p> 在公共组件里面为prop添加watch方法，当对象属性发生变化时就检查select是否有值了，有的话，就将提示隐藏掉<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">data () &#123;</div><div class="line">     return &#123;</div><div class="line">       configCopy:this.modelConfig,</div><div class="line">       FLAG:false</div><div class="line">     &#125;</div><div class="line">   &#125;,</div><div class="line">props: [&apos;modelConfig&apos;],</div><div class="line">watch:&#123;</div><div class="line">     configCopy: &#123;</div><div class="line">       handler()&#123; </div><div class="line">         //select选择完将提示隐藏，如果日后保留&apos;X&apos;删除功能，如需要，再增加显示处理逻辑</div><div class="line">         for(let key in this.modelConfig.v_select_configs) &#123; //slot select</div><div class="line">           if(key.endsWith(&apos;isError&apos;))&#123;</div><div class="line">             let prefix = key.slice(0,-7)</div><div class="line">             if(this.modelConfig.v_select_configs[key] &amp;&amp; this.modelConfig.v_select_configs[prefix+&apos;selected&apos;])&#123;</div><div class="line">               this.modelConfig.v_select_configs[key] = false</div><div class="line">             &#125;</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">         for(let i=0; i&lt; this.modelConfig.config.length; i++)&#123; //config select</div><div class="line">           if(this.modelConfig.config[i].type === &apos;select&apos; &amp;&amp; this.modelConfig.config[i].v_validate) &#123; </div><div class="line">             let obj = this.modelConfig.config[i]</div><div class="line">             if(this.modelConfig.v_select_configs[obj.value])&#123;</div><div class="line">               this.modelConfig.config[i].isError = false</div><div class="line">             &#125;</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">       &#125;,</div><div class="line">       deep:true</div><div class="line">     &#125;</div><div class="line">   &#125;,</div></pre></td></tr></table></figure></p>
<p>4.关闭配置页面的清空</p>
<p>  检查配置项对象里面所有的select配置项，将其负责错误提示显示的项设置为false<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 清除表单selected</div><div class="line">     for(let i=0; i&lt;this.modelConfig.config.length; i++)&#123;</div><div class="line">       if(this.modelConfig.config[i].type === &apos;select&apos; &amp;&amp; this.modelConfig.config[i].v_validate) &#123;</div><div class="line">         this.modelConfig.config[i].isError = false</div><div class="line">       &#125;</div><div class="line">       if(this.modelConfig.config[i].type === &apos;slot&apos;) &#123; </div><div class="line">         let arr = this.modelConfig.config[i].v_validate ? this.modelConfig.config[i].v_validate :[]</div><div class="line">         for(let j =0;j&lt;arr.length;j++)&#123;</div><div class="line">           let key = arr[j].isError</div><div class="line">           let value = arr[j].value</div><div class="line">           if(arr[j].type === &apos;select&apos; &amp;&amp; !this.modelConfig.v_select_configs[value]) &#123;</div><div class="line">             this.modelConfig.v_select_configs[key] = false</div><div class="line">           &#125;</div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.对校验项进行手动触发校验&lt;/p&gt;
&lt;p&gt;配置 VeeValidate 时，触发事件event设置为‘blur’,而表单在点击提交按钮时，没有对整个表单进行校验，用户如果点开配置表单，不做任何操作就提交的话，会导致页面上不会有任何反应，因此调用 VeeValidate手动
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>自定义VUE指令</title>
    <link href="http://yoohannah.github.io/post/vue/customcommander.html"/>
    <id>http://yoohannah.github.io/post/vue/customcommander.html</id>
    <published>2018-12-22T04:30:15.000Z</published>
    <updated>2018-12-22T04:32:29.471Z</updated>
    
    <content type="html"><![CDATA[<p>使用marquee标签实现文字悬浮滚动效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//一般实现</div><div class="line"> &lt;div id=&quot;demo&quot;&gt;</div><div class="line">    &lt;div v-if=&quot;show&quot; style=&quot;z-index:99999;width200px;margin-left:20px;margin-top:-20px;background-color:#00a4ff;width:200px;position: absolute;border-radius:5px;padding-top: 5px;&quot;&gt;</div><div class="line">      &lt;marquee &gt;</div><div class="line">      &lt;span style=&quot;font-weight: bolder;font-size: 10px;color: white;&quot;&gt;Welcom CMRH!&lt;/span&gt;</div><div class="line">    &lt;/marquee&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;button @mouseover=&quot;show = !show&quot; @mouseout=&quot;show = !show&quot;&gt;</div><div class="line">    Toggle</div><div class="line">  &lt;/button&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//全局定义</div><div class="line">Vue.directive(&apos;demo&apos;, function (el, binding) &#123;</div><div class="line">  console.log(el,binding)</div><div class="line">  let str = &apos;&lt;div id=&quot;pointer&quot; style=&quot;z-index:99999;width200px;margin-left:20px;margin-top:-20px;background-color:#00a4ff;width:200px;position: absolute;border-radius:5px;padding-top: 5px;&quot;&gt;&lt;marquee&gt;&lt;span style=&quot;font-weight: bolder;font-size: 10px;color: white;&quot;&gt;&apos;</div><div class="line">   + binding.value.text + </div><div class="line">   &apos;&lt;/span&gt;&lt;/marquee&gt;&lt;/div&gt;&apos;</div><div class="line">  $(el).mouseover (function() &#123;</div><div class="line">    $(el).prepend(str)</div><div class="line">  &#125;)</div><div class="line">  $(el).mouseout (function() &#123;</div><div class="line">    $(&apos;#pointer&apos;).remove()</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//使用</div><div class="line">&lt;div v-demo=&quot;&#123; color: &apos;white&apos;, text: &apos;hello!&apos; &#125;&quot;&gt;111111&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>通过指令传递的数据，通过binding.value读取</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用marquee标签实现文字悬浮滚动效果&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>触发render</title>
    <link href="http://yoohannah.github.io/post/react/renderfire.html"/>
    <id>http://yoohannah.github.io/post/react/renderfire.html</id>
    <published>2018-12-22T03:40:37.000Z</published>
    <updated>2018-12-22T03:42:29.036Z</updated>
    
    <content type="html"><![CDATA[<p>在react中，触发render的有4条路径。</p>
<p>以下假设shouldComponentUpdate都是按照默认返回true的方式。</p>
<p>首次渲染Initial Render</p>
<p>调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render）</p>
<p>父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render）</p>
<p>调用this.forceUpdate</p>
<p><a href="https://www.cnblogs.com/AnnieBabygn/p/6560833.html" target="_blank" rel="external">https://www.cnblogs.com/AnnieBabygn/p/6560833.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在react中，触发render的有4条路径。&lt;/p&gt;
&lt;p&gt;以下假设shouldComponentUpdate都是按照默认返回true的方式。&lt;/p&gt;
&lt;p&gt;首次渲染Initial Render&lt;/p&gt;
&lt;p&gt;调用this.setState （并不是一次setState会
    
    </summary>
    
    
      <category term="react" scheme="http://yoohannah.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>指令</title>
    <link href="http://yoohannah.github.io/post/vue/basic/commanders.html"/>
    <id>http://yoohannah.github.io/post/vue/basic/commanders.html</id>
    <published>2018-12-22T03:40:37.000Z</published>
    <updated>2018-12-22T04:35:50.862Z</updated>
    
    <content type="html"><![CDATA[<p>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<h1 id="简单指令"><a href="#简单指令" class="headerlink" title="简单指令"></a>简单指令</h1><p>v-if 条件指令，绑定值为真时构建DOM,假时bu构建或者删除已存在DOM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">    name: &apos;vpc&apos;,</div><div class="line">    data () &#123;</div><div class="line">      return &#123;</div><div class="line">        seen: true</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>v-for 循环指令，根据绑定值，循环输出DOM元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div v-for=&quot;(item, index) in modalFooter&quot;&gt;</div><div class="line">  &lt;button  @click=&quot;customFunc(item.Func)&quot; type=&quot;button&quot; class=&quot;btn btn-primary&quot; v-if=&apos;item.name&apos;&gt;&#123;&#123;item.name&#125;&#125;&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">//根据数据modalFooter数组循环出多个数组</div></pre></td></tr></table></figure></p>
<p>v-on 监听 DOM 事件的指令,触发事件的回调函数放在method中，可以简写成‘@事件名’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-5&quot;&gt;</div><div class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;</div><div class="line"> //或者 &lt;button @click=&quot;reverseMessage&quot;&gt;逆转消息&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var app5 = new Vue(&#123;</div><div class="line">  el: &apos;#app-5&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;Hello Vue.js!&apos;</div><div class="line">  &#125;,</div><div class="line">  methods: &#123;</div><div class="line">    reverseMessage: function () &#123;</div><div class="line">      this.message = this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>v-model 双向绑定指令,绑定的值在页面更改后js可以及时更改，js改变该值后,页面能马上渲染响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-6&quot;&gt;</div><div class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</div><div class="line">  &lt;input v-model=&quot;message&quot;&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var app6 = new Vue(&#123;</div><div class="line">  el: &apos;#app-6&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;Hello Vue!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>v-bind 绑定HTML标签属性,响应式地更新 HTML 特性 缩写形式”  :属性名=’响应函数名’  “<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app-2&quot;&gt;</div><div class="line">  &lt;span v-bind:title=&quot;message&quot;&gt;</div><div class="line">  //或者&lt;span :title=&quot;message&quot;&gt;</div><div class="line">    鼠标悬停几秒钟查看此处动态绑定的提示信息！</div><div class="line">  &lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var app2 = new Vue(&#123;</div><div class="line">  el: &apos;#app-2&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;页面加载于 &apos; + new Date().toLocaleString()</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">//在这里，该指令的意思是：“将这个元素节点的 title 特性和 Vue 实例的 message 属性保持一致”</div></pre></td></tr></table></figure></p>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM&lt;/p&gt;
&lt;h1 id=&quot;简单指令&quot;&gt;&lt;a href=&quot;#简单指令&quot; class=&quot;headerlink&quot; title=&quot;简单指令&quot;&gt;&lt;/a&gt;简单指令&lt;/h1&gt;&lt;p&gt;v-if 条件指令，绑定值为真时
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>文件结构</title>
    <link href="http://yoohannah.github.io/post/vue/basic/filestructor.html"/>
    <id>http://yoohannah.github.io/post/vue/basic/filestructor.html</id>
    <published>2018-12-22T03:40:37.000Z</published>
    <updated>2018-12-22T04:36:13.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>使用命令行构建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">npm install --global vue-cli //全局安装vue命令</div><div class="line">vue init webpack my-project //使用vue命令构建名为my-project的项目</div><div class="line">cd my-project //进入项目所在文件夹</div><div class="line">npm run dev //运行项目</div></pre></td></tr></table></figure></p>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><pre><code class="lang-bash">.
├── build/                      <span class="hljs-comment"># webpack config files</span>
│   └── ...
├── config/
│   ├── index.js                <span class="hljs-comment"># main project config</span>
│   └── ...
├── src/
│   ├── main.js                 <span class="hljs-comment"># app entry file</span>
│   ├── App.vue                 <span class="hljs-comment"># main app component</span>
│   ├── components/             <span class="hljs-comment"># ui components</span>
│   │   └── ...
│   └── assets/                 <span class="hljs-comment"># module assets (processed by webpack)</span>
│       └── ...
├── static/                     <span class="hljs-comment"># pure static assets (directly copied)</span>
├── <span class="hljs-built_in">test</span>/
│   └── unit/                   <span class="hljs-comment"># unit tests</span>
│   │   ├── specs/              <span class="hljs-comment"># test spec files</span>
│   │   ├── eslintrc            <span class="hljs-comment"># config file for eslint with extra settings only for unit tests</span>
│   │   ├── index.js            <span class="hljs-comment"># test build entry file</span>
│   │   ├── jest.conf.js        <span class="hljs-comment"># Config file when using Jest for unit tests</span>
│   │   └── karma.conf.js       <span class="hljs-comment"># test runner config file when using Karma for unit tests</span>
│   │   ├── setup.js            <span class="hljs-comment"># file that runs before Jest runs your unit tests</span>
│   └── e2e/                    <span class="hljs-comment"># e2e tests</span>
│   │   ├── specs/              <span class="hljs-comment"># test spec files</span>
│   │   ├── custom-assertions/  <span class="hljs-comment"># custom assertions for e2e tests</span>
│   │   ├── runner.js           <span class="hljs-comment"># test runner script</span>
│   │   └── nightwatch.conf.js  <span class="hljs-comment"># test runner config file</span>
├── .babelrc                    <span class="hljs-comment"># babel config</span>
├── .editorconfig               <span class="hljs-comment"># indentation, spaces/tabs and similar settings for your editor</span>
├── .eslintrc.js                <span class="hljs-comment"># eslint config</span>
├── .eslintignore               <span class="hljs-comment"># eslint ignore rules</span>
├── .gitignore                  <span class="hljs-comment"># sensible defaults for gitignore</span>
├── .postcssrc.js               <span class="hljs-comment"># postcss config</span>
├── index.html                  <span class="hljs-comment"># index.html template</span>
├── package.json                <span class="hljs-comment"># build scripts and dependencies</span>
└── README.md                   <span class="hljs-comment"># Default README file</span>
</code></pre>

]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;构建&quot;&gt;&lt;a href=&quot;#构建&quot; class=&quot;headerlink&quot; title=&quot;构建&quot;&gt;&lt;/a&gt;构建&lt;/h1&gt;&lt;p&gt;使用命令行构建&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue对象属性</title>
    <link href="http://yoohannah.github.io/post/vue/basic/vueprops.html"/>
    <id>http://yoohannah.github.io/post/vue/basic/vueprops.html</id>
    <published>2018-12-22T03:40:37.000Z</published>
    <updated>2018-12-22T04:53:44.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="el"><a href="#el" class="headerlink" title="el"></a>el</h1><p>其值为vue模板挂载ID,用于标识vue的APP template挂载在index.html的什么位置</p>
<h1 id="data"><a href="#data" class="headerlink" title="data"></a>data</h1><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><h1 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h1><p>通过&#123; &#123;&#125;&#125;}插值的时候,可以在大括号里面添加一个简单的计算表达式，从而将计算结果插入,但是对于复杂的计算,需要执行多个计算表达式时不能放在大括号里面的，为方便绑定，在computed属性中定义计算属性A，A是一个函数用到变量b，然后将该A属性插入，从而实现相关值b变化，插入值A随之响应的效果</p>
<p>相当于计算属性因为依赖项改变而执行计算，将计算结果插入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">例</div><div class="line"> &lt;p&gt;Original data: &quot;&#123;&#123; value &#125;&#125;&quot;&lt;/p&gt;</div><div class="line"> &lt;p&gt;Computed result: &quot;&#123;&#123; doubleValue &#125;&#125;&quot;&lt;/p&gt;</div><div class="line"> &lt;button @click=&apos;changeValue&apos;&gt;&lt;button&gt;</div><div class="line"> </div><div class="line">  export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        value: 10</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">        doubleValue: function() &#123;</div><div class="line">            return this.value * 2</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    method: &#123;</div><div class="line">        changeValue: function() &#123;</div><div class="line">            this.value++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> //当value 变化时，doubleValue通过运算将结果插入</div></pre></td></tr></table></figure></p>
<p>与method区别</p>
<p>也可以在大括号里面调用method中定义的方法，达到计算响应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&#123;&#123;doubleVlue()&#125;&#125;&lt;/p&gt;</div><div class="line">&lt;button @click=&apos;changeValue&apos;&gt;&lt;button&gt;</div><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        value: 10</div><div class="line">    &#125;,</div><div class="line">    method: &#123;</div><div class="line">        doubleValue: function() &#123;</div><div class="line">            return this.value * 2</div><div class="line">        &#125;,</div><div class="line">        changeValue: function() &#123;</div><div class="line">            this.value++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>当计算属性函数依赖的值不发生变化时，每次调用计算属性都会去取最后一次运算的结果，即读取缓存的结果</p>
<p>比如有一个计算属性A需要遍历一个庞大的数组然后得到一个结果，而这个结果则用于其他计算，这样我们就不需要每次去运算A属性函数得到结果，直接读取缓存结果即可</p>
<p>但如果属性A结果的得来是通过运行method方法，那么每次调用A就会进行计算一次，就会造成很大开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//computed方式</div><div class="line">&lt;p&gt;Original data: &quot;&#123;&#123; value &#125;&#125;&quot;&lt;/p&gt;</div><div class="line">&lt;p&gt;Computed result: &#123;&#123; double &#125;&#125;&lt;/p&gt;</div><div class="line">&lt;button @click=&apos;changeValue&apos;&gt;&lt;button&gt;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        value: 10</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">      double: function() &#123;</div><div class="line">        return  this.value + this.doubleValue</div><div class="line">      &#125;,</div><div class="line">      doubleValue: function() &#123;</div><div class="line">        console.log(&apos;double&apos;) //只打印一次</div><div class="line">        return  2</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    method: &#123;</div><div class="line">        changeValue: function() &#123;</div><div class="line">            this.value++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">//method方式</div><div class="line"></div><div class="line">&lt;p&gt;Original data: &quot;&#123;&#123; value &#125;&#125;&quot;&lt;/p&gt;</div><div class="line">&lt;p&gt;Computed result: &#123;&#123; value + doubleValue() &#125;&#125;&lt;/p&gt;</div><div class="line">&lt;button @click=&apos;changeValue&apos;&gt;1234&lt;button&gt;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        value: 10</div><div class="line">    &#125;,</div><div class="line">    method: &#123;</div><div class="line">        doubleValue: function() &#123;</div><div class="line">            console.log(&apos;double&apos;) //value 改变一次，打印一次,即函数会被执行一次</div><div class="line">            return 2</div><div class="line">        &#125;,</div><div class="line">        changeValue: function() &#123;</div><div class="line">            this.value++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>计算属性还可以设置getter和setter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  fullName: &#123;</div><div class="line">    // getter</div><div class="line">    get: function () &#123;</div><div class="line">      return this.firstName + &apos; &apos; + this.lastName</div><div class="line">    &#125;,</div><div class="line">    // setter</div><div class="line">    set: function (newValue) &#123;</div><div class="line">      var names = newValue.split(&apos; &apos;)</div><div class="line">      this.firstName = names[0]</div><div class="line">      this.lastName = names[names.length - 1]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//给fullName设置值的时候,比如fullName = &apos;John Doe&apos; 时，setter 会被调用，firstName 和 lastName 也会相应地被更新</div></pre></td></tr></table></figure></p>
<h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><p>定义某个变量发生变化时需要执行的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;Original data: &quot;&#123;&#123; value &#125;&#125;&quot;&lt;/p&gt;</div><div class="line">&lt;p&gt;Computed result: &#123;&#123; result &#125;&#125;&lt;/p&gt;</div><div class="line">&lt;button @click=&apos;changeValue&apos;&gt;1234&lt;button&gt;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        value: 10</div><div class="line">        result: 0</div><div class="line">    &#125;,</div><div class="line">    watch: &#123;</div><div class="line">        value: function() &#123;</div><div class="line">            this.result +=10</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    method: &#123;</div><div class="line">        changeValue: function() &#123;</div><div class="line">            this.value++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">//当value发生变化的时候，就会执行watch绑定的函数，从而可以让result发生响应</div></pre></td></tr></table></figure></p>
<p>对比computed属性,假设一个结果需要依赖多个变量，如果使用watch方法则需要定义多个响应函数，而且响应函数是重复的，而如果使用computed属性则只需要定义一次即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">例</div><div class="line">//computed方式</div><div class="line">&lt;p&gt;Original data: &quot;&#123;&#123; value &#125;&#125;&quot;&lt;/p&gt;</div><div class="line">&lt;p&gt;Computed result: &#123;&#123; result &#125;&#125;&lt;/p&gt;</div><div class="line">&lt;button @click=&apos;changeValue&apos;&gt;1234&lt;/button&gt;</div><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        value: 10,</div><div class="line">        val:1</div><div class="line">    &#125;,</div><div class="line">   computed: &#123;</div><div class="line">      result: function() &#123;</div><div class="line">          return this.val + this.value</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    method: &#123;</div><div class="line">        changeValue: function() &#123;</div><div class="line">            this.value++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">//watch方式</div><div class="line">&lt;p&gt;Original data: &quot;&#123;&#123; value &#125;&#125;&quot;&lt;/p&gt;</div><div class="line">&lt;p&gt;Computed result: &#123;&#123; result &#125;&#125;&lt;/p&gt;</div><div class="line">&lt;button @click=&apos;changeValue&apos;&gt;1234&lt;/button&gt;</div><div class="line"></div><div class="line">export default &#123;</div><div class="line">    data() &#123;</div><div class="line">        value: 10,</div><div class="line">        val:1</div><div class="line">    &#125;,</div><div class="line">    watch: &#123;</div><div class="line">      value: function() &#123;</div><div class="line">         this.result = this.val + this.value</div><div class="line">      &#125;,</div><div class="line">      val: function() &#123;</div><div class="line">          this.result = this.val + this.value</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    method: &#123;</div><div class="line">        changeValue: function() &#123;</div><div class="line">            this.value++</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h1><h1 id="components"><a href="#components" class="headerlink" title="components"></a>components</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;el&quot;&gt;&lt;a href=&quot;#el&quot; class=&quot;headerlink&quot; title=&quot;el&quot;&gt;&lt;/a&gt;el&lt;/h1&gt;&lt;p&gt;其值为vue模板挂载ID,用于标识vue的APP template挂载在index.html的什么位置&lt;/p&gt;
&lt;h1 id=&quot;data&quot;&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoohannah.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>定时器</title>
    <link href="http://yoohannah.github.io/post/knowledge/clock.html"/>
    <id>http://yoohannah.github.io/post/knowledge/clock.html</id>
    <published>2018-12-22T03:40:37.000Z</published>
    <updated>2018-12-22T05:00:44.717Z</updated>
    
    <content type="html"><![CDATA[<p>1.使用 setInterval<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">this.timerID = setInterval(fn, time);</div><div class="line">clearInterval(this.timerID);</div></pre></td></tr></table></figure></p>
<p> 2.angular 中使用 $interval<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">this.timerID = $interval(fn, time);</div><div class="line">$interval.cancel(this.timerID)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.使用 setInterval&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;
    
    </summary>
    
    
      <category term="knowledge" scheme="http://yoohannah.github.io/tags/knowledge/"/>
    
  </entry>
  
  <entry>
    <title>flex-drection属性使用</title>
    <link href="http://yoohannah.github.io/post/knowledge/flex-direction.html"/>
    <id>http://yoohannah.github.io/post/knowledge/flex-direction.html</id>
    <published>2018-12-22T03:29:37.000Z</published>
    <updated>2018-12-22T03:29:54.580Z</updated>
    
    <content type="html"><![CDATA[<p>在display:flex基础上使用flex-direction,可用于多子模块布局</p>
<p>flex-direction可以为四个值</p>
<p>row:水平并行排列在左侧</p>
<p>row-reverse：水平并行排列在右侧，顺序与书写顺序相反,最前的在最右边</p>
<p>column:垂直排列在上方,相当于display:block状态下模块默认布局</p>
<p>column-reverse:垂直排列在下方,顺序与书写顺序相反，最前的在最下边</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">        #main1 </div><div class="line">        &#123;</div><div class="line">            width:200px;</div><div class="line">            height: 300px;</div><div class="line">            border:1px solid black;</div><div class="line">            display: flex;</div><div class="line">            flex-direction:row;</div><div class="line">        &#125;</div><div class="line">        #main2 </div><div class="line">        &#123;</div><div class="line">            width:200px;</div><div class="line">            height: 300px;</div><div class="line">            border:1px solid black;</div><div class="line">            display: flex;</div><div class="line">            flex-direction:row-reverse;</div><div class="line">        &#125;</div><div class="line">        #main3 </div><div class="line">        &#123;</div><div class="line">            width:200px;</div><div class="line">            height: 300px;</div><div class="line">            border:1px solid black;</div><div class="line">            display: flex;</div><div class="line">            flex-direction:column;</div><div class="line">        &#125;</div><div class="line">        #main4 </div><div class="line">        &#123;</div><div class="line">            width:200px;</div><div class="line">            height: 300px;</div><div class="line">            border:1px solid black;</div><div class="line">            display: flex;</div><div class="line">            flex-direction:column-reverse;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h4&gt;This is an example for flex-direction:row(default)&lt;/h4&gt;</div><div class="line">&lt;div id=&quot;main1&quot;&gt;</div><div class="line">    &lt;div style=&quot;background-color:red;&quot;&gt;RED&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightblue;&quot;&gt;BLUE&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightgreen;&quot;&gt;GREEN&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;h4&gt;This is an example for flex-direction:row-reverse&lt;/h4&gt;</div><div class="line">&lt;div id=&quot;main2&quot;&gt;</div><div class="line">    &lt;div style=&quot;background-color:red;&quot;&gt;RED&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightblue;&quot;&gt;BLUE&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightgreen;&quot;&gt;GREEN&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;h4&gt;This is an example for flex-direction:column&lt;/h4&gt;</div><div class="line">&lt;div id=&quot;main3&quot;&gt;</div><div class="line">    &lt;div style=&quot;background-color:red;&quot;&gt;RED&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightblue;&quot;&gt;BLUE&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightgreen;&quot;&gt;GREEN&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;h4&gt;This is an example for flex-direction:column-reverse&lt;/h4&gt;</div><div class="line">&lt;div id=&quot;main4&quot;&gt;</div><div class="line">    &lt;div style=&quot;background-color:red;&quot;&gt;RED&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightblue;&quot;&gt;BLUE&lt;/div&gt;</div><div class="line">    &lt;div style=&quot;background-color:lightgreen;&quot;&gt;GREEN&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在display:flex基础上使用flex-direction,可用于多子模块布局&lt;/p&gt;
&lt;p&gt;flex-direction可以为四个值&lt;/p&gt;
&lt;p&gt;row:水平并行排列在左侧&lt;/p&gt;
&lt;p&gt;row-reverse：水平并行排列在右侧，顺序与书写顺序相反,最前的在最右
    
    </summary>
    
    
      <category term="css" scheme="http://yoohannah.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>数组的map和reduce</title>
    <link href="http://yoohannah.github.io/post/js/map&amp;reduce.html"/>
    <id>http://yoohannah.github.io/post/js/map&amp;reduce.html</id>
    <published>2018-12-22T03:25:37.000Z</published>
    <updated>2018-12-22T05:09:12.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的map方法"><a href="#数组的map方法" class="headerlink" title="数组的map方法"></a>数组的map方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,3,4,5];</div><div class="line">let arr1 = arr.map(function(val,index,arr)&#123;</div><div class="line">	console.log(val,index,arr)</div><div class="line">	return val+1</div><div class="line">&#125;)</div><div class="line">console.log(arr1)//[2, 3, 4, 5, 6]</div><div class="line">console.log(arr) //[1, 2, 3, 4, 5]</div></pre></td></tr></table></figure>
<p>在map中可以传递一个函数，数组的每一项作为参数调用这个函数，然后返回根据该数组项得到的结果，每一个数组项返会一个结果，从而组成新的数组</p>
<p>函数的参数有三个，第一项为数组按序传进的一个值，该值的index和数组本身</p>
<p>整个结果产生新数组，原来数组不变</p>
<h1 id="数组的reduce-方法"><a href="#数组的reduce-方法" class="headerlink" title="数组的reduce 方法"></a>数组的reduce 方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">例1.</div><div class="line">let arr = [1,2,3];</div><div class="line">let result = arr.reduce(function(preresult,item)&#123;</div><div class="line">	return preresult += item;</div><div class="line">&#125;,0)</div><div class="line">console.log(result)   //6</div><div class="line"></div><div class="line">例2.</div><div class="line">let result4 = arr.reduce(function(preresult,item)&#123;</div><div class="line">    preresult.name += item;</div><div class="line">	return preresult</div><div class="line">&#125;,&#123;name:0&#125;)</div><div class="line">console.log(result4); //&#123;name:6&#125;</div></pre></td></tr></table></figure>
<p>reduce 用于对数组每一项进行累计计算，每一项计算结果作为参数参加数组下一项的计算,最终返回计算结果</p>
<p>例1中单纯对数组每一项进行叠加处理，返回叠加结果<br>例2同样进行叠加只是叠加结果放在对象中返回</p>
<p>reduce(callback(),initval)</p>
<p>需要两个参数，一个是用于累计计算的callback函数，一个是初始值，见上两例</p>
<p>callback()函数有四个参数依次为：</p>
<p>preVal （上一次调用回调返回的值，或者是提供的初始值（initialValue））</p>
<p>currentValue （数组中当前被处理的元素）</p>
<p>index （当前元素在数组中的索引）</p>
<p>array （调用 reduce 的数组）</p>
<p>初始值会在第一次调用时当作回调函数callback的第一个参数使用</p>
<p>希望返回值是什么类型的数据，初始值就要设置为什么样的类型，callback返回值也是该类型；或者说是在这里设置返回值的类型</p>
<p>整个处理过程就是拿初始值initval和数组第一个值在callback里面进行处理，返回结果result,result当作callback的preval参数和数组第二个元素传入callback在处理，直到数组全部元素被处理完，返回一个最终处理结果</p>
<p>高级应用<br>对对象数组元素进行累计计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var reducers = &#123;  </div><div class="line">  totalInEuros : function(state, item) &#123;</div><div class="line">    return state.euros += item.price * 0.897424392;</div><div class="line">  &#125;,</div><div class="line">  totalInYen : function(state, item) &#123;</div><div class="line">    return state.yens += item.price * 113.852;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var manageReducers = function(reducers) &#123;</div><div class="line">  return function(state, item) &#123;</div><div class="line">    return Object.keys(reducers).reduce(</div><div class="line">      function(nextState, key) &#123;</div><div class="line">        reducers[key](state, item);</div><div class="line">        return state;</div><div class="line">      &#125;,</div><div class="line">      &#123;&#125;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bigTotalPriceReducer = manageReducers(reducers);</div><div class="line">var initialState = &#123;euros:0, yens: 0&#125;;</div><div class="line">var items = [&#123;price: 10&#125;, &#123;price: 120&#125;, &#123;price: 1000&#125;];</div><div class="line">var totals = items.reduce(bigTotalPriceReducer, initialState);</div><div class="line">console.log(totals);</div><div class="line">//&#123;euros: 1014.08956296, yens: 128652.76&#125;</div></pre></td></tr></table></figure></p>
<p>该例的目的是将对象数组items的元素属性price进行不同处理操作然后将结果分别保存到结果对象的属性中</p>
<p>处理的关键是manageReducers返回的作为items callback的函数bigTotalPriceReducer，</p>
<p>处理思路是items每用一个元素调用callback时,callback的处理过程是将这个元素作为参数调用reducers 对象里面设置的每一个处理函数,</p>
<p>调用reducers处理函数的过程同样使用一个reduce方法进行处理</p>
<p>Object.keys(obj)方法返回对象键值组成的数组</p>
<p>当items的元素参加完reducers所有处理函数后,返回的结果参加下一个元素的计算最终返回结果</p>
<p>扩展：</p>
<p>1.在reduces中设置对items不同属性的计算，从而得到不同属性的结算结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var reducers = &#123;  </div><div class="line">  totalInEuros : function(state, item) &#123;</div><div class="line">    return state.euros += item.p1;</div><div class="line">  &#125;,</div><div class="line">  totalInYen : function(state, item) &#123;</div><div class="line">    return state.yens += item.price * 113.852;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bigTotalPriceReducer = manageReducers(reducers);</div><div class="line">var initialState = &#123;euros:0, yens: 0&#125;;</div><div class="line">var items = [&#123;price: 10,p1:1&#125;, &#123;price: 120,p1:1&#125;, &#123;price: 1000,p1:1&#125;];</div><div class="line">var totals = items.reduce(bigTotalPriceReducer, initialState);</div><div class="line">console.log(totals);</div><div class="line">//&#123;euros: 3, yens: 128652.76&#125;</div></pre></td></tr></table></figure>
<p>2.计算对象数组属性值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var manageReducers = function(state, item) &#123;</div><div class="line">    return Object.keys(item).reduce(</div><div class="line">      function(nextState, key) &#123;</div><div class="line">        state[key] +=item[key];</div><div class="line">        return state;</div><div class="line">      &#125;,</div><div class="line">      &#123;&#125;</div><div class="line">    );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var initialState = &#123;price:0, p1: 0&#125;;</div><div class="line">var items = [&#123;price: 10,p1:1&#125;, &#123;price: 120,p1:1&#125;, &#123;price: 1000,p1:1&#125;];</div><div class="line">var totals = items.reduce(manageReducers, initialState);</div><div class="line">console.log(totals);</div><div class="line">//&#123;price: 1130, p1: 3&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://segmentfault.com/a/1190000010731933" target="_blank" rel="external">参阅资料</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组的map方法&quot;&gt;&lt;a href=&quot;#数组的map方法&quot; class=&quot;headerlink&quot; title=&quot;数组的map方法&quot;&gt;&lt;/a&gt;数组的map方法&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js 知识点 一</title>
    <link href="http://yoohannah.github.io/post/js/js1.html"/>
    <id>http://yoohannah.github.io/post/js/js1.html</id>
    <published>2018-12-08T01:29:37.000Z</published>
    <updated>2019-01-22T13:48:53.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-lt-script-gt-标签几个属性"><a href="#1-lt-script-gt-标签几个属性" class="headerlink" title="1.&lt; script &gt; 标签几个属性"></a>1.&lt; script &gt; 标签几个属性</h1><p><b>async :</b>立即异步下载，因此不保证能够按指定的先后顺序执行，但会在load事件前，DOMContentLoad前后执行<br><b>defer :</b>延迟执行，也不保证按顺序执行，在DOMContentLoad前后执行<br><b>src :</b>外部文件链接<br><b>charset :</b>src指定代码的字符集，防止出现乱码<br><b>language :</b>已废弃，表示脚本语言，<br><b>type :</b>值为脚本语言内容类型（MIME），language替代属性，服务器传递过来类型为application/x-javascript需要注意，一个是可能导致脚本被忽略，另一个是可能触发浏览器XHTML标准模式；另外外链文件不是js文件时，一定要设置该值</p>
<h1 id="2-js-代码执行过程"><a href="#2-js-代码执行过程" class="headerlink" title="2.js 代码执行过程"></a>2.js 代码执行过程</h1><p>包括两个部分一个是编译，或者叫预处理过程，一个是执行<br>编译过程 首先会创建一个全局作用域，然后进行词法分析，<br>词法分析过程会涉及到变量提升和函数声明提前处理，<br>即词法分析到变量声明会先判断当前域到全局域有没有该变量声明，如果有，就会将该变量挂到该作用域的对象上，<br>如果到全局域都没有则以全局为背景，新建该变量，并为其分配内存，<br>对于基本类型，变量中会保存它的值，对于对象，变量中会保存值所在内存的内存地址，<br>在一定场景下，这里就相当于发生了变量提升，把变量从局部提升到了全局，或者将声明提前到了使用之前，<br><b>避免变量提升</b>可以使用es6的let 关键字或者使用立即执行实现变量声明使用，但要注意使用let重复声明会报错，var 会同名覆盖；<br>当遇到函数声明时，会直接按声明顺序，将声明提前到代码顶端，<br><b>重复声明</b> 的函数会被后者覆盖，<br>如果变量名与函数名相同，则无论原来词法位置如何，先将函数声明提前到顶端，不再进行变量声明，变量名在哪赋值，则原函数在哪被覆盖，<br>覆盖之前调用使用原函数<br>提前之后会为函数创建作用域，<br>这时创建的作用域就是函数的 【【scope】】属性，保存着指向父域到全局域的指针<br>（指针就是指向活动对象的一个地址，全局域浏览器环境就是windows,nodejs环境就是global）<br>将来执行时会根据此指针建立作用域链，作用域链就是指针列表，指向不同层级作用域的内存，在里面取值<br>以上就基本上是编译过程，除了一些特定的编译规则，编译过程还会会使用大量技巧进行优化提升编译速度<br>但在使用js时，需要注意try-catch,with和eval三个语法关键字的使用，因为在使用它们时，会创建块级作用域，<br>破坏掉编译器原有的创建管理作用域的规则，在编译时，编译器也就不会对其中的代码进行优化，最终导致性能变差</p>
<p>运行过程，基本就是在运行函数，函数在运行时会首先根据【【scope】】属性拿到父域到全局的指针，创建指针列表即作用域链，<br>然后创建函数执行的局部作用域，将函数中声明的变量挂到局部作用域活动对象上，然后将局部作用域指针推向作用域链前端，<br>在用到变量值时，会根据作用域链依次查找取值<br>函数执行结束后，局部活动对象被销毁，作用域链被销毁，进行垃圾回收<br>但是对于声明在一个函数内部的函数来说，这个声明的函数在声明时，就会包含其父域的活动对象，<br>因此在外部使用该函数时，可以访问到其父域的变量，实现了父域访问子域变量，延长了变量的使用范围，也就是常见的闭包现象，<br>缺点就是闭包的函数执行完毕后，因为本身【【scope】】会指向父域的活动对象，所以父域的活动对象始终不会被回收,除非闭包函数被销毁<br>从而有可能造成内存泄露，为什么说有可能，因为父活动对象占的内存其实是比较小的，造成内存泄露的真正原因是使用闭包易造成循环引用，<br>尤其是闭包作用域中保存dom结点时，如果是在IE中，dom和bom都是以C++的COM对象保存的，垃圾回收机制是技术策略，<br>因此循环引用的话，永远都不会被回收</p>
<p>补充，对于未以分号结尾的语句，会采用能合就合的原则，即，会尝试和下一行语句合并执行，如果能合并执行就合并执行，<br>不能合并执行就在中间加分号再执行，如果再执行不了就会报错<br>好处就是对于条件判断语句可进行一行一行判断<br>坏处就是如果下一行以大括号开头，上一行语句就会变成函数，导致出现意想不到的结果<br>两个例外，<br>对于return，break,continue语句不会做尝试合并；<br>对于++，–自增自减符后没有分号，上一行也没分号情况，自增自减会和下一行合并，上一行自行添加分号</p>
<p>以上即是我所了解的js运行机制</p>
<h1 id="3-关于对象继承"><a href="#3-关于对象继承" class="headerlink" title="3.关于对象继承"></a>3.关于对象继承</h1><p>3.0  new 操作符调用构造函数 执行过程<br>  1.创建或者构造一个全新的对象<br>  2.将构造函数的作用域赋给这个新的对象,<br>  3.执行构造函数 (为这个新对象添加属性) ，第二，三步相当于func.call(newobj)<br>  4.如果构造函数没有返回值或返回值非对象，则返回新对象，否则返回构造函数return的对象</p>
<p>3.1 继承的6种方式及优缺点<br>    <b>第一种原型链方式</b>，子类的原型对象指向父类的实例<br>    缺点<br>        给原型添加方法必须要在替换原型的语句之后；<br>        不能实现多继承（原型指向多个父对象）；<br>        所有属性共享<br>        无法传递参数到父类进行初始化<br>    <b>第二种借助构造函数</b>，在子类构造函数中使用call或者apply执行父类构造函数<br>    优点<br>        可以实现多继承<br>        可以传递参数<br>        方法属性不共享<br>    缺点<br>        只能继承构造函数中属性，不能继承原型上方法，不能复用方法<br>        实例仅为子类实例，不是父类实例<br>    <b>第三种组合继承</b>，以上两组结合在一起，两种方式都执行<br>    缺点<br>        要调用两次父类构造函数，影响性能<br>        实例属性和原型属性各占一份，同名覆盖机制，重复占内存，没必要<br>    <b>第四种原型式继承</b>，借助object()或者object.create()函数,缺点同原型链方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;</div><div class="line"> function F()&#123;&#125;</div><div class="line"> F.prototype = o;</div><div class="line"> return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><b>第五种寄生式继承</b>，利用原型式继承和增强对象过程的封装函数创建子类，缺点同原型链方式<br><b>第六种寄生组合式继承</b>，保留借助构造函数部分，原型部分功能借助中间函数处理，<br>中间函数借助object拿到父类prototype，给到子类的prototype,从而完美解决组合继承的缺点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType,superType)&#123;</div><div class="line">  var prototype = object(superType.prototype)</div><div class="line">  prototype.constructor = subType</div><div class="line">  subType.prototype = prototype</div><div class="line">&#125;</div><div class="line">subType.prototype.__proto__ = superType</div></pre></td></tr></table></figure>
<p>3.2 es6 使用class extend实现继承<br>使用class声明构造函数时，本来挂在this上的属性，放在constructor（）函数里面执行初始化，<br>挂在prototype上的方法直接放在class里面声明</p>
<p>使用extend继承时，需要在constructor里面先执行super函数才能使用this关键字，<br>增强方法同样直接在class中和constructor并列声明，相当于挂在prototype上</p>
<p>注意super函数只能在consructor中运行；super用作对象在constructor中使用时，相当于this,<br>添加属性会添加在当前对象上，运行函数时会调用继承的父类的方法</p>
<p>还有就是class extend继承null和 什么也不继承是，相当于继承Function.prototype<br>继承Object时，子类就相当于object 的复制，子类实例就是object实例</p>
<h1 id="4-关于this-四种使用场景"><a href="#4-关于this-四种使用场景" class="headerlink" title="4.关于this 四种使用场景"></a>4.关于this 四种使用场景</h1><p>   普通函数执行，指向全局作用域<br>   对象属性方法调用，指向调用对象<br>   call,apply中强制绑定对象，this执行绑定的对象<br>   构造函数中this指向构造的新对象<br>   （箭头函数中this,指向词法作用域的父域）</p>
<h1 id="5-js文件位置"><a href="#5-js文件位置" class="headerlink" title="5.js文件位置"></a>5.js文件位置</h1><p>   放html底部原因：<br>   下载解析执行过程是阻断式的，会停止页面渲染，造成白屏，影响用户体验；<br>   另外JS中如果有对dom的操作，页面中还没有dom,获取不到，是不符合逻辑的，会报错</p>
<p>   哪些js功能文件可以放顶部：<br>   与css相关的js,比如rem单位的换算，需要根据根结点进行设置<br>   使用的框架需要在根结点将浏览器支持的样式罗列出来</p>
<h1 id="6-什么情况下用内部文件，内部文件比外部文件好处在哪？"><a href="#6-什么情况下用内部文件，内部文件比外部文件好处在哪？" class="headerlink" title="6.什么情况下用内部文件，内部文件比外部文件好处在哪？"></a>6.什么情况下用内部文件，内部文件比外部文件好处在哪？</h1><p>   内部文件相比外部文件最大好处就是性能提升，因为访问外部文件时，不管文件大小都会造成一次网络请求链接，请求服务器，下载文件，<br>   解析文件，除了文件本身代码外，还要处理文件头文件尾的请求，增加了链接数，从而造成性能影响<br>   对于功能短小精悍，不会被到处复用的js代码不适合采用外部文件，应该采用内部文件写法，尤其对手机端页面有性能提升</p>
<h1 id="7-开发过程避免缓存方法"><a href="#7-开发过程避免缓存方法" class="headerlink" title="7.开发过程避免缓存方法"></a>7.开发过程避免缓存方法</h1><p>   在浏览器开启禁用缓存的模式<br>   手动清缓存 ctrl+shfit+del<br>   引用的文件名添加随机数，浏览器根据文件名不同，就会重新获取资源更新缓存</p>
<h1 id="8-使用严格模式弊端及解决办法"><a href="#8-使用严格模式弊端及解决办法" class="headerlink" title="8.使用严格模式弊端及解决办法"></a>8.使用严格模式弊端及解决办法</h1><p>   在代码压缩时，’use strict’ 这一行可能不在位于第一行，<br>   或者后续代码不需要在严格模式下执行，被压缩在了严格模式范围内，导致了全部以严格模式执行</p>
<p>   解决办法就是，将需要严格模式执行的代码放在匿名函数中，形成代码块，在函数中使用严格模式</p>
<h1 id="9-立即执行函数好处"><a href="#9-立即执行函数好处" class="headerlink" title="9.立即执行函数好处"></a>9.立即执行函数好处</h1><p>   避免变量污染：有些变量仅在小功能内使用，将小功能封装起来，就可以避免这些变量暴露到全局，<br>   另外函数本身没有函数名，不会增加全局变量<br>   提升性能：功能所需变量全都在函数内时，查找变量快<br>   有利于压缩：一部分代码执行需要用到的变量变量名太长，将这段代码封装成立即执行函数，将长变量名以参数形式传进去<br>   避免全局命名冲突：一段代码需要用到两个代表不同功能但名称相同的变量，可以将该段代码封装成立即执行函数，<br>   将其中一个变量以参数形式传递进来，达到换名的目的<br>   保存闭包状态：循环执行异步代码时，将异步代码用立即执行函数包裹，函数内可保存本次循环的状态<br>   改变代码运行顺序：umd,通用模块规范，function（fn）{fn()}()</p>
<h1 id="10-变量类型"><a href="#10-变量类型" class="headerlink" title="10.变量类型"></a>10.变量类型</h1><p>   根据当前变量的值的类型确定<br>   如果想要进行标记，方法有三种<br>   初始化时指定相应类型值<br>   使用匈牙利标记法，用单字母表示类型，添加到变量命中，例sName 代表string类型<br>   使用注释，变量声明时，在旁边添加注释</p>
<h1 id="11-null-vs-undefined"><a href="#11-null-vs-undefined" class="headerlink" title="11.null vs undefined"></a>11.null vs undefined</h1><p>   转数字时，null –&gt;0;undefined–&gt;NaN<br>   undefined可以当做windows对象上的一个属性，null不行</p>
<h1 id="12-类型转换"><a href="#12-类型转换" class="headerlink" title="12. 类型转换"></a>12. 类型转换</h1><p>基本类型包括，undefined，null,boolean,string,number</p>
<p>基本类型 —&gt; boolean   Boolean(someval) 相当于 !!someval<br>undefined，null,NaN,’’,+0,-0 —&gt; false<br>其他 —&gt; true </p>
<p>基本类型 —&gt; string  String（someval）相当于 someval+’’<br>一般情况直接加引号<br>[] —&gt; ‘’<br>{} —&gt; ‘[object object]’</p>
<p>基本类型—&gt;number  + someval  相当于 Number（someval）<br>undefined,{} —&gt; NaN<br>false, null,’’,[],—&gt; 0<br>true —&gt; 1<br>‘123’ —&gt; 123<br>‘abc’ —&gt; NaN<br>[]—&gt; toString —&gt; ‘’ —&gt; 0<br>{} —&gt; valueOf —&gt; {} —&gt; toString —&gt; ‘[object object]’ —&gt; NaN</p>
<p>基本类型 —&gt;对象<br>undefined，null —&gt; {}<br>true/123 —&gt; {initval:true/123}<br>‘abc’ —&gt; {initval:’abc’,length:3,0:’a’,1:’b’,2:’c’}</p>
<p>对象 —&gt;基本类型</p>
<p>关于–对象分类：<br>内部对象（错误对象；常用对象：Boolean,Number,String,Object,Array,Function,Date,Exec;内置对象：Math,global,Json）<br>宿主对象：windows,document<br>自定义对象</p>
<p>关于–属性访问<br>obj.someprop—&gt;检查obj是不是null/undefined—&gt;是|不是—&gt;报错|是不是Object,不是的话转object—&gt;取值<br>obj[someval]—&gt;检查obj是不是null/undefined—&gt;是|不是—&gt;报错|是不是Object,不是的话转object—&gt;计算someval拿到string—&gt;取值</p>
<p>Boolean —&gt;true<br>Number —&gt;基本类型转的|{}/{a:1}|Date—&gt;相应值|NaN|时间戳<br>Array.toString:数组每一项转字符串<br>Function.toString:原代码字符串形式<br>Date.toString:日期和时间组合形式<br>Exec.toString:正则字符串形式</p>
<p>运算转换</p>
<p>Number()参数不能有非数字<br>parseInt()参数只能为字符串，非字符串会进行强制转化字符串，可含非数字，但不能以非数字开头<br>一元操作符对任何数据类型有效，得到数字</p>
<p>&#43;二元运算侧重转字符串，然后进行字符串拼接<br>其中一个为字符串或者两个都是对象时，转字符串拼接<br>undefined,null,Boolean,数字混合运算+时，会被转数字再计算<br>{}为第一个运算值时，会被当做函数结束，不参与计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">null + null --&gt; 0</div><div class="line">undefined + null --&gt; NaN</div><div class="line">[] + [] --&gt; &apos;&apos;</div><div class="line">1 + [1,2] --&gt; &apos;11,2&apos;</div><div class="line">1 + &#123;a:1&#125; --&gt; &apos;1[object object]&apos;</div><div class="line">&#123;a:1&#125; + 1 --&gt; 1</div><div class="line">&#123;&#125; + &#123;&#125; --&gt; NaN</div><div class="line">(&#123;&#125;) + &#123;&#125; --&gt; &apos;[object object][object object]&apos;</div><div class="line">[] + &#123;&#125; --&gt; &apos;[object object]&apos;</div><div class="line">&#123;&#125; + [] --&gt; 0</div><div class="line">var a = &#123;&#125;</div><div class="line">a + a --&gt;&apos;[object object][object object]&apos;</div></pre></td></tr></table></figure></p>
<p>&#42;/- 转数字，进行相减,如果不能转数字，返回NaN</p>
<p>&gt;/&lt; 侧重转数字<br>string &lt; string 字典比较<br>非字符串&lt;非字符串/字符串 都转数字然后比较</p>
<p>string == number 字符串转数字<br>boolean == 其他类型 二者转数字然后比较<br>null == undefined —&gt;true undefined和null只与对方和自己==比较时为true，其他均为false<br>null === undefined —&gt;false<br>非对象 == 对象 与数字比较object转数字，与字符串比较二者转数字再比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&apos;0&apos; == null  //false</div><div class="line">&apos;0&apos; == undefined  //false</div><div class="line">&apos;0&apos; == false  //true</div><div class="line">&apos;0&apos; == NaN  //false</div><div class="line">&apos;0&apos; == 0  //true</div><div class="line">&apos;0&apos; == &apos;&apos;  //false</div><div class="line"></div><div class="line">false == null  //false</div><div class="line">false == undefined  //false</div><div class="line">false == NaN  //false</div><div class="line">false == 0  //true</div><div class="line">false == &apos;&apos;  //true</div><div class="line">false == []  //true</div><div class="line">false == &#123;&#125; //false</div><div class="line"></div><div class="line">&apos;&apos; == null  //false</div><div class="line">&apos;&apos; == undefined  //false</div><div class="line">&apos;&apos; == NaN  //false</div><div class="line">&apos;&apos; == 0  //true</div><div class="line">&apos;&apos; == []  //true</div><div class="line">&apos;&apos; == &#123;&#125; //false</div><div class="line"></div><div class="line">0 == null  //false</div><div class="line">0 == undefined  //false</div><div class="line">0 == NaN  //false</div><div class="line">0 == []  //true</div><div class="line">0 == &#123;&#125; //false</div><div class="line"></div><div class="line">[] == ![] //true</div></pre></td></tr></table></figure></p>
<p>&amp;&amp;和|| 计算结果根据短路原则判断到了哪里，返回最后一个进行判断的值</p>
<p>运算符优先级<br>属性访问.<br>一元操作符（+，-，++，–）<br>二元操作符（+-*/）<br>比较（&gt;,&lt;)<br>相等（==，===，！=）<br>与&amp;&amp;，或||<br>三目运算符<br>赋值</p>
<p>运算符结合性<br>除了一元操作符，三目运算符和赋值是右结合，其他都是左结合</p>
<p>减少小数计算误差<br>尽量不使用小数进行比较或运算<br>转整数计算，再转回相应位数小数<br>使用toFixed()四舍五入<br>两个情境需要重复计算时，保证前后书写顺序</p>
<h1 id="13-数组相关方法"><a href="#13-数组相关方法" class="headerlink" title="13. 数组相关方法"></a>13. 数组相关方法</h1><p><img src="/image/arrmethod.jpg" alt="arrmethod"></p>
<h1 id="14-字符串相关方法"><a href="#14-字符串相关方法" class="headerlink" title="14.字符串相关方法"></a>14.字符串相关方法</h1><p><img src="/image/strmethod.jpg" alt="strmethod"></p>
<h1 id="15-日期相关方法"><a href="#15-日期相关方法" class="headerlink" title="15.日期相关方法"></a>15.日期相关方法</h1><p>   一共 33个<br>   set/get（UTC）FullYear,Month,Date,Hours,Minutes,Seconds,Millseconds<br>   set/get Time<br>   get(UTC) Day<br>   getTimezoneOffset</p>
<h1 id="16-Math三个舍入方法"><a href="#16-Math三个舍入方法" class="headerlink" title="16. Math三个舍入方法"></a>16. Math三个舍入方法</h1><p>  Math.ceil:比值大的最小整数<br>  Math.round:四舍五入<br>  Math.floor:比值小的最大整数</p>
<h1 id="17-setInterval-注意问题"><a href="#17-setInterval-注意问题" class="headerlink" title="17. setInterval 注意问题"></a>17. setInterval 注意问题</h1><p>累积效应<br>代码执行时间大于间隔时间，后续调用会进行累积，累积会在短时间内连续触发</p>
<p>当用于动画时，因与显示器刷新频率不统一会造成视觉卡顿，解决办法如下：<br>一种是使用CSS3创建动画，根据显示器刷新执行动画<br>另一种是使用 requestAnimationframe(function(){})函数，也是在显示器刷新时执行<br>可以解决CSS3无法实现的，例如滚动控制等效果</p>
<h1 id="18-关于DOM"><a href="#18-关于DOM" class="headerlink" title="18. 关于DOM"></a>18. 关于DOM</h1><p>   document 三个属性<br>   url：地址栏中URL<br>   domain:域名，跨域域名 X；父域名到子域名 X；<br>   referer:上一页URL,可在跳转时，判断与当前页是否在同一域，是的话，就可以back,否则 location.href其他页面<br>   dom.getAttribute(‘style’),得到样式字符串<br>   dom.style 得到到样式对象<br>   dom.getAttribute(‘onclick’) ,得到代码字符串<br>   dom.onclick 得到函数对象</p>
<p>   动态合集<br>   使用时可能会造成死循环<br>   使用框架如Jquery获取的合集不具有动态性<br>   使用 queryselect(all)()获取到的也是静态合集</p>
<p>   动态合集生成原理：<br>   浏览器通过DOM树预先缓存起来，获取时，浏览器会通过缓存直接注册，创建一个变量返回</p>
<p>   静态合集生成原理：<br>   获取标识是一个CSS选择器，浏览器会先去解析字符串，判断是一个CSS选择器，<br>   分析选择器并创建一个选择器结构，浏览器根据DOM树创建一个静态文件，即DOM树的一个快照<br>   然后拿选择器和快照进行对比，符合选择器就放到合集中，知道整个快照对比完，再把合集的快照返回</p>
<h1 id="19-事件"><a href="#19-事件" class="headerlink" title="19. 事件"></a>19. 事件</h1><p>   绑定方式</p>
<p>   直接通过HTML属性绑定<br>   缺点<br>   有可能响应函数还未被解析就被触发<br>   事件名和回调1对1，修改繁琐<br>   响应执行时，作用域为全局，不同浏览器解析规则不同，造成某些对象无法访问</p>
<p>   使用dom属性绑定<br>   冒泡阶段执行<br>   缺点<br>   只能绑定一个响应，后续赋值会被覆盖</p>
<p>   IE attachEvent/detachEvent绑定/解绑<br>   冒泡阶段执行<br>   绑定多个时按按绑定顺序的逆序执行</p>
<p>   addEventListener()/removeEventListener()绑定/解绑<br>   第三个参数为对象时，passive属性为true时，会针对touchstart,touchend等特定事件通过开启两个线程，<br>   一个执行浏览器默认行为，一个执行JS进行优化</p>
<p>   事件优先级<br>   浏览器在绑定事件而不是JS在绑定事件</p>
<p>   1.html标签绑定事件会被dom属性事件覆盖<br>   2.html标签优先执行，即使被属性事件覆盖，则执行被覆盖的属性事件<br>   3.仅有监听事件和属性事件时，按绑定顺序执行，即事件对象的冒泡事件可能会在捕获事件之前执行</p>
<p>   event对象属性<br>   curentTarget:响应函数绑定的对象<br>   target:发生事件的对象</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-lt-script-gt-标签几个属性&quot;&gt;&lt;a href=&quot;#1-lt-script-gt-标签几个属性&quot; class=&quot;headerlink&quot; title=&quot;1.&amp;lt; script &amp;gt; 标签几个属性&quot;&gt;&lt;/a&gt;1.&amp;lt; script &amp;gt; 
    
    </summary>
    
    
      <category term="js" scheme="http://yoohannah.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js 知识点 一</title>
    <link href="http://yoohannah.github.io/post/designMode/js1.html"/>
    <id>http://yoohannah.github.io/post/designMode/js1.html</id>
    <published>2018-12-08T01:29:37.000Z</published>
    <updated>2018-12-16T02:59:06.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-lt-script-gt-标签几个属性"><a href="#1-lt-script-gt-标签几个属性" class="headerlink" title="1.&lt; script &gt; 标签几个属性"></a>1.&lt; script &gt; 标签几个属性</h1><p><b>async :</b>立即异步下载，因此不保证能够按指定的先后顺序执行，但会在load事件前，DOMContentLoad前后执行<br><b>defer :</b>延迟执行，也不保证按顺序执行，在DOMContentLoad前后执行<br><b>src :</b>外部文件链接<br><b>charset :</b>src指定代码的字符集，防止出现乱码<br><b>language :</b>已废弃，表示脚本语言，<br><b>type :</b>值为脚本语言内容类型（MIME），language替代属性，服务器传递过来类型为application/x-javascript需要注意，一个是可能导致脚本被忽略，另一个是可能触发浏览器XHTML标准模式；另外外链文件不是js文件时，一定要设置该值</p>
<h1 id="2-js-代码执行过程"><a href="#2-js-代码执行过程" class="headerlink" title="2.js 代码执行过程"></a>2.js 代码执行过程</h1><p>包括两个部分一个是编译，或者叫预处理过程，一个是执行<br>编译过程 首先会创建一个全局作用域，然后进行词法分析，<br>词法分析过程会涉及到变量提升和函数声明提前处理，<br>即词法分析到变量声明会先判断当前域到全局域有没有该变量声明，如果有，就会将该变量挂到该作用域的对象上，<br>如果到全局域都没有则以全局为背景，新建该变量，并为其分配内存，<br>对于基本类型，变量中会保存它的值，对于对象，变量中会保存值所在内存的内存地址，<br>在一定场景下，这里就相当于发生了变量提升，把变量从局部提升到了全局，或者将声明提前到了使用之前，<br><b>避免变量提升</b>可以使用es6的let 关键字或者使用立即执行实现变量声明使用，但要注意使用let重复声明会报错，var 会同名覆盖；<br>当遇到函数声明时，会直接按声明顺序，将声明提前到代码顶端，<br><b>重复声明</b> 的函数会被后者覆盖，<br>如果变量名与函数名相同，则无论原来词法位置如何，先将函数声明提前到顶端，不再进行变量声明，变量名在哪赋值，则原函数在哪被覆盖，<br>覆盖之前调用使用原函数<br>提前之后会为函数创建作用域，<br>这时创建的作用域就是函数的 【【scope】】属性，保存着指向父域到全局域的指针<br>（指针就是指向活动对象的一个地址，全局域浏览器环境就是windows,nodejs环境就是global）<br>将来执行时会根据此指针建立作用域链，作用域链就是指针列表，指向不同层级作用域的内存，在里面取值<br>以上就基本上是编译过程，除了一些特定的编译规则，编译过程还会会使用大量技巧进行优化提升编译速度<br>但在使用js时，需要注意try-catch,with和eval三个语法关键字的使用，因为在使用它们时，会创建块级作用域，<br>破坏掉编译器原有的创建管理作用域的规则，在编译时，编译器也就不会对其中的代码进行优化，最终导致性能变差</p>
<p>运行过程，基本就是在运行函数，函数在运行时会首先根据【【scope】】属性拿到父域到全局的指针，创建指针列表即作用域链，<br>然后创建函数执行的局部作用域，将函数中声明的变量挂到局部作用域活动对象上，然后将局部作用域指针推向作用域链前端，<br>在用到变量值时，会根据作用域链依次查找取值<br>函数执行结束后，局部活动对象被销毁，作用域链被销毁，进行垃圾回收<br>但是对于声明在一个函数内部的函数来说，这个声明的函数在声明时，就会包含其父域的活动对象，<br>因此在外部使用该函数时，可以访问到其父域的变量，实现了父域访问子域变量，延长了变量的使用范围，也就是常见的闭包现象，<br>缺点就是闭包的函数执行完毕后，因为本身【【scope】】会指向父域的活动对象，所以父域的活动对象始终不会被回收,除非闭包函数被销毁<br>从而有可能造成内存泄露，为什么说有可能，因为父活动对象占的内存其实是比较小的，造成内存泄露的真正原因是使用闭包易造成循环引用，<br>尤其是闭包作用域中保存dom结点时，如果是在IE中，dom和bom都是以C++的COM对象保存的，垃圾回收机制是技术策略，<br>因此循环引用的话，永远都不会被回收</p>
<p>补充，对于未以分号结尾的语句，会采用能合就合的原则，即，会尝试和下一行语句合并执行，如果能合并执行就合并执行，<br>不能合并执行就在中间加分号再执行，如果再执行不了就会报错<br>好处就是对于条件判断语句可进行一行一行判断<br>坏处就是如果下一行以大括号开头，上一行语句就会变成函数，导致出现意想不到的结果<br>两个例外，<br>对于return，break,continue语句不会做尝试合并；<br>对于++，–自增自减符后没有分号，上一行也没分号情况，自增自减会和下一行合并，上一行自行添加分号</p>
<p>以上即是我所了解的js运行机制</p>
<h1 id="3-关于对象继承"><a href="#3-关于对象继承" class="headerlink" title="3.关于对象继承"></a>3.关于对象继承</h1><p>3.0  new 操作符调用构造函数 执行过程<br>  1.创建或者构造一个全新的对象<br>  2.将构造函数的作用域赋给这个新的对象,<br>  3.执行构造函数 (为这个新对象添加属性) ，第二，三步相当于func.call(newobj)<br>  4.如果构造函数没有返回值或返回值非对象，则返回新对象，否则返回构造函数return的对象</p>
<p>3.1 继承的6种方式及优缺点<br>    <b>第一种原型链方式</b>，子类的原型对象指向父类的实例<br>    缺点<br>        给原型添加方法必须要在替换原型的语句之后；<br>        不能实现多继承（原型指向多个父对象）；<br>        所有属性共享<br>        无法传递参数到父类进行初始化<br>    <b>第二种借助构造函数</b>，在子类构造函数中使用call或者apply执行父类构造函数<br>    优点<br>        可以实现多继承<br>        可以传递参数<br>        方法属性不共享<br>    缺点<br>        只能继承构造函数中属性，不能继承原型上方法，不能复用方法<br>        实例仅为子类实例，不是父类实例<br>    <b>第三种组合继承</b>，以上两组结合在一起，两种方式都执行<br>    缺点<br>        要调用两次父类构造函数，影响性能<br>        实例属性和原型属性各占一份，同名覆盖机制，重复占内存，没必要<br>    <b>第四种原型式继承</b>，借助object()或者object.create()函数,缺点同原型链方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(o)&#123;</div><div class="line"> function F()&#123;&#125;</div><div class="line"> F.prototype = o;</div><div class="line"> return new F();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><b>第五种寄生式继承</b>，利用原型式继承和增强对象过程的封装函数创建子类，缺点同原型链方式<br><b>第六种寄生组合式继承</b>，保留借助构造函数部分，原型部分功能借助中间函数处理，<br>中间函数借助object拿到父类prototype，给到子类的prototype,从而完美解决组合继承的缺点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function inheritPrototype(subType,superType)&#123;</div><div class="line">  var prototype = object(superType.prototype)</div><div class="line">  prototype.constructor = subType</div><div class="line">  subType.prototype = prototype</div><div class="line">&#125;</div><div class="line">subType.prototype.__proto__ = superType</div></pre></td></tr></table></figure>
<p>3.2 es6 使用class extend实现继承<br>使用class声明构造函数时，本来挂在this上的属性，放在constructor（）函数里面执行初始化，<br>挂在prototype上的方法直接放在class里面声明</p>
<p>使用extend继承时，需要在constructor里面先执行super函数才能使用this关键字，<br>增强方法同样直接在class中和constructor并列声明，相当于挂在prototype上</p>
<p>注意super函数只能在consructor中运行；super用作对象在constructor中使用时，相当于this,<br>添加属性会添加在当前对象上，运行函数时会调用继承的父类的方法</p>
<p>还有就是class extend继承null和 什么也不继承是，相当于继承Function.prototype<br>继承Object时，子类就相当于object 的复制，子类实例就是object实例</p>
<h1 id="4-关于this-四种使用场景"><a href="#4-关于this-四种使用场景" class="headerlink" title="4.关于this 四种使用场景"></a>4.关于this 四种使用场景</h1><p>   普通函数执行，指向全局作用域<br>   对象属性方法调用，指向调用对象<br>   call,apply中强制绑定对象，this执行绑定的对象<br>   构造函数中this指向构造的新对象<br>   （箭头函数中this,指向词法作用域的父域）</p>
<h1 id="5-js文件位置"><a href="#5-js文件位置" class="headerlink" title="5.js文件位置"></a>5.js文件位置</h1><p>   放html底部原因：<br>   下载解析执行过程是阻断式的，会停止页面渲染，造成白屏，影响用户体验；<br>   另外JS中如果有对dom的操作，页面中还没有dom,获取不到，是不符合逻辑的，会报错</p>
<p>   哪些js功能文件可以放顶部：<br>   与css相关的js,比如rem单位的换算，需要根据根结点进行设置<br>   使用的框架需要在根结点将浏览器支持的样式罗列出来</p>
<h1 id="6-什么情况下用内部文件，内部文件比外部文件好处在哪？"><a href="#6-什么情况下用内部文件，内部文件比外部文件好处在哪？" class="headerlink" title="6.什么情况下用内部文件，内部文件比外部文件好处在哪？"></a>6.什么情况下用内部文件，内部文件比外部文件好处在哪？</h1><p>   内部文件相比外部文件最大好处就是性能提升，因为访问外部文件时，不管文件大小都会造成一次网络请求链接，请求服务器，下载文件，<br>   解析文件，除了文件本身代码外，还要处理文件头文件尾的请求，增加了链接数，从而造成性能影响<br>   对于功能短小精悍，不会被到处复用的js代码不适合采用外部文件，应该采用内部文件写法，尤其对手机端页面有性能提升</p>
<h1 id="7-开发过程避免缓存方法"><a href="#7-开发过程避免缓存方法" class="headerlink" title="7.开发过程避免缓存方法"></a>7.开发过程避免缓存方法</h1><p>   在浏览器开启禁用缓存的模式<br>   手动清缓存 ctrl+shfit+del<br>   引用的文件名添加随机数，浏览器根据文件名不同，就会重新获取资源更新缓存</p>
<h1 id="8-使用严格模式弊端及解决办法"><a href="#8-使用严格模式弊端及解决办法" class="headerlink" title="8.使用严格模式弊端及解决办法"></a>8.使用严格模式弊端及解决办法</h1><p>   在代码压缩时，’use strict’ 这一行可能不在位于第一行，<br>   或者后续代码不需要在严格模式下执行，被压缩在了严格模式范围内，导致了全部以严格模式执行</p>
<p>   解决办法就是，将需要严格模式执行的代码放在匿名函数中，形成代码块，在函数中使用严格模式</p>
<h1 id="9-立即执行函数好处"><a href="#9-立即执行函数好处" class="headerlink" title="9.立即执行函数好处"></a>9.立即执行函数好处</h1><p>   避免变量污染：有些变量仅在小功能内使用，将小功能封装起来，就可以避免这些变量暴露到全局，<br>   另外函数本身没有函数名，不会增加全局变量<br>   提升性能：功能所需变量全都在函数内时，查找变量快<br>   有利于压缩：一部分代码执行需要用到的变量变量名太长，将这段代码封装成立即执行函数，将长变量名以参数形式传进去<br>   避免全局命名冲突：一段代码需要用到两个代表不同功能但名称相同的变量，可以将该段代码封装成立即执行函数，<br>   将其中一个变量以参数形式传递进来，达到换名的目的<br>   保存闭包状态：循环执行异步代码时，将异步代码用立即执行函数包裹，函数内可保存本次循环的状态<br>   改变代码运行顺序：umd,通用模块规范，function（fn）{fn()}()</p>
<h1 id="10-变量类型"><a href="#10-变量类型" class="headerlink" title="10.变量类型"></a>10.变量类型</h1><p>   根据当前变量的值的类型确定<br>   如果想要进行标记，方法有三种<br>   初始化时指定相应类型值<br>   使用匈牙利标记法，用单字母表示类型，添加到变量命中，例sName 代表string类型<br>   使用注释，变量声明时，在旁边添加注释</p>
<h1 id="11-null-vs-undefined"><a href="#11-null-vs-undefined" class="headerlink" title="11.null vs undefined"></a>11.null vs undefined</h1><p>   转数字时，null –&gt;0;undefined–&gt;NaN<br>   undefined可以当做windows对象上的一个属性，null不行</p>
<h1 id="12-类型转换"><a href="#12-类型转换" class="headerlink" title="12. 类型转换"></a>12. 类型转换</h1><p>基本类型包括，undefined，null,boolean,string,number</p>
<p>基本类型 —&gt; boolean   Boolean(someval) 相当于 !!someval<br>undefined，null,NaN,’’,+0,-0 —&gt; false<br>其他 —&gt; true </p>
<p>基本类型 —&gt; string  String（someval）相当于 someval+’’<br>一般情况直接加引号<br>[] —&gt; ‘’<br>{} —&gt; ‘[object object]’</p>
<p>基本类型—&gt;number  + someval  相当于 Number（someval）<br>undefined,{} —&gt; NaN<br>false, null,’’,[],—&gt; 0<br>true —&gt; 1<br>‘123’ —&gt; 123<br>‘abc’ —&gt; NaN<br>[]—&gt; toString —&gt; ‘’ —&gt; 0<br>{} —&gt; valueOf —&gt; {} —&gt; toString —&gt; ‘[object object]’ —&gt; NaN</p>
<p>基本类型 —&gt;对象<br>undefined，null —&gt; {}<br>true/123 —&gt; {initval:true/123}<br>‘abc’ —&gt; {initval:’abc’,length:3,0:’a’,1:’b’,2:’c’}</p>
<p>对象 —&gt;基本类型</p>
<p>关于–对象分类：<br>内部对象（错误对象；常用对象：Boolean,Number,String,Object,Array,Function,Date,Exec;内置对象：Math,global,Json）<br>宿主对象：windows,document<br>自定义对象</p>
<p>关于–属性访问<br>obj.someprop—&gt;检查obj是不是null/undefined—&gt;是|不是—&gt;报错|是不是Object,不是的话转object—&gt;取值<br>obj[someval]—&gt;检查obj是不是null/undefined—&gt;是|不是—&gt;报错|是不是Object,不是的话转object—&gt;计算someval拿到string—&gt;取值</p>
<p>Boolean —&gt;true<br>Number —&gt;基本类型转的|{}/{a:1}|Date—&gt;相应值|NaN|时间戳<br>Array.toString:数组每一项转字符串<br>Function.toString:原代码字符串形式<br>Date.toString:日期和时间组合形式<br>Exec.toString:正则字符串形式</p>
<p>运算转换</p>
<p>Number()参数不能有非数字<br>parseInt()参数只能为字符串，非字符串会进行强制转化字符串，可含非数字，但不能以非数字开头<br>一元操作符对任何数据类型有效，得到数字</p>
<p>&#43;二元运算侧重转字符串，然后进行字符串拼接<br>其中一个为字符串或者两个都是对象时，转字符串拼接<br>undefined,null,Boolean,数字混合运算+时，会被转数字再计算<br>{}为第一个运算值时，会被当做函数结束，不参与计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">null + null --&gt; 0</div><div class="line">undefined + null --&gt; NaN</div><div class="line">[] + [] --&gt; &apos;&apos;</div><div class="line">1 + [1,2] --&gt; &apos;11,2&apos;</div><div class="line">1 + &#123;a:1&#125; --&gt; &apos;1[object object]&apos;</div><div class="line">&#123;a:1&#125; + 1 --&gt; 1</div><div class="line">&#123;&#125; + &#123;&#125; --&gt; NaN</div><div class="line">(&#123;&#125;) + &#123;&#125; --&gt; &apos;[object object][object object]&apos;</div><div class="line">[] + &#123;&#125; --&gt; &apos;[object object]&apos;</div><div class="line">&#123;&#125; + [] --&gt; 0</div><div class="line">var a = &#123;&#125;</div><div class="line">a + a --&gt;&apos;[object object][object object]&apos;</div></pre></td></tr></table></figure></p>
<p>&#42;/- 转数字，进行相减,如果不能转数字，返回NaN</p>
<p>&gt;/&lt; 侧重转数字<br>string &lt; string 字典比较<br>非字符串&lt;非字符串/字符串 都转数字然后比较</p>
<p>string == number 字符串转数字<br>boolean == 其他类型 二者转数字然后比较<br>null == undefined —&gt;true undefined和null只与对方和自己==比较时为true，其他均为false<br>null === undefined —&gt;false<br>非对象 == 对象 与数字比较object转数字，与字符串比较二者转数字再比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&apos;0&apos; == null  //false</div><div class="line">&apos;0&apos; == undefined  //false</div><div class="line">&apos;0&apos; == false  //true</div><div class="line">&apos;0&apos; == NaN  //false</div><div class="line">&apos;0&apos; == 0  //true</div><div class="line">&apos;0&apos; == &apos;&apos;  //true</div><div class="line"></div><div class="line">false == null  //false</div><div class="line">false == undefined  //false</div><div class="line">false == NaN  //false</div><div class="line">false == 0  //true</div><div class="line">false == &apos;&apos;  //true</div><div class="line">false == []  //true</div><div class="line">false == &#123;&#125; //false</div><div class="line"></div><div class="line">&apos;&apos; == null  //false</div><div class="line">&apos;&apos; == undefined  //false</div><div class="line">&apos;&apos; == NaN  //false</div><div class="line">&apos;&apos; == 0  //true</div><div class="line">&apos;&apos; == []  //true</div><div class="line">&apos;&apos; == &#123;&#125; //false</div><div class="line"></div><div class="line">0 == null  //false</div><div class="line">0 == undefined  //false</div><div class="line">0 == NaN  //false</div><div class="line">0 == []  //true</div><div class="line">0 == &#123;&#125; //false</div><div class="line"></div><div class="line">[] == ![]</div></pre></td></tr></table></figure></p>
<p>&amp;&amp;和|| 计算结果根据短路原则判断到了哪里，返回最后一个进行判断的值</p>
<p>运算符优先级<br>属性访问.<br>一元操作符（+，-，++，–）<br>二元操作符（+-*/）<br>比较（&gt;,&lt;)<br>相等（==，===，！=）<br>与&amp;&amp;，或||<br>三目运算符<br>赋值</p>
<p>运算符结合性<br>除了一元操作符，三目运算符和赋值是右结合，其他都是左结合</p>
<p>减少小数计算误差<br>尽量不使用小数进行比较或运算<br>转整数计算，再转回相应位数小数<br>使用toFixed()四舍五入<br>两个情境需要重复计算时，保证前后书写顺序</p>
<h1 id="13-数组相关方法"><a href="#13-数组相关方法" class="headerlink" title="13. 数组相关方法"></a>13. 数组相关方法</h1><p><img src="/image/arrmethod.jpg" alt="arrmethod"></p>
<h1 id="14-字符串相关方法"><a href="#14-字符串相关方法" class="headerlink" title="14.字符串相关方法"></a>14.字符串相关方法</h1><p><img src="/image/strmethod.jpg" alt="strmethod"></p>
<h1 id="15-日期相关方法"><a href="#15-日期相关方法" class="headerlink" title="15.日期相关方法"></a>15.日期相关方法</h1><p>   一共 33个<br>   set/get（UTC）FullYear,Month,Date,Hours,Minutes,Seconds,Millseconds<br>   set/get Time<br>   get(UTC) Day<br>   getTimezoneOffset</p>
<h1 id="16-Math三个舍入方法"><a href="#16-Math三个舍入方法" class="headerlink" title="16. Math三个舍入方法"></a>16. Math三个舍入方法</h1><p>  Math.ceil:比值大的最小整数<br>  Math.round:四舍五入<br>  Math.floor:比值小的最大整数</p>
<h1 id="17-setInterval-注意问题"><a href="#17-setInterval-注意问题" class="headerlink" title="17. setInterval 注意问题"></a>17. setInterval 注意问题</h1><p>累积效应<br>代码执行时间大于间隔时间，后续调用会进行累积，累积会在短时间内连续触发</p>
<p>当用于动画时，因与显示器刷新频率不统一会造成视觉卡顿，解决办法如下：<br>一种是使用CSS3创建动画，根据显示器刷新执行动画<br>另一种是使用 requestAnimationframe(function(){})函数，也是在显示器刷新时执行<br>可以解决CSS3无法实现的，例如滚动控制等效果</p>
<h1 id="18-关于DOM"><a href="#18-关于DOM" class="headerlink" title="18. 关于DOM"></a>18. 关于DOM</h1><p>   document 三个属性<br>   url：地址栏中URL<br>   domain:域名，跨域域名 X；父域名到子域名 X；<br>   referer:上一页URL,可在跳转时，判断与当前页是否在同一域，是的话，就可以back,否则 location.href其他页面<br>   dom.getAttribute(‘style’),得到样式字符串<br>   dom.style 得到到样式对象<br>   dom.getAttribute(‘onclick’) ,得到代码字符串<br>   dom.onclick 得到函数对象</p>
<p>   动态合集<br>   使用时可能会造成死循环<br>   使用框架如Jquery获取的合集不具有动态性<br>   使用 queryselect(all)()获取到的也是静态合集</p>
<p>   动态合集生成原理：<br>   浏览器通过DOM树预先缓存起来，获取时，浏览器会通过缓存直接注册，创建一个变量返回</p>
<p>   静态合集生成原理：<br>   获取标识是一个CSS选择器，浏览器会先去解析字符串，判断是一个CSS选择器，<br>   分析选择器并创建一个选择器结构，浏览器根据DOM树创建一个静态文件，即DOM树的一个快照<br>   然后拿选择器和快照进行对比，符合选择器就放到合集中，知道整个快照对比完，再把合集的快照返回</p>
<h1 id="19-事件"><a href="#19-事件" class="headerlink" title="19. 事件"></a>19. 事件</h1><p>   绑定方式</p>
<p>   直接通过HTML属性绑定<br>   缺点<br>   有可能响应函数还未被解析就被触发<br>   事件名和回调1对1，修改繁琐<br>   响应执行时，作用域为全局，不同浏览器解析规则不同，造成某些对象无法访问</p>
<p>   使用dom属性绑定<br>   冒泡阶段执行<br>   缺点<br>   只能绑定一个响应，后续赋值会被覆盖</p>
<p>   IE attachEvent/detachEvent绑定/解绑<br>   冒泡阶段执行<br>   绑定多个时按按绑定顺序的逆序执行</p>
<p>   addEventListener()/removeEventListener()绑定/解绑<br>   第三个参数为对象时，passive属性为true时，会针对touchstart,touchend等特定事件通过开启两个线程，<br>   一个执行浏览器默认行为，一个执行JS进行优化</p>
<p>   事件优先级<br>   浏览器在绑定事件而不是JS在绑定事件</p>
<p>   1.html标签绑定事件会被dom属性事件覆盖<br>   2.html标签优先执行，即使被属性事件覆盖，则执行被覆盖的属性事件<br>   3.仅有监听事件和属性事件时，按绑定顺序执行，即事件对象的冒泡事件可能会在捕获事件之前执行</p>
<p>   event对象属性<br>   curentTarget:响应函数绑定的对象<br>   target:发生事件的对象</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-lt-script-gt-标签几个属性&quot;&gt;&lt;a href=&quot;#1-lt-script-gt-标签几个属性&quot; class=&quot;headerlink&quot; title=&quot;1.&amp;lt; script &amp;gt; 标签几个属性&quot;&gt;&lt;/a&gt;1.&amp;lt; script &amp;gt; 
    
    </summary>
    
    
      <category term="html" scheme="http://yoohannah.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>拖拽</title>
    <link href="http://yoohannah.github.io/post/react/course/drag.html"/>
    <id>http://yoohannah.github.io/post/react/course/drag.html</id>
    <published>2018-12-04T13:19:37.000Z</published>
    <updated>2018-12-22T05:13:40.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-React-实现拖放的技术要点"><a href="#使用-React-实现拖放的技术要点" class="headerlink" title="使用 React 实现拖放的技术要点"></a>使用 React 实现拖放的技术要点</h1><p>1.如何使用 React 的鼠标事件系统<br>2.如何判断拖放开始和拖放结束<br>3.如何实现拖放元素的位置移动 (可分为两种，一种是直接拖着具体要被移动的dom移动；另外一种是具体dom留在原位，拖着具体dom的影子移动，确定位置后，再将具体的dom放过去)<br>4.拖放状态在组件中如何维护</p>
<p>鼠标移动可能会超出要移动的组件和他的父组件，除了在document上监听，还可以在一个全局透明遮罩层上监听MouseMove和MouseUp好处：拖放过程不会选中其他任何元素，防止点击到其他组件</p>
<p>其他情景思考：<br>每个条目高度不一致，如何确定移动位置？<br>条目所在的列表有折叠，存在滚动条，如何根据滚动条确定位置？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import React, &#123; Component &#125; from &quot;react&quot;;</div><div class="line"></div><div class="line">require(&quot;./DndSample.css&quot;);</div><div class="line"></div><div class="line">const list = [];</div><div class="line">for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">  list.push(`Item $&#123;i + 1&#125;`);</div><div class="line">&#125;</div><div class="line"></div><div class="line">const move = (arr, startIndex, toIndex) =&gt; &#123;</div><div class="line">  arr = arr.slice();</div><div class="line">  arr.splice(toIndex, 0, arr.splice(startIndex, 1)[0]);</div><div class="line">  return arr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const lineHeight = 42;</div><div class="line">class DndSample extends Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">    this.state.list = list;</div><div class="line">  &#125;</div><div class="line">  state = &#123;</div><div class="line">    dragging: false,</div><div class="line">    draggingIndex: -1,</div><div class="line">    startPageY: 0,</div><div class="line">    offsetPageY: 0,</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  handleMounseDown = (evt, index) =&gt; &#123;</div><div class="line">    this.setState(&#123;</div><div class="line">      dragging: true,</div><div class="line">      startPageY: evt.pageY,</div><div class="line">      currentPageY: evt.pageY,</div><div class="line">      draggingIndex: index,</div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line">  handleMouseUp = () =&gt; &#123;</div><div class="line">    this.setState(&#123; dragging: false, startPageY: 0, draggingIndex: -1 &#125;);</div><div class="line">  &#125;;</div><div class="line">  //如果往下滑，就一次把下一条数据交换位置，如果往上移动，就一次把上一条数据交换位置，</div><div class="line">  handleMouseMove = evt =&gt; &#123;</div><div class="line">    let offset = evt.pageY - this.state.startPageY;</div><div class="line">    const draggingIndex = this.state.draggingIndex;</div><div class="line">    if (offset &gt; lineHeight &amp;&amp; draggingIndex &lt; this.state.list.length - 1) &#123;</div><div class="line">      // move down</div><div class="line">      offset -= lineHeight;</div><div class="line">      this.setState(&#123;</div><div class="line">        list: move(this.state.list, draggingIndex, draggingIndex + 1),</div><div class="line">        draggingIndex: draggingIndex + 1,</div><div class="line">        startPageY: this.state.startPageY + lineHeight,</div><div class="line">      &#125;);</div><div class="line">    &#125; else if (offset &lt; -lineHeight &amp;&amp; draggingIndex &gt; 0) &#123;</div><div class="line">      // move up</div><div class="line">      offset += lineHeight;</div><div class="line">      this.setState(&#123;</div><div class="line">        list: move(this.state.list, draggingIndex, draggingIndex - 1),</div><div class="line">        draggingIndex: draggingIndex - 1,</div><div class="line">        startPageY: this.state.startPageY - lineHeight,</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">    this.setState(&#123; offsetPageY: offset &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  getDraggingStyle(index) &#123;</div><div class="line">    if (index !== this.state.draggingIndex) return &#123;&#125;;</div><div class="line">    return &#123;</div><div class="line">      backgroundColor: &quot;#eee&quot;,</div><div class="line">      transform: `translate(10px, $&#123;this.state.offsetPageY&#125;px)`,</div><div class="line">      opacity: 0.5,</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;dnd-sample&quot;&gt;</div><div class="line">        &lt;ul&gt;</div><div class="line">          &#123;this.state.list.map((text, i) =&gt; (</div><div class="line">            &lt;li</div><div class="line">              key=&#123;text&#125;</div><div class="line">              onMouseDown=&#123;evt =&gt; this.handleMounseDown(evt, i)&#125;</div><div class="line">              style=&#123;this.getDraggingStyle(i)&#125;</div><div class="line">            &gt;</div><div class="line">              &#123;text&#125;</div><div class="line">            &lt;/li&gt;</div><div class="line">          ))&#125;</div><div class="line">        &lt;/ul&gt;</div><div class="line">        &#123;this.state.dragging &amp;&amp; ( //在一个遮罩层上监听MouseMove和MouseUp</div><div class="line">          &lt;div</div><div class="line">            className=&quot;dnd-sample-mask&quot;</div><div class="line">            onMouseMove=&#123;this.handleMouseMove&#125;</div><div class="line">            onMouseUp=&#123;this.handleMouseUp&#125;</div><div class="line">          /&gt;</div><div class="line">        )&#125;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default DndSample;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">.dnd-sample ul &#123;</div><div class="line">  display: inline-block;</div><div class="line">  margin: 0;</div><div class="line">  padding: 0;</div><div class="line">  background-color: #eee;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.dnd-sample li &#123;</div><div class="line">  cursor: default;</div><div class="line">  list-style: none;</div><div class="line">  border-bottom: 1px solid #ddd;</div><div class="line">  padding: 10px;</div><div class="line">  margin: 0;</div><div class="line">  width: 300px;</div><div class="line">  background-color: #fff;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.dnd-sample-mask &#123;</div><div class="line">  position: fixed;</div><div class="line">  left: 0;</div><div class="line">  right: 0;</div><div class="line">  top: 0;</div><div class="line">  bottom: 0;</div><div class="line">  background: rgba(0, 0, 0, 0.1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-React-实现拖放的技术要点&quot;&gt;&lt;a href=&quot;#使用-React-实现拖放的技术要点&quot; class=&quot;headerlink&quot; title=&quot;使用 React 实现拖放的技术要点&quot;&gt;&lt;/a&gt;使用 React 实现拖放的技术要点&lt;/h1&gt;&lt;p&gt;1.如何使用
    
    </summary>
    
    
      <category term="react" scheme="http://yoohannah.github.io/tags/react/"/>
    
  </entry>
  
</feed>
